 @ Test public static void megamorphicVarTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " var ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } }
 public static void resolveConfig ( Environment env , final ImmutableSettings . Builder settingsBuilder ) { try { Files . walkFileTree ( env . configFile ( ) . toPath ( ) , EnumSet . of ( FileVisitOption . FOLLOW_LINKS ) , Integer . MAX_VALUE , new SimpleFileVisitor < Path > ( ) { @ Override public FileVisitResult visitFile ( Path file , BasicFileAttributes attrs ) throws IOException { if ( file . getFileName ( ) . toString ( ) . startsWith ( " logging . " ) ) { loadConfig ( file , settingsBuilder ) ; } return FileVisitResult . CONTINUE ; } } ) ; } catch ( IOException ioe ) { throw new ElasticsearchException ( " Failed ▁ to ▁ load ▁ logging ▁ configuration " , ioe ) ; } }
 static void PrintHelp ( ) { System . out . println ( " \n Usage : ▁ ▁ LZMA ▁ < e | d > ▁ [ < switches > . . . ] ▁ inputFile ▁ outputFile \n " + " ▁ ▁ e : ▁ encode ▁ file \n " + " ▁ ▁ d : ▁ decode ▁ file \n " + " ▁ ▁ b : ▁ Benchmark \n " + " < Switches > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ dictionary ▁ - ▁ [ 0,28 ] , ▁ default : ▁ 23 ▁ ( 8MB ) \n " + " ▁ ▁ - fb { N } : ▁ set ▁ number ▁ of ▁ fast ▁ bytes ▁ - ▁ [ 5 , ▁ 273 ] , ▁ default : ▁ 128 \n " + " ▁ ▁ - lc { N } : ▁ set ▁ number ▁ of ▁ literal ▁ context ▁ bits ▁ - ▁ [ 0 , ▁ 8 ] , ▁ default : ▁ 3 \n " + " ▁ ▁ - lp { N } : ▁ set ▁ number ▁ of ▁ literal ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 0 \n " + " ▁ ▁ - pb { N } : ▁ set ▁ number ▁ of ▁ pos ▁ bits ▁ - ▁ [ 0 , ▁ 4 ] , ▁ default : ▁ 2 \n " + " ▁ ▁ - mf { MF _ ID } : ▁ set ▁ Match ▁ Finder : ▁ [ bt2 , ▁ bt4 ] , ▁ default : ▁ bt4 \n " + " ▁ ▁ - eos : ▁ ▁ ▁ write ▁ End ▁ Of ▁ Stream ▁ marker \n " ) ; }
 public static byte [ ] convertObjectToJsonBytes ( Object object ) throws IOException { ObjectMapper mapper = new ObjectMapper ( ) ; mapper . setSerializationInclusion ( JsonInclude . Include . NON_NULL ) ; JodaModule module = new JodaModule ( ) ; DateTimeFormatterFactory formatterFactory = new DateTimeFormatterFactory ( ) ; formatterFactory . setIso ( DateTimeFormat . ISO . DATE ) ; module . addSerializer ( DateTime . class , new DateTimeSerializer ( new JacksonJodaFormat ( formatterFactory . createDateTimeFormatter ( ) . withZoneUTC ( ) ) ) ) ; mapper . registerModule ( module ) ; return mapper . writeValueAsBytes ( object ) ; }
 public static void main ( String [ ] args ) throws Exception { new HelloJDBIService ( ) . run ( args ) ; }
 public static String canonicalize ( final String path ) { int state = START ; for ( int i = path . length ( ) - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( c ) { case ' / ' : if ( state == FIRST_SLASH ) { return realCanonicalize ( path , i + 1 , FIRST_SLASH ) ; } else if ( state == ONE_DOT ) { return realCanonicalize ( path , i + 2 , FIRST_SLASH ) ; } else if ( state == TWO_DOT ) { return realCanonicalize ( path , i + 3 , FIRST_SLASH ) ; } state = FIRST_SLASH ; break ; case ' . ' : if ( state == FIRST_SLASH || state == START ) { state = ONE_DOT ; } else if ( state == ONE_DOT ) { state = TWO_DOT ; } else { state = NORMAL ; } break ; default : state = NORMAL ; break ; } } return path ; }
 public static void main ( String [ ] args ) { I i = Foo :: foo ; }
 private static String realCanonicalize ( final String path , final int lastDot , final int initialState ) { int state = initialState ; int eatCount = 0 ; int tokenEnd = path . length ( ) ; final List < String > parts = new ArrayList < > ( ) ; for ( int i = lastDot - 1 ; i >= 0 ; -- i ) { final char c = path . charAt ( i ) ; switch ( state ) { case NORMAL : { if ( c == ' / ' ) { state = FIRST_SLASH ; if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } } break ; } case FIRST_SLASH : { if ( c == ' . ' ) { state = ONE_DOT ; } else if ( c == ' / ' ) { if ( eatCount > 0 ) { -- eatCount ; tokenEnd = i ; } else { parts . add ( path . substring ( i + 1 , tokenEnd ) ) ; tokenEnd = i ; } } else { state = NORMAL ; } break ; } case ONE_DOT : { if ( c == ' . ' ) { state = TWO_DOT ; } else if ( c == ' / ' ) { if ( i + 2 != tokenEnd ) { parts . add ( path . substring ( i + 2 , tokenEnd ) ) ; } tokenEnd = i ; state = FIRST_SLASH ; } else { state = NORMAL ; } break ; } case TWO_DOT : { if ( c == ' / ' ) { if ( i + 3 != tokenEnd ) { parts . add ( path . substring ( i + 3 , tokenEnd ) ) ; } tokenEnd = i ; eatCount ++ ; state = FIRST_SLASH ; } else { state = NORMAL ; } } } } final StringBuilder result = new StringBuilder ( ) ; if ( tokenEnd != 0 ) { result . append ( path . substring ( 0 , tokenEnd ) ) ; } for ( int i = parts . size ( ) - 1 ; i >= 0 ; -- i ) { result . append ( parts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . toString ( ) ; }
 private static void assertEndDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getSlutDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; }
 private static File pathOfFileInDefaultFiles ( String filePath ) { return new File ( MultipleExtensionPluginWithPluginManagerIntegrationTest . class . getClassLoader ( ) . getResource ( " defaultFiles / " + filePath ) . getFile ( ) ) ; }
 private static void setInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; if ( info != null ) { info . setInstanceofed ( ) ; } }
 public static org . apache . axis . encoding . Serializer getSerializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanSerializer ( _javaType , _xmlType , typeDesc ) ; }
 @ Test public static void multiThreadedLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final Bindings b = e . createBindings ( ) ; final ScriptContext origContext = e . getContext ( ) ; final ScriptContext newCtxt = new SimpleScriptContext ( ) ; newCtxt . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; final String sharedScript = " foo " ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' original ▁ context ' ; " , origContext ) , null ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' new ▁ context ' ; " , newCtxt ) , null ) ; final Thread t1 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t2 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " new ▁ context " , 1000 ) ) ; t1 . start ( ) ; t2 . start ( ) ; t1 . join ( ) ; t2 . join ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' newer ▁ context ' ; " , newCtxt ) , " newer ▁ context " ) ; final Thread t3 = new Thread ( new ScriptRunner ( e , origContext , sharedScript , " original ▁ context " , 1000 ) ) ; final Thread t4 = new Thread ( new ScriptRunner ( e , newCtxt , sharedScript , " newer ▁ context " , 1000 ) ) ; t3 . start ( ) ; t4 . start ( ) ; t3 . join ( ) ; t4 . join ( ) ; assertEquals ( e . eval ( sharedScript ) , " original ▁ context " ) ; assertEquals ( e . eval ( sharedScript , newCtxt ) , " newer ▁ context " ) ; }
 public static void loadConfig ( Path file , ImmutableSettings . Builder settingsBuilder ) { try { settingsBuilder . loadFromUrl ( file . toUri ( ) . toURL ( ) ) ; } catch ( FailedToResolveConfigException | NoClassDefFoundError | MalformedURLException e ) { } }
 synchronized static FileLruCache getCache ( Context context ) throws IOException { if ( imageCache == null ) { imageCache = new FileLruCache ( context . getApplicationContext ( ) , TAG , new FileLruCache . Limits ( ) ) ; } return imageCache ; }
 static InputStream interceptAndCacheImageStream ( Context context , HttpURLConnection connection ) throws IOException { InputStream stream = null ; if ( connection . getResponseCode ( ) == HttpURLConnection . HTTP_OK ) { URL url = connection . getURL ( ) ; stream = connection . getInputStream ( ) ; try { if ( isCDNURL ( url . toURI ( ) ) ) { FileLruCache cache = getCache ( context ) ; stream = cache . interceptAndPut ( url . toString ( ) , new BufferedHttpInputStream ( stream , connection ) ) ; } } catch ( IOException e ) { } catch ( URISyntaxException e ) { } } return stream ; }
 public static void configure ( Settings settings ) { if ( loaded ) { return ; } loaded = true ; Environment environment = new Environment ( settings ) ; ImmutableSettings . Builder settingsBuilder = settingsBuilder ( ) . put ( settings ) ; resolveConfig ( environment , settingsBuilder ) ; settingsBuilder . putProperties ( " elasticsearch . " , System . getProperties ( ) ) . putProperties ( " es . " , System . getProperties ( ) ) . replacePropertyPlaceholders ( ) ; Properties props = new Properties ( ) ; for ( Map . Entry < String , String > entry : settingsBuilder . build ( ) . getAsMap ( ) . entrySet ( ) ) { String key = " log4j . " + entry . getKey ( ) ; String value = entry . getValue ( ) ; if ( replacements . containsKey ( value ) ) { value = replacements . get ( value ) ; } if ( key . endsWith ( " . value " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . endsWith ( " . type " ) ) { props . setProperty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { props . setProperty ( key , value ) ; } } PropertyConfigurator . configure ( props ) ; }
 public static final void init ( String filename ) { if ( props == null ) { props = new Props ( filename ) ; } else { throw new RuntimeException ( " The ▁ properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } }
 public static final void init ( int t ) { if ( props == null ) { props = new Props ( t ) ; } else { throw new RuntimeException ( " The ▁ Properties ▁ systems ▁ settings ▁ are ▁ already ▁ initialised ! " ) ; } }
 @ Deprecated public static List < ListViewColumn > getDefaultColumns ( ) { return ListViewColumn . createDefaultInitialColumnList ( ) ; }
 @ BeforeClass public static void initTestData ( ) throws IOException { SjukfallIntygGenerator generator = new SjukfallIntygGenerator ( LOCATION_INTYGSDATA ) ; intygDataList = generator . generate ( ) . get ( ) ; assertTrue ( " Expected ▁ 16 ▁ but ▁ was ▁ " + intygDataList . size ( ) , intygDataList . size ( ) == 16 ) ; }
 public static void main ( String [ ] args ) throws Exception { System . out . println ( " \n LZMA ▁ ( Java ) ▁ 4.61 ▁ ▁ 2008-11-23 \n " ) ; if ( args . length < 1 ) { PrintHelp ( ) ; return ; } CommandLine params = new CommandLine ( ) ; if ( ! params . Parse ( args ) ) { System . out . println ( " \n Incorrect ▁ command " ) ; return ; } if ( params . Command == CommandLine . kBenchmak ) { int dictionary = ( 1 << 21 ) ; if ( params . DictionarySizeIsDefined ) dictionary = params . DictionarySize ; if ( params . MatchFinder > 1 ) throw new Exception ( " Unsupported ▁ match ▁ finder " ) ; SevenZip . LzmaBench . LzmaBenchmark ( params . NumBenchmarkPasses , dictionary ) ; } else if ( params . Command == CommandLine . kEncode || params . Command == CommandLine . kDecode ) { java . io . File inFile = new java . io . File ( params . InFile ) ; java . io . File outFile = new java . io . File ( params . OutFile ) ; java . io . BufferedInputStream inStream = new java . io . BufferedInputStream ( new java . io . FileInputStream ( inFile ) ) ; java . io . BufferedOutputStream outStream = new java . io . BufferedOutputStream ( new java . io . FileOutputStream ( outFile ) ) ; boolean eos = false ; if ( params . Eos ) eos = true ; if ( params . Command == CommandLine . kEncode ) { SevenZip . Compression . LZMA . Encoder encoder = new SevenZip . Compression . LZMA . Encoder ( ) ; if ( ! encoder . SetAlgorithm ( params . Algorithm ) ) throw new Exception ( " Incorrect ▁ compression ▁ mode " ) ; if ( ! encoder . SetDictionarySize ( params . DictionarySize ) ) throw new Exception ( " Incorrect ▁ dictionary ▁ size " ) ; if ( ! encoder . SetNumFastBytes ( params . Fb ) ) throw new Exception ( " Incorrect ▁ - fb ▁ value " ) ; if ( ! encoder . SetMatchFinder ( params . MatchFinder ) ) throw new Exception ( " Incorrect ▁ - mf ▁ value " ) ; if ( ! encoder . SetLcLpPb ( params . Lc , params . Lp , params . Pb ) ) throw new Exception ( " Incorrect ▁ - lc ▁ or ▁ - lp ▁ or ▁ - pb ▁ value " ) ; encoder . SetEndMarkerMode ( eos ) ; encoder . WriteCoderProperties ( outStream ) ; long fileSize ; if ( eos ) fileSize = - 1 ; else fileSize = inFile . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) outStream . write ( ( int ) ( fileSize >>> ( 8 * i ) ) & 0xFF ) ; encoder . Code ( inStream , outStream , - 1 , - 1 , null ) ; } else { int propertiesSize = 5 ; byte [ ] properties = new byte [ propertiesSize ] ; if ( inStream . read ( properties , 0 , propertiesSize ) != propertiesSize ) throw new Exception ( " input ▁ . lzma ▁ file ▁ is ▁ too ▁ short " ) ; SevenZip . Compression . LZMA . Decoder decoder = new SevenZip . Compression . LZMA . Decoder ( ) ; if ( ! decoder . SetDecoderProperties ( properties ) ) throw new Exception ( " Incorrect ▁ stream ▁ properties " ) ; long outSize = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = inStream . read ( ) ; if ( v < 0 ) throw new Exception ( " Can ' t ▁ read ▁ stream ▁ size " ) ; outSize |= ( ( long ) v ) << ( 8 * i ) ; } if ( ! decoder . Code ( inStream , outStream , outSize ) ) throw new Exception ( " Error ▁ in ▁ data ▁ stream " ) ; } outStream . flush ( ) ; outStream . close ( ) ; inStream . close ( ) ; } else throw new Exception ( " Incorrect ▁ command " ) ; return ; }
 static InputStream getCachedImageStream ( URI url , Context context ) { InputStream imageStream = null ; if ( url != null ) { if ( isCDNURL ( url ) ) { try { FileLruCache cache = getCache ( context ) ; imageStream = cache . get ( url . toString ( ) ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , e . toString ( ) ) ; } } } return imageStream ; }
 public static String getStackTrace ( final Throwable ex ) { final StringWriter sw = new StringWriter ( ) ; final PrintWriter pw = new PrintWriter ( sw , true ) ; ex . printStackTrace ( pw ) ; pw . flush ( ) ; sw . flush ( ) ; return sw . toString ( ) ; }
 public static org . apache . axis . encoding . Deserializer getDeserializer ( java . lang . String mechType , java . lang . Class _javaType , javax . xml . namespace . QName _xmlType ) { return new org . apache . axis . encoding . ser . BeanDeserializer ( _javaType , _xmlType , typeDesc ) ; }
 public static boolean isInitialized ( ) { return props != null ; }
 public static Throwable getRootCause ( Throwable throwable ) { if ( throwable . getCause ( ) != null ) return getRootCause ( throwable . getCause ( ) ) ; return throwable ; }
 @ Test public static void megamorphicMultiGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final ScriptContext [ ] contexts = new ScriptContext [ NUMBER_OF_CONTEXTS ] ; final String sharedScript = " foo " ; for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] = new SimpleScriptContext ( ) ; final Bindings b = e . createBindings ( ) ; context . setBindings ( b , ScriptContext . ENGINE_SCOPE ) ; assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < NUMBER_OF_CONTEXTS ; i ++ ) { final ScriptContext context = contexts [ i ] ; assertEquals ( e . eval ( sharedScript , context ) , String . valueOf ( i ) ) ; } }
 public static boolean isInstanceofed ( Clazz clazz ) { ClassOptimizationInfo info = ClassOptimizationInfo . getClassOptimizationInfo ( clazz ) ; return info == null || info . isInstanceofed ( ) ; }
 private static boolean isCDNURL ( URI url ) { if ( url != null ) { String uriHost = url . getHost ( ) ; if ( uriHost . endsWith ( " fbcdn . net " ) ) { return true ; } if ( uriHost . startsWith ( " fbcdn " ) && uriHost . endsWith ( " akamaihd . net " ) ) { return true ; } } return false ; }
 public static org . apache . axis . description . TypeDesc getTypeDesc ( ) { return typeDesc ; }
 public static Props getInstance ( ) { if ( props != null ) { return props ; } throw new RuntimeException ( " Properties , ▁ Kettle ▁ systems ▁ settings , ▁ not ▁ initialised ! " ) ; }
 static void clearCache ( Context context ) { try { getCache ( context ) . clearCache ( ) ; } catch ( IOException e ) { Logger . log ( LoggingBehavior . CACHE , Log . WARN , TAG , " clearCache ▁ failed ▁ " + e . getMessage ( ) ) ; } }
 @ Test public static void megamorphicInheritedGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . prototype . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; }
 @ Test public static void megamorphicSingleGlobalLetTest ( ) throws ScriptException , InterruptedException { final NashornScriptEngineFactory factory = new NashornScriptEngineFactory ( ) ; final ScriptEngine e = factory . getScriptEngine ( LANGUAGE_ES6 ) ; final String sharedGetterScript = " foo " ; final String sharedSetterScript = " foo ▁ = ▁ 1" ; for ( int i = 0 ; i < MEGAMORPHIC_LOOP_COUNT ; i ++ ) { assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " delete ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( sharedGetterScript ) , i ) ; } assertEquals ( e . eval ( " let ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( sharedGetterScript ) , " foo " ) ; assertEquals ( e . eval ( sharedSetterScript ) , 1 ) ; assertEquals ( e . eval ( sharedGetterScript ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , MEGAMORPHIC_LOOP_COUNT - 1 ) ; }
 private static void assertStartDate ( SjukfallIntyg intygsData , String datum ) { assertTrue ( intygsData . getStartDatum ( ) . equals ( LocalDate . parse ( datum ) ) ) ; }
 private static boolean hasOverflow ( PsiExpression expr , @ NotNull Project project ) { if ( ! TypeConversionUtil . isNumericType ( expr . getType ( ) ) ) return false ; boolean overflow = false ; try { if ( expr . getUserData ( HAS_OVERFLOW_IN_CHILD ) == null ) { JavaPsiFacade . getInstance ( project ) . getConstantEvaluationHelper ( ) . computeConstantExpression ( expr , true ) ; } else { overflow = true ; } } catch ( ConstantEvaluationOverflowException e ) { overflow = true ; } finally { PsiElement parent = expr . getParent ( ) ; if ( overflow && parent instanceof PsiExpression ) { parent . putUserData ( HAS_OVERFLOW_IN_CHILD , " " ) ; } } return overflow ; }
