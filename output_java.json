[
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_RPCHandler/RPCHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.pipeline;\n\nimport com.foldright.examples.duplexing.RPC;\n\npublic interface RPCHandler {\n    RPC.Response request(RPC.Request request, RPCHandlerContext rPCHandlerContext);\n\n    void onResponse(RPC.Response response, RPCHandlerContext rPCHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ConfigSourceHandlerContext/ConfigSourceHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.pipeline;\n\nimport com.foldright.examples.config.ConfigSource;\n\npublic interface ConfigSourceHandlerContext extends ConfigSource {\n    ConfigSourcePipeline pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractRPCHandlerContext/AbstractRPCHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.pipeline;\n\nimport com.foldright.examples.duplexing.RPC;\n\npublic abstract class AbstractRPCHandlerContext implements RPCHandlerContext {\n    private final RPCPipeline pipeline;\n\n    volatile AbstractRPCHandlerContext prev;\n\n    volatile AbstractRPCHandlerContext next;\n\n    public AbstractRPCHandlerContext(RPCPipeline pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public RPC.Response request(RPC.Request request) {\n        return handler().request(request , findNextCtx());\n    }\n\n    @Override\n    public void onResponse(RPC.Response response) {\n        handler().onResponse(response , findPrevCtx());\n    }\n\n    protected abstract RPCHandler handler();\n\n    @Override\n    public final RPCPipeline pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractRPCHandlerContext findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractRPCHandlerContext findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_RPCPipeline/RPCPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.pipeline;\n\nimport com.foldright.examples.duplexing.RPC;\nimport java.util.List;\n\npublic class RPCPipeline implements RPC {\n    private final AbstractRPCHandlerContext head;\n\n    private final AbstractRPCHandlerContext tail;\n\n    public RPCPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public RPC.Response request(RPC.Request request) {\n        return head.request(request);\n    }\n\n    @Override\n    public void onResponse(RPC.Response response) {\n        tail.onResponse(response);\n    }\n\n    public synchronized RPCPipeline addFirst(RPCHandler handler) {\n        AbstractRPCHandlerContext newCtx = new DefaultRPCHandlerContext(this, handler);\n        AbstractRPCHandlerContext nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized RPCPipeline addFirst(List<RPCHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized RPCPipeline addLast(RPCHandler handler) {\n        AbstractRPCHandlerContext newCtx = new DefaultRPCHandlerContext(this, handler);\n        AbstractRPCHandlerContext prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized RPCPipeline addLast(List<RPCHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (RPCHandler handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext extends AbstractRPCHandlerContext {\n        HeadContext(RPCPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected RPCHandler handler() {\n            return null;\n        }\n\n        @Override\n        public RPC.Response request(RPC.Request request) {\n            AbstractRPCHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.request(request);\n            }\n\n            return null;\n        }\n\n        @Override\n        public void onResponse(RPC.Response response) {\n            AbstractRPCHandlerContext ctx = findPrevCtx();\n            if(ctx != null) {\n                ctx.onResponse(response);\n                return;\n            }\n\n            //noop\n        }\n    }\n\n    private static class TailContext extends AbstractRPCHandlerContext {\n        TailContext(RPCPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected RPCHandler handler() {\n            return null;\n        }\n\n        @Override\n        public RPC.Response request(RPC.Request request) {\n            AbstractRPCHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.request(request);\n            }\n\n            return null;\n        }\n\n        @Override\n        public void onResponse(RPC.Response response) {\n            AbstractRPCHandlerContext ctx = findPrevCtx();\n            if(ctx != null) {\n                ctx.onResponse(response);\n                return;\n            }\n\n            //noop\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_DefaultChannelHandler/DefaultChannelHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.handler;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\nimport com.foldright.examples.grpc.pipeline.ChannelHandler;\nimport com.foldright.examples.grpc.pipeline.ChannelHandlerContext;\n\npublic class DefaultChannelHandler implements ChannelHandler {\n\n    @Override\n    public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor,\n            CallOptions callOptions,\n            ChannelHandlerContext channelHandlerContext) {\n\n        // return a default clientCall\n        return new ClientCall<>(callOptions);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ChannelPipeline/ChannelPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.pipeline;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.Channel;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\nimport java.util.List;\n\npublic class ChannelPipeline implements Channel {\n    private final AbstractChannelHandlerContext head;\n\n    private final AbstractChannelHandlerContext tail;\n\n    public ChannelPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {\n        return head.newCall(methodDescriptor,callOptions);\n    }\n\n    public synchronized ChannelPipeline addFirst(ChannelHandler handler) {\n        AbstractChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, handler);\n        AbstractChannelHandlerContext nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ChannelPipeline addFirst(List<ChannelHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized ChannelPipeline addLast(ChannelHandler handler) {\n        AbstractChannelHandlerContext newCtx = new DefaultChannelHandlerContext(this, handler);\n        AbstractChannelHandlerContext prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ChannelPipeline addLast(List<ChannelHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (ChannelHandler handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext extends AbstractChannelHandlerContext {\n        HeadContext(ChannelPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ChannelHandler handler() {\n            return null;\n        }\n\n        @Override\n        public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n                MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {\n            AbstractChannelHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.newCall(methodDescriptor,callOptions);\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext extends AbstractChannelHandlerContext {\n        TailContext(ChannelPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ChannelHandler handler() {\n            return null;\n        }\n\n        @Override\n        public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n                MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {\n            AbstractChannelHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.newCall(methodDescriptor,callOptions);\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_LoadBalancerHandlerContext/LoadBalancerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.pipeline;\n\nimport com.foldright.examples.lb.LoadBalancer;\n\npublic interface LoadBalancerHandlerContext extends LoadBalancer {\n    LoadBalancerPipeline pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/lb_LoadBalancer/LoadBalancer.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\n\nimport java.util.List;\n\n@AutoPipeline\npublic interface LoadBalancer {\n\n    <T extends Node> T choose(List<T> nodes);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/config_ConfigSource/ConfigSource.java",
        "copies": "1",
        "content": "package com.foldright.examples.config;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\n\n@AutoPipeline\npublic interface ConfigSource {\n    String get(String key);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/interval_IntervalMerger/IntervalMerger.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\nimport com.foldright.examples.merge.Merger;\n\nimport java.util.List;\n\n@AutoPipeline\npublic interface IntervalMerger<T extends Interval> extends Merger<T> {\n\n    @Override\n    T merge(List<T> intervals);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_DefaultValueReader/DefaultValueReader.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.handler;\n\nimport com.foldright.examples.reader.pipeline.ReaderHandler;\nimport com.foldright.examples.reader.pipeline.ReaderHandlerContext;\n\npublic class DefaultValueReader implements ReaderHandler {\n\n    private final String defaultValue;\n\n    public DefaultValueReader(String defaultValue) {\n        this.defaultValue = defaultValue;\n    }\n\n    @Override\n    public String read(ReaderHandlerContext readerHandlerContext) {\n        return defaultValue;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ReaderHandlerContext/ReaderHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.pipeline;\n\nimport com.foldright.examples.reader.Reader;\n\npublic interface ReaderHandlerContext extends Reader {\n    ReaderPipeline pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/grpc_Channel/Channel.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\n\n@AutoPipeline\npublic interface Channel {\n\n    <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions\n    );\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractIntervalMergerHandlerContext/AbstractIntervalMergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval.pipeline;\n\nimport com.foldright.examples.merge.interval.Interval;\nimport java.util.List;\n\npublic abstract class AbstractIntervalMergerHandlerContext<T extends Interval> implements IntervalMergerHandlerContext<T> {\n    private final IntervalMergerPipeline<T> pipeline;\n\n    volatile AbstractIntervalMergerHandlerContext<T> prev;\n\n    volatile AbstractIntervalMergerHandlerContext<T> next;\n\n    public AbstractIntervalMergerHandlerContext(IntervalMergerPipeline<T> pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public T merge(List<T> intervals) {\n        return handler().merge(intervals , findNextCtx());\n    }\n\n    protected abstract IntervalMergerHandler<T> handler();\n\n    @Override\n    public final IntervalMergerPipeline<T> pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractIntervalMergerHandlerContext<T> findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractIntervalMergerHandlerContext<T> findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/merge_Merger/Merger.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\n\nimport java.util.List;\n\n@AutoPipeline\npublic interface Merger<T> {\n\n    T merge(List<T> elements);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultReaderHandlerContext/DefaultReaderHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.pipeline;\n\npublic class DefaultReaderHandlerContext extends AbstractReaderHandlerContext {\n    private final ReaderHandler handler;\n\n    public DefaultReaderHandlerContext(ReaderPipeline pipeline, ReaderHandler handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected ReaderHandler handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_InvokerHandler/InvokerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.handler;\n\nimport com.foldright.examples.duplexing.RPC.Request;\nimport com.foldright.examples.duplexing.RPC.Response;\nimport com.foldright.examples.duplexing.pipeline.RPCHandler;\nimport com.foldright.examples.duplexing.pipeline.RPCHandlerContext;\n\npublic class InvokerHandler implements RPCHandler {\n\n    @Override\n    public Response request(Request request, RPCHandlerContext rPCHandlerContext) {\n        Response response = new Response();\n        onResponse(response, rPCHandlerContext);\n        return response;\n    }\n\n    @Override\n    public void onResponse(Response response, RPCHandlerContext rPCHandlerContext) {\n        rPCHandlerContext.onResponse(response);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_AvailableLoadBalancerHandler/AvailableLoadBalancerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.handler;\n\nimport com.foldright.examples.lb.Node;\nimport com.foldright.examples.lb.pipeline.LoadBalancerHandler;\nimport com.foldright.examples.lb.pipeline.LoadBalancerHandlerContext;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class AvailableLoadBalancerHandler implements LoadBalancerHandler {\n\n    @Override\n    public <T extends Node> T choose(List<T> nodes, LoadBalancerHandlerContext loadBalancerHandlerContext) {\n        List<T> availableNodes = nodes.stream().filter(Node::available).collect(Collectors.toList());\n        return loadBalancerHandlerContext.choose(availableNodes);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_PlaceholderConfigSourceHandler/PlaceholderConfigSourceHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.handler;\n\nimport com.foldright.examples.config.pipeline.ConfigSourceHandler;\nimport com.foldright.examples.config.pipeline.ConfigSourceHandlerContext;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static org.apache.commons.lang3.StringUtils.removeEnd;\nimport static org.apache.commons.lang3.StringUtils.removeStart;\n\n/**\n * Support value with placeholder with format {@code ${value}}.\n * <p>\n * Not support nested placeholder yet, e.g. {@code ${${value}}}.\n */\npublic class PlaceholderConfigSourceHandler implements ConfigSourceHandler {\n\n    private static final Pattern PATTERN = Pattern.compile(\"(\\\\$\\\\{.+?})\");\n\n    @Override\n    public String get(String key, ConfigSourceHandlerContext context) {\n        String value = context.get(key);\n        if (StringUtils.isBlank(value)) {\n            return null;\n        }\n\n        Matcher matcher = PATTERN.matcher(value);\n\n        if (!matcher.find()) {\n            return value;\n        }\n\n        int groupCount = matcher.groupCount();\n        for (int i = 0; i < groupCount; i++) {\n\n            // like ${xxx}\n            String matched = matcher.group(i + 1);\n            // like xxx\n            String placeholderKey = removeEnd(removeStart(matched, \"${\"), \"}\");\n            // get xxx's value and replace ${xxx} with placeholderValue\n            String placeholderValue = context.pipeline().get(placeholderKey);\n            value = StringUtils.replace(value, matched, placeholderValue);\n        }\n\n        if (StringUtils.isBlank(value)) {\n            return null;\n        }\n\n        return value;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultIntervalMergerHandlerContext/DefaultIntervalMergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval.pipeline;\n\nimport com.foldright.examples.merge.interval.Interval;\n\npublic class DefaultIntervalMergerHandlerContext<T extends Interval> extends AbstractIntervalMergerHandlerContext<T> {\n    private final IntervalMergerHandler<T> handler;\n\n    public DefaultIntervalMergerHandlerContext(IntervalMergerPipeline<T> pipeline,\n            IntervalMergerHandler<T> handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected IntervalMergerHandler<T> handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_MergerHandlerContext/MergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.pipeline;\n\nimport com.foldright.examples.merge.Merger;\n\npublic interface MergerHandlerContext<T> extends Merger<T> {\n    MergerPipeline<T> pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_MapConfigSourceHandler/MapConfigSourceHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.handler;\n\nimport com.foldright.examples.config.pipeline.ConfigSourceHandler;\nimport com.foldright.examples.config.pipeline.ConfigSourceHandlerContext;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.Map;\n\npublic class MapConfigSourceHandler implements ConfigSourceHandler {\n\n    private final Map<String, String> map;\n\n    public MapConfigSourceHandler(Map<String, String> map) {\n        this.map = map;\n    }\n\n\n    @Override\n    public String get(String key, ConfigSourceHandlerContext context) {\n        String value = map.get(key);\n\n        if (StringUtils.isNotBlank(value)) {\n            return value;\n        }\n\n        return context.get(key);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_MergerPipeline/MergerPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.pipeline;\n\nimport com.foldright.examples.merge.Merger;\nimport java.util.List;\n\npublic class MergerPipeline<T> implements Merger<T> {\n    private final AbstractMergerHandlerContext<T> head;\n\n    private final AbstractMergerHandlerContext<T> tail;\n\n    public MergerPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public T merge(List<T> elements) {\n        return head.merge(elements);\n    }\n\n    public synchronized MergerPipeline<T> addFirst(MergerHandler<T> handler) {\n        AbstractMergerHandlerContext<T> newCtx = new DefaultMergerHandlerContext<T>(this, handler);\n        AbstractMergerHandlerContext<T> nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized MergerPipeline<T> addFirst(List<MergerHandler<T>> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized MergerPipeline<T> addLast(MergerHandler<T> handler) {\n        AbstractMergerHandlerContext<T> newCtx = new DefaultMergerHandlerContext<T>(this, handler);\n        AbstractMergerHandlerContext<T> prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized MergerPipeline<T> addLast(List<MergerHandler<T>> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (MergerHandler<T> handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext<T> extends AbstractMergerHandlerContext<T> {\n        HeadContext(MergerPipeline<T> pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected MergerHandler<T> handler() {\n            return null;\n        }\n\n        @Override\n        public T merge(List<T> elements) {\n            AbstractMergerHandlerContext<T> ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.merge(elements);\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext<T> extends AbstractMergerHandlerContext<T> {\n        TailContext(MergerPipeline<T> pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected MergerHandler<T> handler() {\n            return null;\n        }\n\n        @Override\n        public T merge(List<T> elements) {\n            AbstractMergerHandlerContext<T> ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.merge(elements);\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_IntervalMergerHandler/IntervalMergerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval.pipeline;\n\nimport com.foldright.examples.merge.interval.Interval;\nimport java.util.List;\n\npublic interface IntervalMergerHandler<T extends Interval> {\n    T merge(List<T> intervals, IntervalMergerHandlerContext<T> intervalMergerHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_WrapCallOptionsChannelHandler/WrapCallOptionsChannelHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.handler;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\nimport com.foldright.examples.grpc.pipeline.ChannelHandler;\nimport com.foldright.examples.grpc.pipeline.ChannelHandlerContext;\n\npublic class WrapCallOptionsChannelHandler implements ChannelHandler {\n\n    @Override\n    public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor,\n            CallOptions callOptions,\n            ChannelHandlerContext channelHandlerContext) {\n\n        CallOptionsWrapper callOptionsWrapper = new CallOptionsWrapper(callOptions);\n\n        return channelHandlerContext.newCall(methodDescriptor, callOptionsWrapper);\n    }\n\n\n    public static class CallOptionsWrapper extends CallOptions {\n        private final CallOptions callOptions;\n\n        public CallOptionsWrapper(CallOptions callOptions) {\n            this.callOptions = callOptions;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultMergerHandlerContext/DefaultMergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.pipeline;\n\npublic class DefaultMergerHandlerContext<T> extends AbstractMergerHandlerContext<T> {\n    private final MergerHandler<T> handler;\n\n    public DefaultMergerHandlerContext(MergerPipeline<T> pipeline, MergerHandler<T> handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected MergerHandler<T> handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AutoPipeline/AutoPipeline.java",
        "copies": "1",
        "content": "package com.foldright.auto.pipeline;\n\nimport com.foldright.auto.pipeline.PipelineDirection.Direction;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * The annotation to be applied to an interface for which the pipeline pattern should be automatically generated.\n * the default of {@link PipelineDirection} is {@link Direction#FORWARD},\n *\n * @see PipelineDirection\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface AutoPipeline {\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_RPCHandlerContext/RPCHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.pipeline;\n\nimport com.foldright.examples.duplexing.RPC;\n\npublic interface RPCHandlerContext extends RPC {\n    RPCPipeline pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_RandomLoadBalancerHandler/RandomLoadBalancerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.handler;\n\nimport com.foldright.examples.lb.Node;\nimport com.foldright.examples.lb.pipeline.LoadBalancerHandler;\nimport com.foldright.examples.lb.pipeline.LoadBalancerHandlerContext;\n\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class RandomLoadBalancerHandler implements LoadBalancerHandler {\n\n    @Override\n    public <T extends Node> T choose(List<T> nodes, LoadBalancerHandlerContext loadBalancerHandlerContext) {\n        int randomIndex = ThreadLocalRandom.current().nextInt(nodes.size());\n        return nodes.get(randomIndex);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultChannelHandlerContext/DefaultChannelHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.pipeline;\n\npublic class DefaultChannelHandlerContext extends AbstractChannelHandlerContext {\n    private final ChannelHandler handler;\n\n    public DefaultChannelHandlerContext(ChannelPipeline pipeline, ChannelHandler handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected ChannelHandler handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ReaderHandler/ReaderHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.pipeline;\n\npublic interface ReaderHandler {\n    String read(ReaderHandlerContext readerHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_MergerHandler/MergerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.pipeline;\n\nimport java.util.List;\n\npublic interface MergerHandler<T> {\n    T merge(List<T> elements, MergerHandlerContext<T> mergerHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultLoadBalancerHandlerContext/DefaultLoadBalancerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.pipeline;\n\npublic class DefaultLoadBalancerHandlerContext extends AbstractLoadBalancerHandlerContext {\n    private final LoadBalancerHandler handler;\n\n    public DefaultLoadBalancerHandlerContext(LoadBalancerPipeline pipeline,\n            LoadBalancerHandler handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected LoadBalancerHandler handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractChannelHandlerContext/AbstractChannelHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.pipeline;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\n\npublic abstract class AbstractChannelHandlerContext implements ChannelHandlerContext {\n    private final ChannelPipeline pipeline;\n\n    volatile AbstractChannelHandlerContext prev;\n\n    volatile AbstractChannelHandlerContext next;\n\n    public AbstractChannelHandlerContext(ChannelPipeline pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions) {\n        return handler().newCall(methodDescriptor,callOptions , findNextCtx());\n    }\n\n    protected abstract ChannelHandler handler();\n\n    @Override\n    public final ChannelPipeline pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractChannelHandlerContext findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractChannelHandlerContext findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/grpc_MethodDescriptor/MethodDescriptor.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc;\n\npublic class MethodDescriptor<ReqT, RespT> {\n\n    private final String fullMethodName;\n    private final String serviceName;\n\n    public MethodDescriptor(String fullMethodName, String serviceName) {\n        this.fullMethodName = fullMethodName;\n        this.serviceName = serviceName;\n    }\n\n    public String getFullMethodName() {\n        return fullMethodName;\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_SystemConfigSourceHandler/SystemConfigSourceHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.handler;\n\nimport com.foldright.examples.config.pipeline.ConfigSourceHandler;\nimport com.foldright.examples.config.pipeline.ConfigSourceHandlerContext;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class SystemConfigSourceHandler implements ConfigSourceHandler {\n\n    public static final SystemConfigSourceHandler INSTANCE = new SystemConfigSourceHandler();\n\n    @Override\n    public String get(String key, ConfigSourceHandlerContext context) {\n        String value = System.getProperty(key);\n        if (StringUtils.isNotBlank(value)) {\n            return value;\n        }\n        return context.get(key);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultConfigSourceHandlerContext/DefaultConfigSourceHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.pipeline;\n\npublic class DefaultConfigSourceHandlerContext extends AbstractConfigSourceHandlerContext {\n    private final ConfigSourceHandler handler;\n\n    public DefaultConfigSourceHandlerContext(ConfigSourcePipeline pipeline,\n            ConfigSourceHandler handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected ConfigSourceHandler handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_PipelineDirection/PipelineDirection.java",
        "copies": "1",
        "content": "package com.foldright.auto.pipeline;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * specify the direction of the pipeline, which can be used on methods or interfaces(which must be annotated with {@link AutoPipeline}).\n * the default direction is {@link Direction#FORWARD}, here's the rules:\n * <ul>\n * <li>\n *     rule1: in the <code>@AutoPipeline</code> interface's method, we can:\n *     <ul>\n *      <li>add {@link Direction#FORWARD} to apply the interface's method, the the annotated method will be called from <strong>head to tail</strong></li>\n *      <li>add {@link Direction#REVERSE} to apply the interface's method, the the annotated method will be called from <strong>tail to head</strong></li>\n *      <li>if there's no {@link Direction} annotation to the method, the direction of pipeline will follow the {@link Direction} in the in the <code>@AutoPipeline</code> interface, see rule2</li>\n *      <li>{@link Direction#FORWARD} and {@link Direction#REVERSE} are mutually exclusive, they cannot coexist</li>\n *     </ul>\n * </li>\n * <li>\n *     rule2: in the <code>@AutoPipeline</code> interface, we can:\n *     <ul>\n *         <li>add {@link Direction#FORWARD} to the <code>@AutoPipeline</code> interface, the methods declared in this interface will be called from <strong>head to tail</strong> unless the method is annotated with {@link Direction} in the method level</li>\n *         <li>add {@link Direction#REVERSE} to the <code>@AutoPipeline</code> interface, the methods declared in this interface will be called from <strong>tail to head</strong> unless the method is annotated with {@link Direction} in the method level</li>\n *         <li>if no {@link Direction} annotation to the <code>@AutoPipeline</code> interface, it equals to add {@link Direction#FORWARD} to the <code>@AutoPipeline</code> interface</li>\n *         <li>{@link Direction#FORWARD} and {@link Direction#REVERSE} are mutually exclusive, they cannot coexist</li>\n *     </ul>\n *\n * </li>\n * </ul>\n *\n * @see AutoPipeline\n */\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.CLASS)\npublic @interface PipelineDirection {\n\n    /**\n     * the direction of the pipeline, check the {@link PipelineDirection} to find the rules\n     *\n     * @see PipelineDirection\n     */\n    Direction value();\n\n    enum Direction {\n\n        /**\n         * from head to tail\n         */\n        FORWARD,\n\n        /**\n         * from tail to head\n         */\n        REVERSE,\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/duplexing_RPC/RPC.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\nimport com.foldright.auto.pipeline.PipelineDirection;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static com.foldright.auto.pipeline.PipelineDirection.Direction.REVERSE;\n\n@AutoPipeline\npublic interface RPC {\n\n\n    Response request(Request request);\n\n    @PipelineDirection(REVERSE)\n    void onResponse(Response response);\n\n\n    class Request {\n        private final List<String> infos = new ArrayList<>();\n\n        public void append(String info) {\n            infos.add(info);\n        }\n\n        public List<String> infos() {\n            return Collections.unmodifiableList(infos);\n        }\n    }\n\n    class Response {\n        private final List<String> infos = new ArrayList<>();\n\n        public void append(String info) {\n            infos.add(info);\n        }\n\n        public List<String> infos() {\n            return Collections.unmodifiableList(infos);\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/grpc_CallOptions/CallOptions.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc;\n\npublic class CallOptions {\n    // noop, just an example\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_LoadBalancerHandler/LoadBalancerHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.pipeline;\n\nimport com.foldright.examples.lb.Node;\nimport java.util.List;\n\npublic interface LoadBalancerHandler {\n    <T extends Node> T choose(List<T> nodes, LoadBalancerHandlerContext loadBalancerHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractLoadBalancerHandlerContext/AbstractLoadBalancerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.pipeline;\n\nimport com.foldright.examples.lb.Node;\nimport java.util.List;\n\npublic abstract class AbstractLoadBalancerHandlerContext implements LoadBalancerHandlerContext {\n    private final LoadBalancerPipeline pipeline;\n\n    volatile AbstractLoadBalancerHandlerContext prev;\n\n    volatile AbstractLoadBalancerHandlerContext next;\n\n    public AbstractLoadBalancerHandlerContext(LoadBalancerPipeline pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public <T extends Node> T choose(List<T> nodes) {\n        return handler().choose(nodes , findNextCtx());\n    }\n\n    protected abstract LoadBalancerHandler handler();\n\n    @Override\n    public final LoadBalancerPipeline pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractLoadBalancerHandlerContext findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractLoadBalancerHandlerContext findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_TransformClientCallChannelHandler/TransformClientCallChannelHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.handler;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\nimport com.foldright.examples.grpc.pipeline.ChannelHandler;\nimport com.foldright.examples.grpc.pipeline.ChannelHandlerContext;\n\npublic class TransformClientCallChannelHandler implements ChannelHandler {\n    @Override\n    public <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor,\n            CallOptions callOptions,\n            ChannelHandlerContext channelHandlerContext) {\n\n        ClientCall<RequestT, ResponseT> clientCall = channelHandlerContext.newCall(methodDescriptor, callOptions);\n        return new ClientCallWrapper<>(clientCall);\n    }\n\n    public static class ClientCallWrapper<Req, Res> extends ClientCall<Req, Res> {\n        private final ClientCall<Req, Res> clientCall;\n\n        public ClientCallWrapper(ClientCall<Req, Res> clientCall) {\n            super(clientCall.getCallOptions());\n            this.clientCall = clientCall;\n        }\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ConfigSourceHandler/ConfigSourceHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.pipeline;\n\npublic interface ConfigSourceHandler {\n    String get(String key, ConfigSourceHandlerContext configSourceHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_AddInfoHandler/AddInfoHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.handler;\n\nimport com.foldright.examples.duplexing.RPC.Request;\nimport com.foldright.examples.duplexing.RPC.Response;\nimport com.foldright.examples.duplexing.pipeline.RPCHandler;\nimport com.foldright.examples.duplexing.pipeline.RPCHandlerContext;\n\npublic class AddInfoHandler implements RPCHandler {\n\n    private final String info;\n\n    public AddInfoHandler(String info) {\n        this.info = info;\n    }\n\n    @Override\n    public Response request(Request request, RPCHandlerContext rPCHandlerContext) {\n        request.append(info);\n        return rPCHandlerContext.request(request);\n    }\n\n    @Override\n    public void onResponse(Response response, RPCHandlerContext rPCHandlerContext) {\n        response.append(info);\n        rPCHandlerContext.onResponse(response);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_DefaultRPCHandlerContext/DefaultRPCHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.duplexing.pipeline;\n\npublic class DefaultRPCHandlerContext extends AbstractRPCHandlerContext {\n    private final RPCHandler handler;\n\n    public DefaultRPCHandlerContext(RPCPipeline pipeline, RPCHandler handler) {\n        super(pipeline);\n        this.handler = handler;\n    }\n\n    @Override\n    protected RPCHandler handler() {\n        return handler;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/handler_FileReader/FileReader.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.handler;\n\nimport com.foldright.examples.reader.pipeline.ReaderHandler;\nimport com.foldright.examples.reader.pipeline.ReaderHandlerContext;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\npublic class FileReader implements ReaderHandler {\n\n    private final Path filePath;\n    private final String charset;\n\n    public FileReader(Path fileName, String charset) {\n        this.filePath = fileName;\n        this.charset = charset;\n    }\n\n    @Override\n    public String read(ReaderHandlerContext readerHandlerContext) {\n        boolean fileExists = Files.exists(filePath);\n\n        if (!fileExists) {\n            return readerHandlerContext.read();\n        }\n\n        try {\n            byte[] bytes = Files.readAllBytes(filePath);\n            return new String(bytes, charset);\n        } catch (IOException e) {\n            return readerHandlerContext.read();\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_LoadBalancerPipeline/LoadBalancerPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb.pipeline;\n\nimport com.foldright.examples.lb.LoadBalancer;\nimport com.foldright.examples.lb.Node;\nimport java.util.List;\n\npublic class LoadBalancerPipeline implements LoadBalancer {\n    private final AbstractLoadBalancerHandlerContext head;\n\n    private final AbstractLoadBalancerHandlerContext tail;\n\n    public LoadBalancerPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public <T extends Node> T choose(List<T> nodes) {\n        return head.choose(nodes);\n    }\n\n    public synchronized LoadBalancerPipeline addFirst(LoadBalancerHandler handler) {\n        AbstractLoadBalancerHandlerContext newCtx = new DefaultLoadBalancerHandlerContext(this, handler);\n        AbstractLoadBalancerHandlerContext nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized LoadBalancerPipeline addFirst(List<LoadBalancerHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized LoadBalancerPipeline addLast(LoadBalancerHandler handler) {\n        AbstractLoadBalancerHandlerContext newCtx = new DefaultLoadBalancerHandlerContext(this, handler);\n        AbstractLoadBalancerHandlerContext prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized LoadBalancerPipeline addLast(List<LoadBalancerHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (LoadBalancerHandler handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext extends AbstractLoadBalancerHandlerContext {\n        HeadContext(LoadBalancerPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected LoadBalancerHandler handler() {\n            return null;\n        }\n\n        @Override\n        public <T extends Node> T choose(List<T> nodes) {\n            AbstractLoadBalancerHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.choose(nodes);\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext extends AbstractLoadBalancerHandlerContext {\n        TailContext(LoadBalancerPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected LoadBalancerHandler handler() {\n            return null;\n        }\n\n        @Override\n        public <T extends Node> T choose(List<T> nodes) {\n            AbstractLoadBalancerHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.choose(nodes);\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/grpc_ClientCall/ClientCall.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc;\n\npublic class ClientCall<ReqT, RespT> {\n\n    private final CallOptions callOptions;\n\n    public ClientCall(CallOptions callOptions) {\n        this.callOptions = callOptions;\n    }\n\n    public CallOptions getCallOptions() {\n        return callOptions;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_IntervalMergerPipeline/IntervalMergerPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval.pipeline;\n\nimport com.foldright.examples.merge.interval.Interval;\nimport com.foldright.examples.merge.interval.IntervalMerger;\nimport java.util.List;\n\npublic class IntervalMergerPipeline<T extends Interval> implements IntervalMerger<T> {\n    private final AbstractIntervalMergerHandlerContext<T> head;\n\n    private final AbstractIntervalMergerHandlerContext<T> tail;\n\n    public IntervalMergerPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public T merge(List<T> intervals) {\n        return head.merge(intervals);\n    }\n\n    public synchronized IntervalMergerPipeline<T> addFirst(IntervalMergerHandler<T> handler) {\n        AbstractIntervalMergerHandlerContext<T> newCtx = new DefaultIntervalMergerHandlerContext<T>(this, handler);\n        AbstractIntervalMergerHandlerContext<T> nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized IntervalMergerPipeline<T> addFirst(\n            List<IntervalMergerHandler<T>> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized IntervalMergerPipeline<T> addLast(IntervalMergerHandler<T> handler) {\n        AbstractIntervalMergerHandlerContext<T> newCtx = new DefaultIntervalMergerHandlerContext<T>(this, handler);\n        AbstractIntervalMergerHandlerContext<T> prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized IntervalMergerPipeline<T> addLast(List<IntervalMergerHandler<T>> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (IntervalMergerHandler<T> handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext<T extends Interval> extends AbstractIntervalMergerHandlerContext<T> {\n        HeadContext(IntervalMergerPipeline<T> pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected IntervalMergerHandler<T> handler() {\n            return null;\n        }\n\n        @Override\n        public T merge(List<T> intervals) {\n            AbstractIntervalMergerHandlerContext<T> ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.merge(intervals);\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext<T extends Interval> extends AbstractIntervalMergerHandlerContext<T> {\n        TailContext(IntervalMergerPipeline<T> pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected IntervalMergerHandler<T> handler() {\n            return null;\n        }\n\n        @Override\n        public T merge(List<T> intervals) {\n            AbstractIntervalMergerHandlerContext<T> ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.merge(intervals);\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_IntervalMergerHandlerContext/IntervalMergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval.pipeline;\n\nimport com.foldright.examples.merge.interval.Interval;\nimport com.foldright.examples.merge.interval.IntervalMerger;\n\npublic interface IntervalMergerHandlerContext<T extends Interval> extends IntervalMerger<T> {\n    IntervalMergerPipeline<T> pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractMergerHandlerContext/AbstractMergerHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.pipeline;\n\nimport java.util.List;\n\npublic abstract class AbstractMergerHandlerContext<T> implements MergerHandlerContext<T> {\n    private final MergerPipeline<T> pipeline;\n\n    volatile AbstractMergerHandlerContext<T> prev;\n\n    volatile AbstractMergerHandlerContext<T> next;\n\n    public AbstractMergerHandlerContext(MergerPipeline<T> pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public T merge(List<T> elements) {\n        return handler().merge(elements , findNextCtx());\n    }\n\n    protected abstract MergerHandler<T> handler();\n\n    @Override\n    public final MergerPipeline<T> pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractMergerHandlerContext<T> findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractMergerHandlerContext<T> findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractConfigSourceHandlerContext/AbstractConfigSourceHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.pipeline;\n\npublic abstract class AbstractConfigSourceHandlerContext implements ConfigSourceHandlerContext {\n    private final ConfigSourcePipeline pipeline;\n\n    volatile AbstractConfigSourceHandlerContext prev;\n\n    volatile AbstractConfigSourceHandlerContext next;\n\n    public AbstractConfigSourceHandlerContext(ConfigSourcePipeline pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public String get(String key) {\n        return handler().get(key , findNextCtx());\n    }\n\n    protected abstract ConfigSourceHandler handler();\n\n    @Override\n    public final ConfigSourcePipeline pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractConfigSourceHandlerContext findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractConfigSourceHandlerContext findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/lb_Node/Node.java",
        "copies": "1",
        "content": "package com.foldright.examples.lb;\n\npublic interface Node {\n    String id();\n\n    int weight();\n\n    boolean available();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ConfigSourcePipeline/ConfigSourcePipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.config.pipeline;\n\nimport com.foldright.examples.config.ConfigSource;\nimport java.util.List;\n\npublic class ConfigSourcePipeline implements ConfigSource {\n    private final AbstractConfigSourceHandlerContext head;\n\n    private final AbstractConfigSourceHandlerContext tail;\n\n    public ConfigSourcePipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public String get(String key) {\n        return head.get(key);\n    }\n\n    public synchronized ConfigSourcePipeline addFirst(ConfigSourceHandler handler) {\n        AbstractConfigSourceHandlerContext newCtx = new DefaultConfigSourceHandlerContext(this, handler);\n        AbstractConfigSourceHandlerContext nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ConfigSourcePipeline addFirst(List<ConfigSourceHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized ConfigSourcePipeline addLast(ConfigSourceHandler handler) {\n        AbstractConfigSourceHandlerContext newCtx = new DefaultConfigSourceHandlerContext(this, handler);\n        AbstractConfigSourceHandlerContext prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ConfigSourcePipeline addLast(List<ConfigSourceHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (ConfigSourceHandler handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext extends AbstractConfigSourceHandlerContext {\n        HeadContext(ConfigSourcePipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ConfigSourceHandler handler() {\n            return null;\n        }\n\n        @Override\n        public String get(String key) {\n            AbstractConfigSourceHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.get(key);\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext extends AbstractConfigSourceHandlerContext {\n        TailContext(ConfigSourcePipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ConfigSourceHandler handler() {\n            return null;\n        }\n\n        @Override\n        public String get(String key) {\n            AbstractConfigSourceHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.get(key);\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ReaderPipeline/ReaderPipeline.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.pipeline;\n\nimport com.foldright.examples.reader.Reader;\nimport java.util.List;\n\npublic class ReaderPipeline implements Reader {\n    private final AbstractReaderHandlerContext head;\n\n    private final AbstractReaderHandlerContext tail;\n\n    public ReaderPipeline() {\n        head = new HeadContext(this);\n        tail = new TailContext(this);\n\n        head.prev = null;\n        head.next = tail;\n        tail.prev = head;\n        tail.next = null;\n    }\n\n    @Override\n    public String read() {\n        return head.read();\n    }\n\n    public synchronized ReaderPipeline addFirst(ReaderHandler handler) {\n        AbstractReaderHandlerContext newCtx = new DefaultReaderHandlerContext(this, handler);\n        AbstractReaderHandlerContext nextCtx = head.next;\n        head.next = newCtx;\n        newCtx.prev = head;\n        newCtx.next = nextCtx;\n        nextCtx.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ReaderPipeline addFirst(List<ReaderHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        int size = handlers.size();\n        for (int i = 0; i < size; i++) {\n            addFirst(handlers.get(size - i - 1));\n        }\n\n        return this;\n    }\n\n    public synchronized ReaderPipeline addLast(ReaderHandler handler) {\n        AbstractReaderHandlerContext newCtx = new DefaultReaderHandlerContext(this, handler);\n        AbstractReaderHandlerContext prevCtx = tail.prev;\n\n        newCtx.prev = prevCtx;\n        newCtx.next = tail;\n        prevCtx.next = newCtx;\n        tail.prev = newCtx;\n\n        return this;\n    }\n\n    public synchronized ReaderPipeline addLast(List<ReaderHandler> handlers) {\n        if (handlers == null || handlers.isEmpty()) {\n            return this;\n        }\n\n        for (ReaderHandler handler : handlers) {\n            addLast(handler);\n        }\n\n        return this;\n    }\n\n    private static class HeadContext extends AbstractReaderHandlerContext {\n        HeadContext(ReaderPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ReaderHandler handler() {\n            return null;\n        }\n\n        @Override\n        public String read() {\n            AbstractReaderHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.read();\n            }\n\n            return null;\n        }\n    }\n\n    private static class TailContext extends AbstractReaderHandlerContext {\n        TailContext(ReaderPipeline pipeline) {\n            super(pipeline);\n        }\n\n        @Override\n        protected ReaderHandler handler() {\n            return null;\n        }\n\n        @Override\n        public String read() {\n            AbstractReaderHandlerContext ctx = findNextCtx();\n            if(ctx != null) {\n                return ctx.read();\n            }\n\n            return null;\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ChannelHandlerContext/ChannelHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.pipeline;\n\nimport com.foldright.examples.grpc.Channel;\n\npublic interface ChannelHandlerContext extends Channel {\n    ChannelPipeline pipeline();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_ChannelHandler/ChannelHandler.java",
        "copies": "1",
        "content": "package com.foldright.examples.grpc.pipeline;\n\nimport com.foldright.examples.grpc.CallOptions;\nimport com.foldright.examples.grpc.ClientCall;\nimport com.foldright.examples.grpc.MethodDescriptor;\n\npublic interface ChannelHandler {\n    <RequestT, ResponseT> ClientCall<RequestT, ResponseT> newCall(\n            MethodDescriptor<RequestT, ResponseT> methodDescriptor, CallOptions callOptions,\n            ChannelHandlerContext channelHandlerContext);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/reader_Reader/Reader.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader;\n\nimport com.foldright.auto.pipeline.AutoPipeline;\n\n@AutoPipeline\npublic interface Reader {\n\n    String read();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/pipeline_AbstractReaderHandlerContext/AbstractReaderHandlerContext.java",
        "copies": "1",
        "content": "package com.foldright.examples.reader.pipeline;\n\npublic abstract class AbstractReaderHandlerContext implements ReaderHandlerContext {\n    private final ReaderPipeline pipeline;\n\n    volatile AbstractReaderHandlerContext prev;\n\n    volatile AbstractReaderHandlerContext next;\n\n    public AbstractReaderHandlerContext(ReaderPipeline pipeline) {\n                        this.pipeline = pipeline;\n    }\n\n    @Override\n    public String read() {\n        return handler().read(findNextCtx());\n    }\n\n    protected abstract ReaderHandler handler();\n\n    @Override\n    public final ReaderPipeline pipeline() {\n        return pipeline;\n    }\n\n    protected final AbstractReaderHandlerContext findNextCtx() {\n        return next;\n    }\n\n    protected final AbstractReaderHandlerContext findPrevCtx() {\n        return prev;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "auto-pipeline/interval_Interval/Interval.java",
        "copies": "1",
        "content": "package com.foldright.examples.merge.interval;\n\npublic interface Interval {\n\n    int start();\n\n    int end();\n\n    int length();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/staticfiles_ResourceHandler/ResourceHandler.java",
        "copies": "1",
        "content": "package io.javalin.http.staticfiles;\n\nimport io.javalin.http.Context;\n\npublic interface ResourceHandler {\n    boolean canHandle(Context context);\n\n    boolean handle(Context context);\n\n    boolean addStaticFileConfig(StaticFileConfig config);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_FileUploadExample/FileUploadExample.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.util.FileUtil;\n\npublic class FileUploadExample {\n\n    public static void main(String[] args) {\n\n        Javalin app = Javalin.create().start(7000);\n\n        app.get(\"/\", ctx ->\n            ctx.html(\n                \"\"\n                    + \"<form method='post' enctype='multipart/form-data'>\"\n                    + \"    <input type='file' name='files' multiple>\"\n                    + \"    <button>Upload</button>\"\n                    + \"</form>\"\n            )\n        );\n\n        app.post(\"/\", ctx -> {\n            ctx.uploadedFiles(\"files\").forEach(file -> {\n                FileUtil.streamToFile(file.content(), \"upload/\" + file.filename());\n            });\n        });\n\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_TypedException/TypedException.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.testing;\n\npublic class TypedException extends Exception {\n    public String proofOfType() {\n        return \"I'm so typed\";\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalinvue_TestJavalinVueHandler/TestJavalinVueHandler.java",
        "copies": "1",
        "content": "package io.javalin.javalinvue;\n\nimport io.javalin.http.Context;\nimport io.javalin.vue.VueComponent;\nimport io.javalin.vue.VueHandler;\nimport io.javalin.vue.VueRenderer;\nimport org.jetbrains.annotations.NotNull;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class TestJavalinVueHandler {\n\n    @Test\n    public void testDefaultPreAndPostRenderer() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/no-state\", new VueHandler(\"test-component\") {\n            });\n            String body = httpUtil.getBody(\"/no-state\");\n            assertThat(body).contains(\"<body><test-component></test-component></body>\");\n            assertThat(body).doesNotContain(\"PRE_RENDER\");\n            assertThat(body).doesNotContain(\"POST_RENDER\");\n        });\n    }\n\n    @Test\n    public void testPreRenderer() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/no-state\", new VueHandler(\"test-component\") {\n                @NotNull\n                @Override\n                public String preRender(@NotNull String layout, @NotNull Context ctx) {\n                    return layout.concat(\"PRE_RENDER\");\n                }\n            });\n            String body = httpUtil.getBody(\"/no-state\");\n            assertThat(body).contains(\"<body><test-component></test-component></body>\");\n            assertThat(body).contains(\"PRE_RENDER\");\n            assertThat(body).doesNotContain(\"POST_RENDER\");\n        });\n    }\n\n    @Test\n    public void testPostRenderer() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/no-state\", new VueHandler(\"test-component\") {\n                @NotNull\n                @Override\n                public String postRender(@NotNull String layout, @NotNull Context ctx) {\n                    return layout.concat(\"POST_RENDER\");\n                }\n            });\n            String body = httpUtil.getBody(\"/no-state\");\n            assertThat(body).contains(\"<body><test-component></test-component></body>\");\n            assertThat(body).doesNotContain(\"PRE_RENDER\");\n            assertThat(body).contains(\"POST_RENDER\");\n        });\n    }\n\n    @Test\n    public void testVueRenderer() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/no-state\", new VueComponent(\"test-component\", null, new VueRenderer() {\n                @NotNull\n                @Override\n                public String postRender(@NotNull String layout, @NotNull Context ctx) {\n                    return layout.concat(\"POST_RENDER\");\n                }\n\n                @Override\n                public String preRender(@NotNull String layout, @NotNull Context ctx) {\n                    return layout.concat(\"PRE_RENDER\");\n                }\n            }));\n            String body = httpUtil.getBody(\"/no-state\");\n            assertThat(body).contains(\"<body><test-component></test-component></body>\");\n            assertThat(body).contains(\"POST_RENDER\");\n            assertThat(body).contains(\"PRE_RENDER\");\n        });\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_jmhType_B3/PathMatcherBenchmark_jmhType_B3.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\npublic class PathMatcherBenchmark_jmhType_B3 extends PathMatcherBenchmark_jmhType_B2 {\n    byte b3_000, b3_001, b3_002, b3_003, b3_004, b3_005, b3_006, b3_007, b3_008, b3_009, b3_010, b3_011, b3_012, b3_013, b3_014, b3_015;\n    byte b3_016, b3_017, b3_018, b3_019, b3_020, b3_021, b3_022, b3_023, b3_024, b3_025, b3_026, b3_027, b3_028, b3_029, b3_030, b3_031;\n    byte b3_032, b3_033, b3_034, b3_035, b3_036, b3_037, b3_038, b3_039, b3_040, b3_041, b3_042, b3_043, b3_044, b3_045, b3_046, b3_047;\n    byte b3_048, b3_049, b3_050, b3_051, b3_052, b3_053, b3_054, b3_055, b3_056, b3_057, b3_058, b3_059, b3_060, b3_061, b3_062, b3_063;\n    byte b3_064, b3_065, b3_066, b3_067, b3_068, b3_069, b3_070, b3_071, b3_072, b3_073, b3_074, b3_075, b3_076, b3_077, b3_078, b3_079;\n    byte b3_080, b3_081, b3_082, b3_083, b3_084, b3_085, b3_086, b3_087, b3_088, b3_089, b3_090, b3_091, b3_092, b3_093, b3_094, b3_095;\n    byte b3_096, b3_097, b3_098, b3_099, b3_100, b3_101, b3_102, b3_103, b3_104, b3_105, b3_106, b3_107, b3_108, b3_109, b3_110, b3_111;\n    byte b3_112, b3_113, b3_114, b3_115, b3_116, b3_117, b3_118, b3_119, b3_120, b3_121, b3_122, b3_123, b3_124, b3_125, b3_126, b3_127;\n    byte b3_128, b3_129, b3_130, b3_131, b3_132, b3_133, b3_134, b3_135, b3_136, b3_137, b3_138, b3_139, b3_140, b3_141, b3_142, b3_143;\n    byte b3_144, b3_145, b3_146, b3_147, b3_148, b3_149, b3_150, b3_151, b3_152, b3_153, b3_154, b3_155, b3_156, b3_157, b3_158, b3_159;\n    byte b3_160, b3_161, b3_162, b3_163, b3_164, b3_165, b3_166, b3_167, b3_168, b3_169, b3_170, b3_171, b3_172, b3_173, b3_174, b3_175;\n    byte b3_176, b3_177, b3_178, b3_179, b3_180, b3_181, b3_182, b3_183, b3_184, b3_185, b3_186, b3_187, b3_188, b3_189, b3_190, b3_191;\n    byte b3_192, b3_193, b3_194, b3_195, b3_196, b3_197, b3_198, b3_199, b3_200, b3_201, b3_202, b3_203, b3_204, b3_205, b3_206, b3_207;\n    byte b3_208, b3_209, b3_210, b3_211, b3_212, b3_213, b3_214, b3_215, b3_216, b3_217, b3_218, b3_219, b3_220, b3_221, b3_222, b3_223;\n    byte b3_224, b3_225, b3_226, b3_227, b3_228, b3_229, b3_230, b3_231, b3_232, b3_233, b3_234, b3_235, b3_236, b3_237, b3_238, b3_239;\n    byte b3_240, b3_241, b3_242, b3_243, b3_244, b3_245, b3_246, b3_247, b3_248, b3_249, b3_250, b3_251, b3_252, b3_253, b3_254, b3_255;\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestValidation_Java/TestValidation_Java.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin;\n\nimport io.javalin.config.ValidationConfig;\nimport io.javalin.testing.TestUtil;\nimport io.javalin.validation.Validation;\n\nimport java.time.Instant;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class TestValidation_Java {\n    private static class CustomException extends RuntimeException {\n        public CustomException(String message) {\n            super(message);\n        }\n    }\n\n    @Test\n    public void validation_on_context_works_from_java() {\n        TestUtil.test((app, http) -> {\n            app.get(\"/validate\", ctx -> ctx.queryParamAsClass(\"param\", Integer.class).get());\n            assertThat(http.getBody(\"/validate?param=hmm\")).contains(\"TYPE_CONVERSION_FAILED\");\n        });\n    }\n\n    @Test\n    public void default_values_work_from_java() {\n        TestUtil.test((app, http) -> {\n            app.get(\"/validate\", ctx -> ctx.result(ctx.queryParamAsClass(\"param\", Integer.class).getOrDefault(250).toString()));\n            assertThat(http.getBody(\"/validate?param=hmm\")).contains(\"TYPE_CONVERSION_FAILED\");\n            assertThat(http.getBody(\"/validate\")).isEqualTo(\"250\");\n        });\n    }\n\n    @Test\n    public void get_or_throw_works_from_java() {\n        TestUtil.test((app, http) -> {\n            app.get(\"/\", ctx -> {\n                Integer myInt = ctx.queryParamAsClass(\"my-qp\", Integer.class)\n                    .getOrThrow(e -> new CustomException(\"'my-qp' is not a number\"));\n                ctx.result(myInt.toString());\n            });\n            app.exception(CustomException.class, (e, ctx) -> ctx.result(e.getMessage()));\n            assertThat(http.getBody(\"/\")).isEqualTo(\"'my-qp' is not a number\");\n        });\n    }\n\n    @Test\n    public void validator_works_from_java_too() {\n        ValidationConfig validationConfig = new ValidationConfig();\n        validationConfig.register(Instant.class, v -> Instant.ofEpochMilli(Long.parseLong(v)));\n        Validation validation = new Validation(validationConfig);\n        String intString = \"123\";\n        int myInt = validation.validator(\"?\", Integer.class, intString).get();\n        assertThat(myInt).isEqualTo(123);\n\n        Instant fromDate = validation.validator(\"?\", Instant.class, \"1262347200000\").get();\n        Instant toDate = validation.validator(\"?\", Instant.class, \"1262347300000\")\n            .check(date -> date.isAfter(fromDate), \"'to' has to be after 'from'\")\n            .get();\n\n        assertThat(toDate.getEpochSecond()).isEqualTo(1262347300L);\n        assertThat(validation.validator(\"?\", Boolean.class, \"true\").get()).isInstanceOf(Boolean.class);\n        assertThat(validation.validator(\"?\", Double.class, \"1.2\").get()).isInstanceOf(Double.class);\n        assertThat(validation.validator(\"?\", Float.class, \"1.2\").get()).isInstanceOf(Float.class);\n        assertThat(validation.validator(\"?\", Integer.class, \"123\").get()).isInstanceOf(Integer.class);\n        assertThat(validation.validator(\"?\", Long.class, \"123\").get()).isInstanceOf(Long.class);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldFuture/HelloWorldFuture.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class HelloWorldFuture {\n\n    public static void main(String[] args) {\n        Javalin app = Javalin.create().start(7070);\n        app.get(\"/\", ctx -> {\n            CompletableFuture<String> future = new CompletableFuture<>();\n            Executors.newSingleThreadScheduledExecutor().schedule(() -> future.complete(\"Hello World!\"), 10, TimeUnit.MILLISECONDS);\n            ctx.future(() -> future.thenApply(ctx::result));\n        });\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldApi/HelloWorldApi.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\n\nimport static io.javalin.apibuilder.ApiBuilder.get;\nimport static io.javalin.apibuilder.ApiBuilder.path;\nimport static io.javalin.http.HttpStatus.OK;\n\npublic class HelloWorldApi {\n\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.router.apiBuilder(() -> {\n                get(\"/hello\", ctx -> ctx.result(\"Hello World\"));\n                path(\"/api\", () -> {\n                    get(\"/test\", ctx -> ctx.result(\"Hello World\"));\n                    get(\"/tast\", ctx -> ctx.status(OK).result(\"Hello world\"));\n                    get(\"/hest\", ctx -> ctx.status(OK).result(\"Hello World\"));\n                    get(\"/hast\", ctx -> ctx.status(OK).result(\"Hello World\").header(\"test\", \"tast\"));\n                });\n            });\n        })\n        .start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestPublicApi_Java/TestPublicApi_Java.java",
        "copies": "1",
        "content": "package io.javalin;\n\nimport io.javalin.config.Key;\nimport io.javalin.http.*;\nimport io.javalin.plugin.ContextPlugin;\nimport io.javalin.plugin.bundled.CorsPlugin;\nimport io.javalin.validation.ValidationError;\nimport io.javalin.validation.Validator;\nimport io.javalin.websocket.WsConfig;\n\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport static io.javalin.apibuilder.ApiBuilder.delete;\nimport static io.javalin.apibuilder.ApiBuilder.get;\nimport static io.javalin.apibuilder.ApiBuilder.patch;\nimport static io.javalin.apibuilder.ApiBuilder.path;\nimport static io.javalin.apibuilder.ApiBuilder.post;\nimport static io.javalin.apibuilder.ApiBuilder.ws;\n\n// @formatter:off\npublic class TestPublicApi_Java {\n    static public class TestContextPlugin extends ContextPlugin<Void, HandlerType> {\n        public HandlerType createExtension(Context context) {\n            return context.method();\n        }\n    }\n\n    public static void main(String[] args) {\n        Javalin.create(/*config*/)\n            .get(\"/\", ctx -> ctx.result(\"Hello World\"))\n            .start(7070);\n        var testComponentkey = new Key<String>(\"test-component\");\n        var app = Javalin.create(config -> {\n            config.appData(testComponentkey, \"name\");\n            config.validation.register(Instant.class, v -> Instant.ofEpochMilli(Long.parseLong(v)));\n            config.registerPlugin(new CorsPlugin(cors -> {\n                cors.addRule(rule -> {\n                    rule.path = \"images*\";\n                    rule.allowHost(\"https://images.local\");\n                });\n            }));\n            config.registerPlugin(new TestContextPlugin());\n            config.http.asyncTimeout = 10_000L;\n            config.router.apiBuilder(() -> {\n                path(\"users\", () -> {\n                    get(UserController::getAll);\n                    post(UserController::create);\n                    path(\"{userId}\", () -> {\n                        get(UserController::getOne);\n                        patch(UserController::update);\n                        delete(UserController::delete);\n                    });\n                    ws(\"events\", UserController::webSocketEvents);\n                });\n            });\n        });\n        app.before(ctx -> {});\n        app.before(\"/path/*\", ctx -> {});\n        app.after(ctx -> {});\n        app.after(\"/path/*\", ctx -> {});\n\n        // validation\n        app.get(\"/\", ctx -> {\n            Integer myValue = ctx.queryParamAsClass(\"value\", Integer.class).getOrDefault(788);\n            ctx.result(\"\" + myValue);\n\n            Instant fromDate = ctx.queryParamAsClass(\"from\", Instant.class).get();\n            Instant toDate = ctx.queryParamAsClass(\"to\", Instant.class)\n                .check(it -> it.isAfter(fromDate), \"'to' has to be after 'from'\")\n                .get();\n\n            MyObject myObject = ctx.bodyValidator(MyObject.class)\n                .check(obj -> obj.myObjectProperty == 2, \"THINGS_MUST_BE_EQUAL\")\n                .get();\n\n            ctx.queryParamAsClass(\"param\", Integer.class)\n                .check(it -> it > 5, new ValidationError<>(\"OVER_LIMIT\", Map.of(\"limit\", 5)))\n                .get();\n\n            Validator<Integer> ageValidator = ctx.queryParamAsClass(\"age\", Integer.class)\n                .check(n -> n < 4, \"TOO_YOUNG\");\n\n            Map<String, List<ValidationError<Integer>>> errors = ageValidator.errors();\n\n        });\n\n        app.exception(NullPointerException.class, (e, ctx) -> { /* ... */ });\n        app.exception(Exception.class, (e, ctx) -> { /* ... */ });\n        app.wsException(NullPointerException.class, (e, ctx) -> { /* ... */ });\n        app.wsException(Exception.class, (e, ctx) -> { /* ... */ });\n\n        app.sse(\"/sse\", client -> {\n            client.sendEvent(\"connected\", \"Hello, SSE\");\n            client.onClose(() -> System.out.println(\"Client disconnected\"));\n            client.close(); // close the client\n        });\n\n        Javalin.create(config -> {\n            config.requestLogger.http((ctx, ms) -> {\n                // log things here\n            });\n        });\n\n        Javalin.create(config -> {\n            config.requestLogger.ws(ws -> {\n                ws.onMessage(ctx -> {\n                    System.out.println(\"Received: \" + ctx.message());\n                });\n            });\n        });\n\n        Javalin.create().events(event -> {\n            event.serverStarting(() -> { });\n            event.serverStarted(() -> { });\n            event.serverStartFailed(() -> { });\n            event.serverStopping(() -> { });\n            event.serverStopped(() -> { });\n            event.handlerAdded(handlerMetaInfo -> { });\n            event.wsHandlerAdded(wsHandlerMetaInfo -> { });\n        });\n\n        app.ws(\"/websocket/{path}\", ws -> {\n            ws.onConnect(ctx -> System.out.println(\"Connected\"));\n            ws.onMessage(ctx -> {\n                User user = ctx.messageAsClass(User.class); // convert from json\n                ctx.send(user); // convert to json and send back\n            });\n            ws.onBinaryMessage(ctx -> System.out.println(\"Message\"));\n            ws.onClose(ctx -> System.out.println(\"Closed\"));\n            ws.onError(ctx -> System.out.println(\"Errored\"));\n        });\n\n        app.wsAfter(ws -> { });\n        app.wsAfter(\"/path/*\", ws -> { });\n\n        // context\n        app.get(\"/\", ctx -> {\n            ctx.body();\n            ctx.bodyAsBytes();\n            ctx.bodyAsClass(Integer.class);\n            ctx.bodyStreamAsClass(Integer.class);\n            ctx.bodyValidator(Integer.class);\n            ctx.bodyInputStream();\n            ctx.uploadedFile(\"name\");\n            ctx.uploadedFiles(\"name\");\n            ctx.uploadedFiles();\n            ctx.uploadedFileMap();\n            ctx.formParam(\"name\");\n            ctx.formParamAsClass(\"name\",Integer.class);\n            ctx.formParams(\"name\");\n            ctx.formParamMap();\n            ctx.pathParam(\"name\");\n            ctx.pathParamAsClass(\"name\",Integer.class);\n            ctx.pathParamMap();\n            ctx.basicAuthCredentials();\n            ctx.attribute(\"name\",Integer.class);\n            ctx.attribute(\"name\");\n            ctx.attributeOrCompute(\"name\", ctx2-> \"\");\n            ctx.attributeMap();\n            ctx.contentLength();\n            ctx.contentType();\n            ctx.cookie(\"name\");\n            ctx.cookieMap();\n            ctx.header(\"name\");\n            ctx.headerAsClass(\"name\",Integer.class);\n            ctx.headerMap();\n            ctx.host();\n            ctx.ip();\n            ctx.isMultipart();\n            ctx.isMultipartFormData();\n            ctx.method();\n            ctx.path();\n            ctx.port();\n            ctx.protocol();\n            ctx.queryParam(\"name\");\n            ctx.queryParamAsClass(\"name\",Integer.class);\n            ctx.queryParams(\"name\");\n            ctx.queryParamMap();\n            ctx.queryString();\n            ctx.scheme();\n            ctx.sessionAttribute(\"name\",Integer.class);\n            ctx.sessionAttribute(\"name\");\n            ctx.consumeSessionAttribute(\"name\");\n            ctx.cachedSessionAttribute(\"name\",Integer.class);\n            ctx.cachedSessionAttribute(\"name\");\n            ctx.cachedSessionAttributeOrCompute(\"name\", ctx2-> \"\");\n            ctx.sessionAttributeMap();\n            ctx.url();\n            ctx.fullUrl();\n            ctx.contextPath();\n            ctx.userAgent();\n            ctx.req();\n            ctx.result(\"result\");\n            ctx.result(new byte[0]);\n            ctx.result(ctx.resultInputStream());\n            ctx.future(() -> CompletableFuture.supplyAsync(() -> \"result\"));\n            ctx.writeSeekableStream(ctx.resultInputStream(), ContentType.APPLICATION_BZ.getMimeType());\n            ctx.result();\n            ctx.resultInputStream();\n            ctx.contentType(\"type\");\n            ctx.header(\"name\",\"value\");\n            ctx.redirect(\"/path\",HttpStatus.FOUND);\n            ctx.status(HttpStatus.FOUND);\n            ctx.status();\n            ctx.cookie(\"name\",\"value\",2);\n            ctx.cookie(new Cookie(\"name\",\"value\",\"/path\", 2, true, 3));\n            ctx.removeCookie(\"name\",\"/path\");\n            ctx.json(new User());\n            ctx.jsonStream(new User());\n            ctx.html(\"html\");\n            ctx.render(\"/template.tmpl\",Map.of(\"test\", \"tast\"));\n            ctx.res();\n            ctx.async(() -> {});\n            ctx.handlerType();\n            ctx.appData(testComponentkey);\n            ctx.matchedPath();\n            ctx.endpointHandlerPath();\n            ctx.cookieStore();\n            ctx.with(TestContextPlugin.class);\n        });\n    }\n\n\n    static class UserController {\n        public static void getAll(Context ctx) { /* ... */ }\n        public static void create(Context ctx) { /* ... */ }\n        public static void getOne(Context ctx) { /* ... */ }\n        public static void update(Context ctx) { /* ... */ }\n        public static void delete(Context ctx) { /* ... */ }\n        public static void webSocketEvents(WsConfig wsConfig) { /* ... */ }\n    }\n\n    private static class MyObject {\n        public int myObjectProperty;\n    }\n\n    private static class User { }\n}\n// @formatter:on\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/websocket_WsExceptionHandler/WsExceptionHandler.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.websocket;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * A handler for use with {@link io.javalin.Javalin#wsException(Class, WsExceptionHandler)}.\n * Is triggered when an exception is thrown by a handler in a {@link WsConfig}.\n *\n * @see WsContext\n */\n@FunctionalInterface\npublic interface WsExceptionHandler<T extends Exception> {\n    void handle(@NotNull T exception, @NotNull WsContext ctx);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldAsync/HelloWorldAsync.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\n\npublic class HelloWorldAsync {\n\n    public static void main(String[] args) {\n        Javalin app = Javalin.create().start(7070);\n\n        app.get(\"/\", ctx -> {\n            ctx.async(\n                (asyncConfig) -> {\n                    asyncConfig.timeout = 1000L;\n                    asyncConfig.onTimeout(timeoutCtx -> timeoutCtx.result(\"Request timed out :<\"));\n                },\n                () -> {\n                    Thread.sleep((long) (Math.random() * 2000L));\n                    ctx.result(\"Hello Javalin\");\n                }\n            );\n        });\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestContextHandlerType/TestContextHandlerType.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2021 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\npackage io.javalin;\n\nimport io.javalin.http.HandlerType;\nimport io.javalin.testing.TestUtil;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.assertj.core.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport static io.javalin.http.HttpStatus.OK;\n\npublic class TestContextHandlerType {\n\n    @Test\n    public void testHandlerTypeCanBeAccessedInContext() {\n        TestUtil.test(Javalin.create(), (app, http) -> {\n            List<HandlerType> handlerTypes = new ArrayList<>();\n            app.before(ctx -> handlerTypes.add(ctx.handlerType()));\n            app.after(ctx -> handlerTypes.add(ctx.handlerType()));\n            app.get(\"/\", ctx -> handlerTypes.add(ctx.handlerType()));\n\n            Assertions.assertThat(http.get(\"/\").getStatus()).isEqualTo(OK.getCode());\n            Assertions.assertThat(handlerTypes).containsExactly(HandlerType.BEFORE, HandlerType.GET, HandlerType.AFTER);\n        });\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jte_JteTestPage/JteTestPage.java",
        "copies": "1",
        "content": "package io.javalin.jte;\n\npublic class JteTestPage {\n    private final String hello;\n    private final String world;\n\n    public JteTestPage(String hello, String world) {\n        this.hello = hello;\n        this.world = world;\n    }\n\n    public String getHello() {\n        return hello;\n    }\n\n    public String getWorld() {\n        return world;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/http_Handler/Handler.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.http;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Main interface for endpoint actions. A handler has a void return type,\n * so you have to use {@link Context#result} to return data to the client.\n *\n * @see Context\n * @see <a href=\"https://javalin.io/documentation#handlers\">Handler in documentation</a>\n */\n@FunctionalInterface\npublic interface Handler {\n    /**\n     * Handles a request.\n     *\n     * @param ctx the current request's context. Use this to process the request's\n     *            parameter (query, form params, body, ) and build up the response\n     *            (status code, payload, )\n     * @throws Exception an exception while handling the request\n     */\n    void handle(@NotNull Context ctx) throws Exception;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_Javalin/Javalin.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin;\n\nimport io.javalin.http.ExceptionHandler;\nimport io.javalin.http.Handler;\nimport io.javalin.router.Endpoint;\nimport io.javalin.router.JavalinDefaultRoutingApi;\nimport io.javalin.config.JavalinConfig;\nimport io.javalin.config.EventConfig;\nimport io.javalin.jetty.JettyServer;\nimport io.javalin.security.RouteRole;\nimport java.util.function.Consumer;\nimport io.javalin.websocket.WsConfig;\nimport io.javalin.websocket.WsExceptionHandler;\nimport io.javalin.websocket.WsHandlerType;\nimport jakarta.servlet.Servlet;\nimport kotlin.Lazy;\nimport org.jetbrains.annotations.NotNull;\n\nimport static io.javalin.util.Util.createLazy;\n\npublic class Javalin implements JavalinDefaultRoutingApi<Javalin> {\n\n    /**\n     * Do not use this field unless you know what you're doing.\n     * Application config should be declared in {@link Javalin#create(Consumer)}.\n     */\n    private final JavalinConfig cfg;\n    protected final Lazy<JettyServer> jettyServer;\n\n    protected Javalin(JavalinConfig config) {\n        this.cfg = config;\n        this.jettyServer = createLazy(() -> new JettyServer(this.cfg));\n    }\n\n    @NotNull\n    public JavalinConfig unsafeConfig() {\n        return cfg;\n    }\n\n    public JettyServer jettyServer() {\n        return jettyServer.getValue();\n    }\n\n    /**\n     * Creates a new instance without any custom configuration.\n     * The server does not run until {@link Javalin#start()} is called.\n     *\n     * @return application instance\n     * @see Javalin#create(Consumer)\n     */\n    public static Javalin create() {\n        return create(config -> {\n        });\n    }\n\n    /**\n     * Creates a new instance with the user provided configuration.\n     * The server does not run until {@link Javalin#start()} is called.\n     *\n     * @return application instance\n     * @see Javalin#start()\n     * @see Javalin#start(int)\n     */\n    public static Javalin create(Consumer<JavalinConfig> config) {\n        JavalinConfig cfg = new JavalinConfig();\n        JavalinConfig.applyUserConfig(cfg, config); // mutates app.config and app (adds http-handlers)\n        Javalin app = new Javalin(cfg);\n        app.jettyServer.getValue(); // initialize server if no plugin already did\n        return app;\n    }\n\n    /**\n     * Creates a new instance with the user provided configuration and starts it immediately.\n     *\n     * @return running application instance\n     * @see io.javalin.Javalin#create(java.util.function.Consumer)\n     * @see Javalin#start()\n     */\n    public static Javalin createAndStart(Consumer<JavalinConfig> config) {\n        return create(cfg -> {\n            cfg.startupWatcherEnabled = false;\n            config.accept(cfg);\n        }).start();\n    }\n\n    // Get JavalinServlet (can be attached to other servlet containers)\n    public Servlet javalinServlet() {\n        return cfg.pvt.servlet.getValue().getServlet();\n    }\n\n    /**\n     * Synchronously starts the application instance on the specified port\n     * with the given host IP to bind to.\n     *\n     * @param host The host IP to bind to\n     * @param port to run on\n     * @return running application instance.\n     * @see Javalin#create()\n     * @see Javalin#start()\n     */\n    public Javalin start(String host, int port) {\n        jettyServer.getValue().start(host, port);\n        return this;\n    }\n\n    /**\n     * Synchronously starts the application instance on the specified port.\n     * Use port 0 to start the application instance on a random available port.\n     *\n     * @param port to run on\n     * @return running application instance.\n     * @see Javalin#create()\n     * @see Javalin#start()\n     */\n    public Javalin start(int port) {\n        jettyServer.getValue().start(null, port);\n        return this;\n    }\n\n    /**\n     * Synchronously starts the application instance on the configured port, or on\n     * the configured ServerConnectors if the Jetty server has been manually configured.\n     * If no port or connector is configured, the instance will start on port 8080.\n     *\n     * @return running application instance.\n     * @see Javalin#create()\n     */\n    public Javalin start() {\n        jettyServer.getValue().start(null, null);\n        return this;\n    }\n\n    /**\n     * Synchronously stops the application instance.\n     *\n     * @return stopped application instance.\n     */\n    public Javalin stop() {\n        if (jettyServer.getValue().server().isStopping() || jettyServer.getValue().server().isStopped()) {\n            return this;\n        }\n        jettyServer.getValue().stop();\n        return this;\n    }\n\n    public Javalin events(Consumer<EventConfig> listener) {\n        listener.accept(cfg.events);\n        return this;\n    }\n\n    /**\n     * Get which port instance is running on\n     * Mostly useful if you start the instance with port(0) (random port)\n     */\n    public int port() {\n        return jettyServer.getValue().port();\n    }\n\n    @NotNull\n    @Override\n    public <E extends Exception> Javalin exception(@NotNull Class<E> exceptionClass, @NotNull ExceptionHandler<? super E> exceptionHandler) {\n        cfg.pvt.internalRouter.addHttpExceptionHandler(exceptionClass, exceptionHandler);\n        return this;\n    }\n\n    @NotNull\n    @Override\n    public Javalin error(int status, @NotNull String contentType, @NotNull Handler handler) {\n        cfg.pvt.internalRouter.addHttpErrorHandler(status, contentType, handler);\n        return this;\n    }\n\n    @NotNull\n    @Override\n    public Javalin addEndpoint(@NotNull Endpoint endpoint) {\n        cfg.pvt.internalRouter.addHttpEndpoint(endpoint);\n        return this;\n    }\n\n    @NotNull\n    @Override\n    public <E extends Exception> Javalin wsException(@NotNull Class<E> exceptionClass, @NotNull WsExceptionHandler<? super E> exceptionHandler) {\n        cfg.pvt.internalRouter.addWsExceptionHandler(exceptionClass, exceptionHandler);\n        return this;\n    }\n\n    @NotNull\n    @Override\n    public Javalin addWsHandler(@NotNull WsHandlerType handlerType, @NotNull String path, @NotNull Consumer<WsConfig> wsConfig, @NotNull RouteRole @NotNull ... roles) {\n        cfg.pvt.internalRouter.addWsHandler(handlerType, path, wsConfig, roles);\n        return this;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldAuth/HelloWorldAuth.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.UnauthorizedResponse;\nimport io.javalin.security.RouteRole;\n\nimport java.util.Set;\n\nimport static io.javalin.apibuilder.ApiBuilder.get;\nimport static io.javalin.apibuilder.ApiBuilder.path;\nimport static io.javalin.examples.HelloWorldAuth.JRole.ROLE_ONE;\nimport static io.javalin.examples.HelloWorldAuth.JRole.ROLE_THREE;\nimport static io.javalin.examples.HelloWorldAuth.JRole.ROLE_TWO;\nimport static io.javalin.http.HttpStatus.OK;\n\npublic class HelloWorldAuth {\n\n    enum JRole implements RouteRole {\n        ROLE_ONE, ROLE_TWO, ROLE_THREE\n    }\n\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.router.mount(router -> {\n                router.beforeMatched(ctx -> {\n                    Set<RouteRole> routeRoles = ctx.routeRoles();\n                    String userRole = ctx.queryParam(\"role\");\n                    if (userRole == null || !routeRoles.contains(JRole.valueOf(userRole))) {\n                        throw new UnauthorizedResponse();\n                    }\n                });\n            });\n            config.router.apiBuilder(() -> {\n                get(\"/hello\", ctx -> ctx.result(\"Hello World 1\"), ROLE_ONE);\n                path(\"/api\", () -> {\n                    get(\"/test\", ctx -> ctx.result(\"Hello World 2\"), ROLE_TWO);\n                    get(\"/tast\", ctx -> ctx.status(OK).result(\"Hello world 3\"), ROLE_THREE);\n                    get(\"/hest\", ctx -> ctx.status(OK).result(\"Hello World 4\"), ROLE_ONE, ROLE_TWO);\n                    get(\"/hast\", ctx -> ctx.status(OK).result(\"Hello World 5\").header(\"test\", \"tast\"), ROLE_ONE, ROLE_THREE);\n                });\n            });\n        }).start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldSse/HelloWorldSse.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.sse.SseClient;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.TimeUnit;\n\npublic class HelloWorldSse {\n\n    public static void main(String[] args) throws InterruptedException {\n\n        Queue<SseClient> clients = new ConcurrentLinkedQueue<>();\n\n        Javalin app = Javalin.create().start(7000);\n        app.get(\"/\", ctx -> ctx.html(\"<script>new EventSource('http://localhost:7000/sse').addEventListener('hi', msg => console.log(msg));</script>\"));\n        app.sse(\"/sse\", client -> {\n            client.keepAlive();\n            clients.add(client); // save the sse to use outside of this context\n            client.onClose(() -> clients.remove(client));\n        });\n\n        while (true) {\n            for (SseClient client : clients) {\n                client.sendEvent(\"hi\", \"hello world\");\n            }\n            TimeUnit.SECONDS.sleep(1);\n        }\n\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/ondemand_JtemultipleparamsGenerated/JtemultipleparamsGenerated.java",
        "copies": "1",
        "content": "package gg.jte.generated.ondemand;\npublic final class JtemultipleparamsGenerated {\n\tpublic static final String JTE_NAME = \"multiple-params.jte\";\n\tpublic static final int[] JTE_LINE_INFO = {0,0,0,0,2,2,2,2,2,2,2,3};\n\tpublic static void render(gg.jte.html.HtmlTemplateOutput jteOutput, gg.jte.html.HtmlInterceptor jteHtmlInterceptor, String one, String two) {\n\t\tjteOutput.writeContent(\"<h1>\");\n\t\tjteOutput.setContext(\"h1\", null);\n\t\tjteOutput.writeUserContent(one);\n\t\tjteOutput.writeContent(\" \");\n\t\tjteOutput.setContext(\"h1\", null);\n\t\tjteOutput.writeUserContent(two);\n\t\tjteOutput.writeContent(\"!</h1>\\n\");\n\t}\n\tpublic static void renderMap(gg.jte.html.HtmlTemplateOutput jteOutput, gg.jte.html.HtmlInterceptor jteHtmlInterceptor, java.util.Map<String, Object> params) {\n\t\tString one = (String)params.get(\"one\");\n\t\tString two = (String)params.get(\"two\");\n\t\trender(jteOutput, jteHtmlInterceptor, one, two);\n\t}\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_matchLastStream_jmhTest/PathMatcherBenchmark_matchLastStream_jmhTest.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\nimport org.openjdk.jmh.annotations.CompilerControl;\nimport org.openjdk.jmh.runner.InfraControl;\nimport org.openjdk.jmh.infra.ThreadParams;\nimport org.openjdk.jmh.results.BenchmarkTaskResult;\nimport org.openjdk.jmh.results.Result;\nimport org.openjdk.jmh.results.ThroughputResult;\nimport org.openjdk.jmh.results.AverageTimeResult;\nimport org.openjdk.jmh.results.SampleTimeResult;\nimport org.openjdk.jmh.results.SingleShotResult;\nimport org.openjdk.jmh.util.SampleBuffer;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.results.RawResults;\nimport org.openjdk.jmh.results.ResultRole;\nimport java.lang.reflect.Field;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.infra.IterationParams;\nimport org.openjdk.jmh.infra.Blackhole;\nimport org.openjdk.jmh.infra.Control;\nimport org.openjdk.jmh.results.ScalarResult;\nimport org.openjdk.jmh.results.AggregationPolicy;\nimport org.openjdk.jmh.runner.FailureAssistException;\n\nimport io.javalin.performance.jmh_generated.PathMatcherBenchmark_jmhType;\npublic final class PathMatcherBenchmark_matchLastStream_jmhTest {\n\n    byte p000, p001, p002, p003, p004, p005, p006, p007, p008, p009, p010, p011, p012, p013, p014, p015;\n    byte p016, p017, p018, p019, p020, p021, p022, p023, p024, p025, p026, p027, p028, p029, p030, p031;\n    byte p032, p033, p034, p035, p036, p037, p038, p039, p040, p041, p042, p043, p044, p045, p046, p047;\n    byte p048, p049, p050, p051, p052, p053, p054, p055, p056, p057, p058, p059, p060, p061, p062, p063;\n    byte p064, p065, p066, p067, p068, p069, p070, p071, p072, p073, p074, p075, p076, p077, p078, p079;\n    byte p080, p081, p082, p083, p084, p085, p086, p087, p088, p089, p090, p091, p092, p093, p094, p095;\n    byte p096, p097, p098, p099, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111;\n    byte p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126, p127;\n    byte p128, p129, p130, p131, p132, p133, p134, p135, p136, p137, p138, p139, p140, p141, p142, p143;\n    byte p144, p145, p146, p147, p148, p149, p150, p151, p152, p153, p154, p155, p156, p157, p158, p159;\n    byte p160, p161, p162, p163, p164, p165, p166, p167, p168, p169, p170, p171, p172, p173, p174, p175;\n    byte p176, p177, p178, p179, p180, p181, p182, p183, p184, p185, p186, p187, p188, p189, p190, p191;\n    byte p192, p193, p194, p195, p196, p197, p198, p199, p200, p201, p202, p203, p204, p205, p206, p207;\n    byte p208, p209, p210, p211, p212, p213, p214, p215, p216, p217, p218, p219, p220, p221, p222, p223;\n    byte p224, p225, p226, p227, p228, p229, p230, p231, p232, p233, p234, p235, p236, p237, p238, p239;\n    byte p240, p241, p242, p243, p244, p245, p246, p247, p248, p249, p250, p251, p252, p253, p254, p255;\n    int startRndMask;\n    BenchmarkParams benchmarkParams;\n    IterationParams iterationParams;\n    ThreadParams threadParams;\n    Blackhole blackhole;\n    Control notifyControl;\n\n    public BenchmarkTaskResult matchLastStream_Throughput(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchLastStream_thrpt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new ThroughputResult(ResultRole.PRIMARY, \"matchLastStream\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastStream_thrpt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastStream_AverageTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchLastStream_avgt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new AverageTimeResult(ResultRole.PRIMARY, \"matchLastStream\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastStream_avgt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastStream_SampleTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            int targetSamples = (int) (control.getDuration(TimeUnit.MILLISECONDS) * 20); // at max, 20 timestamps per millisecond\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            SampleBuffer buffer = new SampleBuffer();\n            matchLastStream_sample_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, buffer, targetSamples, opsPerInv, batchSize, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps * batchSize;\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new SampleTimeResult(ResultRole.PRIMARY, \"matchLastStream\", buffer, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastStream_sample_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, SampleBuffer buffer, int targetSamples, long opsPerInv, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        long operations = 0;\n        int rnd = (int)System.nanoTime();\n        int rndMask = startRndMask;\n        long time = 0;\n        int currentStride = 0;\n        do {\n            rnd = (rnd * 1664525 + 1013904223);\n            boolean sample = (rnd & rndMask) == 0;\n            if (sample) {\n                time = System.nanoTime();\n            }\n            for (int b = 0; b < batchSize; b++) {\n                if (control.volatileSpoiler) return;\n                l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n            }\n            if (sample) {\n                buffer.add((System.nanoTime() - time) / opsPerInv);\n                if (currentStride++ > targetSamples) {\n                    buffer.half();\n                    currentStride = 0;\n                    rndMask = (rndMask << 1) + 1;\n                }\n            }\n            operations++;\n        } while(!control.isDone);\n        startRndMask = Math.max(startRndMask, rndMask);\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastStream_SingleShotTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            notifyControl.startMeasurement = true;\n            RawResults res = new RawResults();\n            int batchSize = iterationParams.getBatchSize();\n            matchLastStream_ss_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, batchSize, l_pathmatcherbenchmark0_G);\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            int opsPerInv = control.benchmarkParams.getOpsPerInvocation();\n            long totalOps = opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult(totalOps, totalOps);\n            results.add(new SingleShotResult(ResultRole.PRIMARY, \"matchLastStream\", res.getTime(), totalOps, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastStream_ss_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        for (int b = 0; b < batchSize; b++) {\n            if (control.volatileSpoiler) return;\n            l_pathmatcherbenchmark0_G.matchLastStream(blackhole);\n        }\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n    }\n\n    \n    static volatile PathMatcherBenchmark_jmhType f_pathmatcherbenchmark0_G;\n    \n    PathMatcherBenchmark_jmhType _jmh_tryInit_f_pathmatcherbenchmark0_G(InfraControl control) throws Throwable {\n        PathMatcherBenchmark_jmhType val = f_pathmatcherbenchmark0_G;\n        if (val != null) {\n            return val;\n        }\n        synchronized(this.getClass()) {\n            try {\n            if (control.isFailing) throw new FailureAssistException();\n            val = f_pathmatcherbenchmark0_G;\n            if (val != null) {\n                return val;\n            }\n            val = new PathMatcherBenchmark_jmhType();\n            val.setup();\n            val.readyTrial = true;\n            f_pathmatcherbenchmark0_G = val;\n            } catch (Throwable t) {\n                control.isFailing = true;\n                throw t;\n            }\n        }\n        return val;\n    }\n\n\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestClose_Java/TestClose_Java.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin;\n\nimport io.javalin.testing.TestUtil;\nimport java.util.Objects;\nimport org.eclipse.jetty.server.Server;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\nclass TestClose_Java {\n\n    @Test\n    void tryWithResourcesStopsServer() {\n        TestUtil.runLogLess(() -> {\n            final Javalin app = Javalin.create();\n\n            //noinspection EmptyTryBlock\n            try (final AutoClosableJavalin ignored = new AutoClosableJavalin(app).start(0)) {\n                // do nothing\n            }\n\n            final Server server = Objects.requireNonNull(app.jettyServer()).server();\n            assertThat(server.isStopped()).isTrue();\n        });\n    }\n\n    @Test\n    void tryWithResourcesCallsLifecycleEvents() {\n        TestUtil.runLogLess(() -> {\n            final StringBuilder log = new StringBuilder();\n            final Javalin app = Javalin.create().events(event -> {\n                event.serverStopping(() -> log.append(\"Stopping\"));\n                event.serverStopped(() -> log.append(\"Stopped\"));\n            });\n\n            //noinspection EmptyTryBlock\n            try (final AutoClosableJavalin ignored = new AutoClosableJavalin(app).start(0)) {\n                // do nothing\n            }\n\n            assertThat(log.toString()).isEqualTo(\"StoppingStopped\");\n        });\n    }\n\n    @Test\n    void closingInsideTryWithResourcesIsIdempotent() {\n        TestUtil.runLogLess(() -> {\n            final StringBuilder log = new StringBuilder();\n            final Javalin app = Javalin.create().events(event -> {\n                event.serverStopping(() -> log.append(\"Stopping\"));\n                event.serverStopped(() -> log.append(\"Stopped\"));\n            });\n            try (final AutoClosableJavalin startedApp = new AutoClosableJavalin(app).start(0)) {\n                //noinspection RedundantExplicitClose\n                startedApp.close();\n            }\n\n            final Server server = Objects.requireNonNull(app.jettyServer()).server();\n            assertThat(server.isStopped()).isTrue();\n            assertThat(log.toString()).isEqualTo(\"StoppingStopped\");\n        });\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldStaticFiles_external/HelloWorldStaticFiles_external.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.staticfiles.Location;\n\npublic class HelloWorldStaticFiles_external {\n\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.staticFiles.add(\"src/test/external/\", Location.EXTERNAL);\n        }).start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldStaticFiles/HelloWorldStaticFiles.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.staticfiles.Location;\n\npublic class HelloWorldStaticFiles {\n\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.staticFiles.add(\"/public\", Location.CLASSPATH);\n        }).start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestGracefulShutdown/TestGracefulShutdown.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n * @author: Jitsusama\n */\n\npackage io.javalin;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport kong.unirest.HttpResponse;\nimport kong.unirest.Unirest;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.handler.StatisticsHandler;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.MethodOrderer;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.TestMethodOrder;\nimport static io.javalin.http.HttpStatus.OK;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\n// TODO: Fix on Windows so @Disabled can be removed\n@Disabled(\"For running manually\")\n@TestMethodOrder(MethodOrderer.MethodName.class)\npublic class TestGracefulShutdown {\n\n    private static final int LONG_WAIT_TIME_IN_MSECS = 500;\n    private static final int CONNECT_WAIT_TIME_IN_MSECS = 30;\n\n    @Test\n    public void t1_shutdown_is_graceful_with_default_config() throws Exception {\n        Javalin app = Javalin.create().start(0);\n        addEndpoints(app);\n        testIfShutdownIsGraceful(app);\n    }\n\n    @Test\n    public void t2_shutdown_is_graceful_when_custom_server_has_statisticshandler() throws Exception {\n        Server server = new Server();\n        server.insertHandler(new StatisticsHandler());\n        Javalin app = Javalin.create(c -> c.pvt.jetty.server = server).start(0);\n        addEndpoints(app);\n        testIfShutdownIsGraceful(app);\n    }\n\n    @Test\n    public void t3_shutdown_is_not_graceful_when_custom_server_has_no_statisticshandler() {\n        Javalin app = Javalin.create(c -> c.pvt.jetty.server = new Server()).start(0);\n        addEndpoints(app);\n        assertThrows(ExecutionException.class, () -> testIfShutdownIsGraceful(app));\n    }\n\n    private void testIfShutdownIsGraceful(Javalin app) throws Exception {\n        performBlockingRequest(app);\n        Future<HttpResponse<String>> asyncResponse = performAsyncRequest(app);\n        app.stop(); // request has not completed yet\n        assertEquals(asyncResponse.get().getStatus(), OK.getCode());\n    }\n\n    private void addEndpoints(Javalin app) {\n        app.get(\"/immediate-response\", context -> context.status(OK));\n        app.get(\"/delayed-response\", context -> Thread.sleep(LONG_WAIT_TIME_IN_MSECS));\n    }\n\n    private void performBlockingRequest(Javalin app) throws Exception {\n        String requestUri = String.format(\"http://localhost:%d/%s\", app.port(), \"immediate-response\");\n        Unirest.get(requestUri).asString();\n    }\n\n    private Future<HttpResponse<String>> performAsyncRequest(Javalin app) throws Exception {\n        String requestUri = String.format(\"http://localhost:%d/%s\", app.port(), \"delayed-response\");\n        Future<HttpResponse<String>> responseFuture = Unirest.get(requestUri).asStringAsync();\n        Thread.sleep(CONNECT_WAIT_TIME_IN_MSECS);\n        return responseFuture;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestRequest_Java/TestRequest_Java.java",
        "copies": "1",
        "content": "package io.javalin;\n\nimport io.javalin.testing.TestUtil;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class TestRequest_Java {\n\n    @Test\n    public void session_attribute_can_be_consumed_easily() {\n        TestUtil.test((app, http) -> {\n            app.get(\"/store-attr\", ctx -> ctx.sessionAttribute(\"attr\", \"Rowin\"));\n            app.get(\"/read-attr\", ctx -> ctx.result(\"\" + ctx.consumeSessionAttribute(\"attr\")));\n            http.getBody(\"/store-attr\");\n            assertThat(http.getBody(\"/read-attr\")).isEqualTo(\"Rowin\"); // read (and consume) the attribute\n            assertThat(http.getBody(\"/read-attr\")).isEqualTo(\"null\"); // fallback\n        });\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testtools_TestCase/TestCase.java",
        "copies": "1",
        "content": "package io.javalin.testtools;\n\nimport io.javalin.Javalin;\n\n@FunctionalInterface\npublic interface TestCase {\n    void accept(Javalin server, HttpClient client) throws Exception;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_RunResult/RunResult.java",
        "copies": "1",
        "content": "package io.javalin.testing;\n\npublic class RunResult {\n    public String logs;\n    public Exception exception;\n\n    public RunResult(String logs, Exception exception) {\n        this.logs = logs;\n        this.exception = exception;\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/performance_SimpleAsyncTest/SimpleAsyncTest.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.performance;\n\nimport io.javalin.Javalin;\nimport io.javalin.testing.HttpUtil;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.TimeUnit;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport static java.util.stream.IntStream.range;\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class SimpleAsyncTest {\n\n    private static final Logger log = LoggerFactory.getLogger(SimpleAsyncTest.class);\n\n    @Test\n    @Disabled(\"For running manually\")\n    public void test_async() throws Exception {\n\n        QueuedThreadPool threadPool = new QueuedThreadPool(10, 2, 60_000);\n        threadPool.setName(\"poolname\");\n        Javalin app = Javalin.create(c -> c.jetty.threadPool = threadPool).start(0);\n        assertThat(((QueuedThreadPool) app.jettyServer().server().getThreadPool()).getName()).isEqualTo(\"poolname\");\n        HttpUtil http = new HttpUtil(app.port());\n\n        app.get(\"/test-async\", ctx -> ctx.future(this::getFuture));\n        app.get(\"/test-sync\", ctx -> ctx.result(getBlockingResult()));\n\n        timeCallable(\"Async result\", () -> {\n            return new ForkJoinPool(100).submit(() -> range(0, 50).parallel().forEach(i -> {\n                assertThat(http.getBody(\"/test-async\")).isEqualTo(\"success\");\n            })).get();\n        });\n\n        timeCallable(\"Blocking result\", () -> {\n            return new ForkJoinPool(100).submit(() -> range(0, 50).parallel().forEach(i -> {\n                assertThat(http.getBody(\"/test-sync\")).isEqualTo(\"success\");\n            })).get();\n        });\n\n        app.stop();\n    }\n\n    private void timeCallable(String name, Callable<?> callable) throws Exception {\n        long startTime = System.currentTimeMillis();\n        callable.call();\n        log.info(name + \" took \" + (System.currentTimeMillis() - startTime) + \" milliseconds\");\n    }\n\n    private String getBlockingResult() throws InterruptedException {\n        Thread.sleep(2000);\n        return \"success\";\n    }\n\n    private CompletableFuture<String> getFuture() {\n        CompletableFuture<String> future = new CompletableFuture<>();\n        Executors.newSingleThreadScheduledExecutor().schedule(() -> future.complete(\"success\"), 2000, TimeUnit.MILLISECONDS);\n        return future;\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_jmhType/PathMatcherBenchmark_jmhType.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\npublic class PathMatcherBenchmark_jmhType extends PathMatcherBenchmark_jmhType_B3 {\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_matchFirstList_jmhTest/PathMatcherBenchmark_matchFirstList_jmhTest.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\nimport org.openjdk.jmh.annotations.CompilerControl;\nimport org.openjdk.jmh.runner.InfraControl;\nimport org.openjdk.jmh.infra.ThreadParams;\nimport org.openjdk.jmh.results.BenchmarkTaskResult;\nimport org.openjdk.jmh.results.Result;\nimport org.openjdk.jmh.results.ThroughputResult;\nimport org.openjdk.jmh.results.AverageTimeResult;\nimport org.openjdk.jmh.results.SampleTimeResult;\nimport org.openjdk.jmh.results.SingleShotResult;\nimport org.openjdk.jmh.util.SampleBuffer;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.results.RawResults;\nimport org.openjdk.jmh.results.ResultRole;\nimport java.lang.reflect.Field;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.infra.IterationParams;\nimport org.openjdk.jmh.infra.Blackhole;\nimport org.openjdk.jmh.infra.Control;\nimport org.openjdk.jmh.results.ScalarResult;\nimport org.openjdk.jmh.results.AggregationPolicy;\nimport org.openjdk.jmh.runner.FailureAssistException;\n\nimport io.javalin.performance.jmh_generated.PathMatcherBenchmark_jmhType;\npublic final class PathMatcherBenchmark_matchFirstList_jmhTest {\n\n    byte p000, p001, p002, p003, p004, p005, p006, p007, p008, p009, p010, p011, p012, p013, p014, p015;\n    byte p016, p017, p018, p019, p020, p021, p022, p023, p024, p025, p026, p027, p028, p029, p030, p031;\n    byte p032, p033, p034, p035, p036, p037, p038, p039, p040, p041, p042, p043, p044, p045, p046, p047;\n    byte p048, p049, p050, p051, p052, p053, p054, p055, p056, p057, p058, p059, p060, p061, p062, p063;\n    byte p064, p065, p066, p067, p068, p069, p070, p071, p072, p073, p074, p075, p076, p077, p078, p079;\n    byte p080, p081, p082, p083, p084, p085, p086, p087, p088, p089, p090, p091, p092, p093, p094, p095;\n    byte p096, p097, p098, p099, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111;\n    byte p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126, p127;\n    byte p128, p129, p130, p131, p132, p133, p134, p135, p136, p137, p138, p139, p140, p141, p142, p143;\n    byte p144, p145, p146, p147, p148, p149, p150, p151, p152, p153, p154, p155, p156, p157, p158, p159;\n    byte p160, p161, p162, p163, p164, p165, p166, p167, p168, p169, p170, p171, p172, p173, p174, p175;\n    byte p176, p177, p178, p179, p180, p181, p182, p183, p184, p185, p186, p187, p188, p189, p190, p191;\n    byte p192, p193, p194, p195, p196, p197, p198, p199, p200, p201, p202, p203, p204, p205, p206, p207;\n    byte p208, p209, p210, p211, p212, p213, p214, p215, p216, p217, p218, p219, p220, p221, p222, p223;\n    byte p224, p225, p226, p227, p228, p229, p230, p231, p232, p233, p234, p235, p236, p237, p238, p239;\n    byte p240, p241, p242, p243, p244, p245, p246, p247, p248, p249, p250, p251, p252, p253, p254, p255;\n    int startRndMask;\n    BenchmarkParams benchmarkParams;\n    IterationParams iterationParams;\n    ThreadParams threadParams;\n    Blackhole blackhole;\n    Control notifyControl;\n\n    public BenchmarkTaskResult matchFirstList_Throughput(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchFirstList_thrpt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new ThroughputResult(ResultRole.PRIMARY, \"matchFirstList\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstList_thrpt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstList_AverageTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchFirstList_avgt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new AverageTimeResult(ResultRole.PRIMARY, \"matchFirstList\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstList_avgt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstList_SampleTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            int targetSamples = (int) (control.getDuration(TimeUnit.MILLISECONDS) * 20); // at max, 20 timestamps per millisecond\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            SampleBuffer buffer = new SampleBuffer();\n            matchFirstList_sample_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, buffer, targetSamples, opsPerInv, batchSize, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps * batchSize;\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new SampleTimeResult(ResultRole.PRIMARY, \"matchFirstList\", buffer, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstList_sample_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, SampleBuffer buffer, int targetSamples, long opsPerInv, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        long operations = 0;\n        int rnd = (int)System.nanoTime();\n        int rndMask = startRndMask;\n        long time = 0;\n        int currentStride = 0;\n        do {\n            rnd = (rnd * 1664525 + 1013904223);\n            boolean sample = (rnd & rndMask) == 0;\n            if (sample) {\n                time = System.nanoTime();\n            }\n            for (int b = 0; b < batchSize; b++) {\n                if (control.volatileSpoiler) return;\n                l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n            }\n            if (sample) {\n                buffer.add((System.nanoTime() - time) / opsPerInv);\n                if (currentStride++ > targetSamples) {\n                    buffer.half();\n                    currentStride = 0;\n                    rndMask = (rndMask << 1) + 1;\n                }\n            }\n            operations++;\n        } while(!control.isDone);\n        startRndMask = Math.max(startRndMask, rndMask);\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstList_SingleShotTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            notifyControl.startMeasurement = true;\n            RawResults res = new RawResults();\n            int batchSize = iterationParams.getBatchSize();\n            matchFirstList_ss_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, batchSize, l_pathmatcherbenchmark0_G);\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            int opsPerInv = control.benchmarkParams.getOpsPerInvocation();\n            long totalOps = opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult(totalOps, totalOps);\n            results.add(new SingleShotResult(ResultRole.PRIMARY, \"matchFirstList\", res.getTime(), totalOps, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstList_ss_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        for (int b = 0; b < batchSize; b++) {\n            if (control.volatileSpoiler) return;\n            l_pathmatcherbenchmark0_G.matchFirstList(blackhole);\n        }\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n    }\n\n    \n    static volatile PathMatcherBenchmark_jmhType f_pathmatcherbenchmark0_G;\n    \n    PathMatcherBenchmark_jmhType _jmh_tryInit_f_pathmatcherbenchmark0_G(InfraControl control) throws Throwable {\n        PathMatcherBenchmark_jmhType val = f_pathmatcherbenchmark0_G;\n        if (val != null) {\n            return val;\n        }\n        synchronized(this.getClass()) {\n            try {\n            if (control.isFailing) throw new FailureAssistException();\n            val = f_pathmatcherbenchmark0_G;\n            if (val != null) {\n                return val;\n            }\n            val = new PathMatcherBenchmark_jmhType();\n            val.setup();\n            val.readyTrial = true;\n            f_pathmatcherbenchmark0_G = val;\n            } catch (Throwable t) {\n                control.isFailing = true;\n                throw t;\n            }\n        }\n        return val;\n    }\n\n\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/function_ThrowingRunnable/ThrowingRunnable.java",
        "copies": "1",
        "content": "package io.javalin.util.function;\n\n/** Throwing version of {@link java.lang.Runnable} */\n@FunctionalInterface\npublic interface ThrowingRunnable<E extends Exception> {\n    void run() throws E;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_ThrowingBiConsumer/ThrowingBiConsumer.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.testing;\n\nimport java.util.function.BiConsumer;\n\n@FunctionalInterface\npublic interface ThrowingBiConsumer<T, U> extends BiConsumer<T, U> {\n    @Override\n    default void accept(T t, U u) {\n        try {\n            acceptThrows(t, u);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    void acceptThrows(T t, U u) throws Exception;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldServlet/HelloWorldServlet.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.testing.TestServlet;\nimport org.eclipse.jetty.server.Handler;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.handler.ContextHandlerCollection;\nimport org.eclipse.jetty.servlet.ServletContextHandler;\n\npublic class HelloWorldServlet {\n\n    public static void main(String[] args) {\n        Javalin app = Javalin.create(config -> {\n            config.router.contextPath = \"/api\";\n\n            Server server = new Server();\n            ServletContextHandler context = new ServletContextHandler();\n            context.setContextPath(\"/test-servlet\");\n            //Servlet will respond to all requests beginning with /test-servlet\n            context.addServlet(TestServlet.class, \"/\");\n            ContextHandlerCollection handlers = new ContextHandlerCollection();\n            handlers.setHandlers(new Handler[]{context});\n            server.setHandler(handlers);\n\n            config.pvt.jetty.server = server;\n        });\n        app.get(\"/\", ctx -> ctx.result(\"Hello Javalin World!\"));\n        app.start(8000);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldBasicAuth/HelloWorldBasicAuth.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.plugin.bundled.BasicAuthPlugin;\n\npublic class HelloWorldBasicAuth {\n\n    public static void main(String[] args) {\n        Javalin\n            .create(config -> {\n                config.registerPlugin(new BasicAuthPlugin(basicAuthCfg -> {\n                    basicAuthCfg.username = \"panda\";\n                    basicAuthCfg.password = \"bamboo\";\n                }));\n                config.registerPlugin(\n                    new BasicAuthPlugin(basicAuthCfg -> {\n                        basicAuthCfg.username = \"panda\";\n                        basicAuthCfg.password = \"bamboo\";\n                    })\n                );\n            })\n            .get(\"/hello\", ctx -> ctx.result(\"Hello World 1\"))\n            .start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/apibuilder_ApiBuilder/ApiBuilder.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.apibuilder;\n\nimport io.javalin.Javalin;\nimport io.javalin.router.JavalinDefaultRoutingApi;\nimport io.javalin.http.Handler;\nimport io.javalin.router.RoutingApi;\nimport io.javalin.http.sse.SseClient;\nimport io.javalin.security.RouteRole;\nimport io.javalin.websocket.WsConfig;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.function.Consumer;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Static methods for route declarations in Javalin\n */\npublic class ApiBuilder implements RoutingApi {\n\n    private static final ThreadLocal<JavalinDefaultRoutingApi<?>> staticJavalin = new ThreadLocal<>();\n    private static final ThreadLocal<Deque<String>> pathDeque = ThreadLocal.withInitial(ArrayDeque::new);\n\n    public static void setStaticJavalin(@NotNull JavalinDefaultRoutingApi<?> javalin) {\n        staticJavalin.set(javalin);\n    }\n\n    public static void clearStaticJavalin() {\n        staticJavalin.remove();\n    }\n\n    /**\n     * Prefixes all handlers defined in its scope with the specified path.\n     * All paths are normalized, so you can call both\n     * path(\"/path\") or path(\"path\") depending on your preference\n     */\n    public static void path(@NotNull String path, @NotNull EndpointGroup endpointGroup) {\n        path = path.startsWith(\"/\") ? path : \"/\" + path;\n        pathDeque.get().addLast(path);\n        endpointGroup.addEndpoints();\n        pathDeque.get().removeLast();\n    }\n\n    public static String prefixPath(@NotNull String path) {\n        if (!path.equals(\"*\")) {\n            path = (path.startsWith(\"/\") || path.isEmpty()) ? path : \"/\" + path;\n        }\n        return String.join(\"\", pathDeque.get()) + path;\n    }\n\n    public static JavalinDefaultRoutingApi<?> staticInstance() {\n        JavalinDefaultRoutingApi<?> javalin = staticJavalin.get();\n        if (javalin == null) {\n            throw new IllegalStateException(\"The static API can only be used within a routes() call.\");\n        }\n        return javalin;\n    }\n\n    // ********************************************************************************************\n    // HTTP verbs\n    // ********************************************************************************************\n\n    /**\n     * Adds a GET request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup).\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void get(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().get(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a GET request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void get(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().get(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a GET request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void get(@NotNull Handler handler) {\n        staticInstance().get(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a GET request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void get(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().get(prefixPath(\"\"), handler, roles);\n    }\n\n    /**\n     * Adds a POST request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void post(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().post(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a POST request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void post(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().post(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a POST request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void post(@NotNull Handler handler) {\n        staticInstance().post(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a POST request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void post(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().post(prefixPath(\"\"), handler, roles);\n    }\n\n    /**\n     * Adds a PUT request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void put(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().put(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a PUT request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void put(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().put(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a PUT request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void put(@NotNull Handler handler) {\n        staticInstance().put(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a PUT request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void put(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().put(prefixPath(\"\"), handler, roles);\n    }\n\n    /**\n     * Adds a PATCH request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void patch(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().patch(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a PATCH request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void patch(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().patch(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a PATCH request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void patch(@NotNull Handler handler) {\n        staticInstance().patch(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a PATCH request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void patch(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().patch(prefixPath(\"\"), handler, roles);\n    }\n\n    /**\n     * Adds a DELETE request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void delete(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().delete(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a DELETE request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void delete(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().delete(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a DELETE request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void delete(@NotNull Handler handler) {\n        staticInstance().delete(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a DELETE request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void delete(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().delete(prefixPath(\"\"), handler, roles);\n    }\n\n    /**\n     * Adds a HEAD request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void head(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().head(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a HEAD request handler with the given roles for the specified path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void head(@NotNull String path, @NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().head(prefixPath(path), handler, roles);\n    }\n\n    /**\n     * Adds a HEAD request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void head(@NotNull Handler handler) {\n        staticInstance().head(prefixPath(\"\"), handler);\n    }\n\n    /**\n     * Adds a HEAD request handler with the given roles for the current path to the instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void head(@NotNull Handler handler, @NotNull RouteRole... roles) {\n        staticInstance().head(prefixPath(\"\"), handler, roles);\n    }\n\n    // ********************************************************************************************\n    // Before/after handlers (filters)\n    // ********************************************************************************************\n\n    /**\n     * Adds a BEFORE request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#before-handlers\">Handlers in docs</a>\n     */\n    public static void before(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().before(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a BEFORE request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void before(@NotNull Handler handler) {\n        staticInstance().before(prefixPath(\"*\"), handler);\n    }\n\n    /**\n     * Adds an AFTER request handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#before-handlers\">Handlers in docs</a>\n     */\n    public static void after(@NotNull String path, @NotNull Handler handler) {\n        staticInstance().after(prefixPath(path), handler);\n    }\n\n    /**\n     * Adds a AFTER request handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void after(@NotNull Handler handler) {\n        staticInstance().after(prefixPath(\"*\"), handler);\n    }\n\n    // ********************************************************************************************\n    // WebSocket\n    // ********************************************************************************************\n\n    /**\n     * Adds a WebSocket handler on the specified path.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#websockets\">WebSockets in docs</a>\n     */\n    public static void ws(@NotNull String path, @NotNull Consumer<WsConfig> ws) {\n        staticInstance().ws(prefixPath(path), ws);\n    }\n\n    /**\n     * Adds a WebSocket handler with the given roles for the specified path.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#websockets\">WebSockets in docs</a>\n     */\n    public static void ws(@NotNull String path, @NotNull Consumer<WsConfig> ws, @NotNull RouteRole... roles) {\n        staticInstance().ws(prefixPath(path), ws, roles);\n    }\n\n    /**\n     * Adds a WebSocket handler on the current path.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#websockets\">WebSockets in docs</a>\n     */\n    public static void ws(@NotNull Consumer<WsConfig> ws) {\n        staticInstance().ws(prefixPath(\"\"), ws);\n    }\n\n    /**\n     * Adds a WebSocket handler with the given roles for the current path.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#websockets\">WebSockets in docs</a>\n     */\n    public static void ws(@NotNull Consumer<WsConfig> ws, @NotNull RouteRole... roles) {\n        staticInstance().ws(prefixPath(\"\"), ws, roles);\n    }\n\n    /**\n     * Adds a WebSocket before handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     */\n    public void wsBefore(@NotNull String path, @NotNull Consumer<WsConfig> wsConfig) {\n        staticInstance().wsBefore(prefixPath(path), wsConfig);\n    }\n\n    /**\n     * Adds a WebSocket before handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     */\n    public void wsBefore(@NotNull Consumer<WsConfig> wsConfig) {\n        staticInstance().wsBefore(prefixPath(\"*\"), wsConfig);\n    }\n\n    /**\n     * Adds a WebSocket after handler for the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     */\n    public void wsAfter(@NotNull String path, @NotNull Consumer<WsConfig> wsConfig) {\n        staticInstance().wsAfter(prefixPath(path), wsConfig);\n    }\n\n    /**\n     * Adds a WebSocket after handler for the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     */\n    public void wsAfter(@NotNull Consumer<WsConfig> wsConfig) {\n        staticInstance().wsAfter(prefixPath(\"*\"), wsConfig);\n    }\n\n    // ********************************************************************************************\n    // Server-sent events\n    // ********************************************************************************************\n\n    public static void sse(@NotNull String path, @NotNull Consumer<SseClient> client) {\n        staticInstance().sse(prefixPath(path), client);\n    }\n\n    public static void sse(@NotNull String path, @NotNull Consumer<SseClient> client, @NotNull RouteRole... roles) {\n        staticInstance().sse(prefixPath(path), client, roles);\n    }\n\n    public static void sse(@NotNull Consumer<SseClient> client) {\n        staticInstance().sse(prefixPath(\"\"), client);\n    }\n\n    public static void sse(@NotNull Consumer<SseClient> client, @NotNull RouteRole... roles) {\n        staticInstance().sse(prefixPath(\"\"), client, roles);\n    }\n\n    // ********************************************************************************************\n    // CrudHandler\n    // ********************************************************************************************\n\n    /**\n     * Adds a CrudHandler handler to the current path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void crud(@NotNull CrudHandler crudHandler) {\n        crud(\"\", crudHandler, new RouteRole[0]);\n    }\n\n    /**\n     * Adds a CrudHandler handler to the current path with the given roles to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see <a href=\"https://javalin.io/documentation#handlers\">Handlers in docs</a>\n     */\n    public static void crud(@NotNull CrudHandler crudHandler, @NotNull RouteRole... roles) {\n        crud(\"\", crudHandler, roles);\n    }\n\n    /**\n     * Adds a CrudHandler handler to the specified path to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see CrudHandler\n     */\n    public static void crud(@NotNull String path, @NotNull CrudHandler crudHandler) {\n        crud(path, crudHandler, new RouteRole[0]);\n    }\n\n    /**\n     * Adds a CrudHandler handler to the specified path with the given roles to the {@link Javalin} instance.\n     * The method can only be called inside a config.router.apiBuilder(EndpointGroup)}.\n     *\n     * @see CrudHandler\n     */\n    public static void crud(@NotNull String path, @NotNull CrudHandler crudHandler, @NotNull RouteRole... roles) {\n        String fullPath = prefixPath(path);\n        String[] subPaths = Arrays.stream(fullPath.split(\"/\")).filter(it -> !it.isEmpty()).toArray(String[]::new);\n        if (subPaths.length < 2) {\n            throw new IllegalArgumentException(\"CrudHandler requires a path like '/resource/{resource-id}'\");\n        }\n        String resourceId = subPaths[subPaths.length - 1];\n        if (!(resourceId.startsWith(\"{\") && resourceId.endsWith(\"}\"))) {\n            throw new IllegalArgumentException(\"CrudHandler requires a path-parameter at the end of the provided path, e.g. '/users/{user-id}'\");\n        }\n        String resourceBase = subPaths[subPaths.length - 2];\n        if (resourceBase.startsWith(\"{\") || resourceBase.startsWith(\"<\") || resourceBase.endsWith(\"}\") || resourceBase.endsWith(\">\")) {\n            throw new IllegalArgumentException(\"CrudHandler requires a resource base at the beginning of the provided path, e.g. '/users/{user-id}'\");\n        }\n        staticInstance().get(fullPath, ctx -> crudHandler.getOne(ctx, ctx.pathParam(resourceId)), roles);\n        staticInstance().get(fullPath.replace(resourceId, \"\"), crudHandler::getAll, roles);\n        staticInstance().post(fullPath.replace(resourceId, \"\"), crudHandler::create, roles);\n        staticInstance().patch(fullPath, ctx -> crudHandler.update(ctx, ctx.pathParam(resourceId)), roles);\n        staticInstance().delete(fullPath, ctx -> crudHandler.delete(ctx, ctx.pathParam(resourceId)), roles);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_NonSerializableObject/NonSerializableObject.java",
        "copies": "1",
        "content": "package io.javalin.testing;\n\npublic class NonSerializableObject {\n    private final String value1 = \"First value\";\n    private final String value2 = \"Second value\";\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_TestServlet/TestServlet.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.testing;\n\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\npublic class TestServlet extends HttpServlet {\n    public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {\n        PrintWriter out = res.getWriter();\n        out.println(\"Hello Servlet World!\");\n        out.close();\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/http_RequestLogger/RequestLogger.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.http;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Interface for logging requests.\n *\n * @see Context\n * @see <a href=\"https://javalin.io/documentation#request-loggers\">RequestLogger in documentation</a>\n */\n@FunctionalInterface\npublic interface RequestLogger {\n    /**\n     * Handles a request\n     *\n     * @param ctx             the current request context\n     * @param executionTimeMs the requests' execution time in milliseconds\n     * @throws Exception any exception while logging information about the request\n     */\n    void handle(@NotNull Context ctx, @NotNull Float executionTimeMs) throws Exception;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_TestUtil/TestUtil.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.testing;\n\nimport io.javalin.Javalin;\nimport io.javalin.config.Key;\nimport io.javalin.http.Handler;\nimport io.javalin.util.JavalinLogger;\nimport java.io.ByteArrayOutputStream;\nimport java.io.PrintStream;\nimport kong.unirest.HttpMethod;\n\npublic class TestUtil {\n\n    public static Boolean captureLogs = true;\n\n    public static Handler okHandler = ctx -> ctx.result(\"OK\");\n\n    public static Key<String> TestLogsKey = new Key<>(\"testlogs\");\n\n    public static void test(ThrowingBiConsumer<Javalin, HttpUtil> test) {\n        test(Javalin.create(), test);\n    }\n\n    public static void test(Javalin app, ThrowingBiConsumer<Javalin, HttpUtil> userCode) {\n        testWithResult(app, userCode);\n    }\n\n    public static RunResult testWithResult(ThrowingBiConsumer<Javalin, HttpUtil> test) {\n        return testWithResult(Javalin.create(), test);\n    }\n\n    public static RunResult testWithResult(Javalin app, ThrowingBiConsumer<Javalin, HttpUtil> userCode) {\n        RunResult result = runAndCaptureLogs(() -> {\n            app.start(0);\n            HttpUtil http = new HttpUtil(app.port());\n            userCode.accept(app, http);\n            app.delete(\"/x-test-cookie-cleaner\", ctx -> ctx.cookieMap().keySet().forEach(ctx::removeCookie));\n            http.call(HttpMethod.DELETE, \"/x-test-cookie-cleaner\");\n            app.stop();\n        });\n        app.unsafeConfig().appData(TestLogsKey, result.logs);\n        if (result.exception != null) {\n            JavalinLogger.error(\"TestUtil#test failed - full log output below:\\n\" + result.logs);\n            throw new RuntimeException(result.exception);\n        }\n        return result;\n    }\n\n    public static RunResult runAndCaptureLogs(Runnable testCode) {\n        Exception exception = null;\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        PrintStream printStream = new PrintStream(out);\n        PrintStream oldOut = System.out;\n        PrintStream oldErr = System.err;\n        if (captureLogs) {\n            System.setOut(printStream);\n            System.setErr(printStream);\n        }\n        try {\n            testCode.run();\n        } catch (Throwable t) {\n            if (t instanceof Exception) exception = (Exception) t;\n            else if (t instanceof AssertionError) exception = new Exception(\"Assertion error: \" + t.getMessage());\n            else exception = new Exception(\"Unexpected Throwable in test. Message: '\" + t.getMessage() + \"'\", t);\n        } finally {\n            System.out.flush();\n            System.setOut(oldOut);\n            System.setErr(oldErr);\n        }\n        return new RunResult(out.toString(), exception);\n    }\n\n    public static void runLogLess(Runnable run) {\n        RunResult result = runAndCaptureLogs(run);\n        if (result.exception != null) {\n            JavalinLogger.error(\"TestUtil#runLogLess failed - full log output below:\\n\" + result.logs);\n            throw new RuntimeException(result.exception);\n        }\n    }\n\n    public static String captureStdOut(Runnable run) {\n        return runAndCaptureLogs(run).logs;\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/websocket_WsConfig/WsConfig.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.websocket;\n\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Holds the different WebSocket handlers for a specific {@link WsHandlerEntry} or the WebSocket logger.\n */\npublic class WsConfig {\n\n    WsConnectHandler wsConnectHandler = null;\n    WsMessageHandler wsMessageHandler = null;\n    WsBinaryMessageHandler wsBinaryMessageHandler = null;\n    WsCloseHandler wsCloseHandler = null;\n    WsErrorHandler wsErrorHandler = null;\n\n    /**\n     * Add a WsConnectHandler to the WsHandler.\n     * The handler is called when a WebSocket client connects.\n     */\n    public void onConnect(@NotNull WsConnectHandler wsConnectHandler) {\n        this.wsConnectHandler = wsConnectHandler;\n    }\n\n    /**\n     * Add a WsMessageHandler to the WsHandler.\n     * The handler is called when a WebSocket client sends\n     * a String message.\n     */\n    public void onMessage(@NotNull WsMessageHandler wsMessageHandler) {\n        this.wsMessageHandler = wsMessageHandler;\n    }\n\n    /**\n     * Add a {@link WsBinaryMessageHandler} to the WsHandler.\n     * The handler is called when a WebSocket client sends\n     * a binary message.\n     */\n    public void onBinaryMessage(@NotNull WsBinaryMessageHandler wsBinaryMessageHandler) {\n        this.wsBinaryMessageHandler = wsBinaryMessageHandler;\n    }\n\n    /**\n     * Add a WsCloseHandler to the WsHandler.\n     * The handler is called when a WebSocket client closes\n     * the connection. The handler is not called in case of\n     * network issues, only when the client actively closes the\n     * connection (or times out).\n     */\n    public void onClose(@NotNull WsCloseHandler wsCloseHandler) {\n        this.wsCloseHandler = wsCloseHandler;\n    }\n\n    /**\n     * Add a wsErrorHandler to the WsHandler.\n     * The handler is called when an error is detected.\n     */\n    public void onError(@NotNull WsErrorHandler wsErrorHandler) {\n        this.wsErrorHandler = wsErrorHandler;\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/http_ExceptionHandler/ExceptionHandler.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.http;\n\nimport io.javalin.Javalin;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * A handler for use with {@link Javalin#exception(Class, ExceptionHandler)}.\n * Is triggered when exceptions are thrown by a {@link Handler}.\n *\n * @see Context\n * @see <a href=\"https://javalin.io/documentation#exception-mapping\">Exception mapping in docs</a>\n */\n@FunctionalInterface\npublic interface ExceptionHandler<T extends Exception> {\n    /**\n     * Handles an exception thrown while handling a request\n     *\n     * @param exception the thrown exception\n     * @param ctx       the context of the request\n     */\n    void handle(@NotNull T exception, @NotNull Context ctx);\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldCustomJsonMapper/HelloWorldCustomJsonMapper.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.json.JsonMapper;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport org.jetbrains.annotations.NotNull;\n\npublic class HelloWorldCustomJsonMapper {\n\n    public static void main(String[] args) {\n        JsonMapper rawJsonMapper = new JsonMapper() {\n            @NotNull\n            @Override\n            public String toJsonString(@NotNull Object obj, @NotNull Type type) {\n                // serialize obj your favourite api\n                return \"{ \\\"\" + type.getTypeName() + \"\\\": \\\"\" + obj + \"\\\" }\";\n            }\n\n            @NotNull\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <T> T fromJsonString(@NotNull String json, @NotNull Type targetType) {\n                // deserialize json your favourite api\n                if (targetType.equals(String.class)) {\n                    return (T) json;\n                } else {\n                    throw new UnsupportedOperationException(\"RawJsonMapper can deserialize only strings\");\n                }\n            }\n        };\n\n        Javalin.create(config -> config.jsonMapper(rawJsonMapper))\n            .get(\"/\", ctx -> ctx.json(Arrays.asList(\"a\", \"b\", \"c\")))\n            .start(7070);\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalin_TestJavalinInstanceAndConfigApi_Java/TestJavalinInstanceAndConfigApi_Java.java",
        "copies": "1",
        "content": "package io.javalin;\n\nimport io.javalin.apibuilder.ApiBuilder;\nimport io.javalin.compression.CompressionStrategy;\nimport io.javalin.config.Key;\nimport io.javalin.config.MultipartConfig;\nimport io.javalin.json.JavalinJackson;\nimport io.javalin.plugin.Plugin;\nimport org.eclipse.jetty.server.ServerConnector;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\n\npublic class TestJavalinInstanceAndConfigApi_Java {\n\n    public void testJavalinInstanceAndConfigApi() {\n\n        Javalin javalin = Javalin.create(app -> {\n            // Jetty\n            app.jetty.multipartConfig = new MultipartConfig();\n            app.jetty.defaultHost = \"localhost\";\n            app.jetty.defaultPort = 8080;\n            app.jetty.threadPool = new QueuedThreadPool();\n            app.jetty.addConnector((server, config) -> new ServerConnector(server));\n            app.jetty.modifyHttpConfiguration(httpConfig -> {});\n            app.jetty.modifyServer(server -> {});\n            app.jetty.modifyServletContextHandler(handler -> {});\n            app.jetty.modifyWebSocketServletFactory(factory -> {});\n            // Http and compression\n            app.http.defaultContentType = \"text/plain\";\n            app.http.asyncTimeout = 10_000L;\n            app.http.maxRequestSize = 10_000L;\n            app.http.generateEtags = true;\n            app.http.prefer405over404 = true;\n            app.http.customCompression(new CompressionStrategy());\n            app.http.brotliAndGzipCompression(3);\n            app.http.brotliOnlyCompression(3);\n            app.http.gzipOnlyCompression(3);\n            app.http.disableCompression();\n            // Static files\n            app.staticFiles.add(\"/public\");\n            app.staticFiles.enableWebjars();\n            // Router\n            app.router.contextPath = \"/api\";\n            app.router.caseInsensitiveRoutes = true;\n            app.router.ignoreTrailingSlashes = true;\n            app.router.treatMultipleSlashesAsSingleSlash = true;\n            app.router.mount(router -> {\n                router.before(\"/hello\", ctx -> {});\n                router.get(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n                router.post(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n                router.exception(Exception.class, (e, ctx) -> {});\n                router.error(404, ctx -> ctx.result(\"Not found\"));\n                router.after(\"/hello\", ctx -> {});\n                router.sse(\"/sse\", client -> {});\n                router.ws(\"/ws\", ws -> {});\n            });\n            app.router.apiBuilder(() -> {\n                ApiBuilder.get(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n            });\n            // Context resolver\n            app.contextResolver.fullUrl = ctx -> \"Test\";\n            app.contextResolver.host = ctx -> \"Test\";\n            app.contextResolver.ip = ctx -> \"Test\";\n            app.contextResolver.url = ctx -> \"Test\";\n            app.contextResolver.scheme = ctx -> \"Test\";\n            // Bundled plugins\n            app.bundledPlugins.enableDevLogging();\n            app.bundledPlugins.enableRouteOverview(\"/overview\");\n            app.bundledPlugins.enableSslRedirects();\n            // Events\n            app.events(event -> {\n                event.serverStarting(() -> System.out.println(\"Server is starting\"));\n                event.serverStartFailed(() -> System.out.println(\"Server start failed\"));\n                event.serverStarted(() -> System.out.println(\"Server is started\"));\n                event.serverStopping(() -> System.out.println(\"Server is stopping\"));\n                event.serverStopFailed(() -> System.out.println(\"Server stop failed\"));\n                event.serverStopped(() -> System.out.println(\"Server is stopped\"));\n                event.handlerAdded(handlerMetaInfo -> {});\n                event.wsHandlerAdded(wsHandlerMetaInfo -> {});\n            });\n            // Request logger\n            app.requestLogger.http((ctx, ms) -> {});\n            app.requestLogger.ws(ctx -> {});\n            // Validation\n            app.validation.register(Object.class, o -> new Object());\n            // Vue\n            app.vue.cacheControl = \"Test\";\n            app.vue.enableCspAndNonces = true;\n            app.vue.vueInstanceNameInJs = \"Test\";\n            app.vue.isDevFunction = ctx -> true;\n            app.vue.optimizeDependencies = true;\n            app.vue.stateFunction = ctx -> \"Test\";\n            app.vue.rootDirectory(\"Test\");\n            // Spa root\n            app.spaRoot.addFile(\"/\", \"index.html\");\n            app.spaRoot.addHandler(\"/\", ctx -> {});\n            // Other\n            app.showJavalinBanner = false;\n            app.startupWatcherEnabled = false;\n            app.useVirtualThreads = true;\n            app.jsonMapper(new JavalinJackson());\n            app.appData(new Key<>(\"Test\"), \"Test\");\n            app.fileRenderer((filePath, model, ctx) -> \"Test\");\n            app.registerPlugin(new Plugin<>() {});\n        });\n\n        javalin.events(event -> {\n            event.serverStarting(() -> System.out.println(\"Server is starting\"));\n            event.serverStartFailed(() -> System.out.println(\"Server start failed\"));\n            event.serverStarted(() -> System.out.println(\"Server is started\"));\n            event.serverStopping(() -> System.out.println(\"Server is stopping\"));\n            event.serverStopFailed(() -> System.out.println(\"Server stop failed\"));\n            event.serverStopped(() -> System.out.println(\"Server is stopped\"));\n            event.handlerAdded(handlerMetaInfo -> {});\n            event.wsHandlerAdded(wsHandlerMetaInfo -> {});\n        });\n        javalin.before(\"/hello\", ctx -> {});\n        javalin.get(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n        javalin.post(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n        javalin.exception(Exception.class, (e, ctx) -> {});\n        javalin.error(404, ctx -> ctx.result(\"Not found\"));\n        javalin.after(\"/hello\", ctx -> {});\n        javalin.sse(\"/sse\", client -> {});\n        javalin.ws(\"/ws\", ws -> {});\n        javalin.start();\n        javalin.javalinServlet();\n        javalin.jettyServer();\n        javalin.port();\n        javalin.unsafeConfig();\n        javalin.stop();\n\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testtools_JavaTest/JavaTest.java",
        "copies": "1",
        "content": "package io.javalin.testtools;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.Header;\nimport okhttp3.FormBody;\nimport okhttp3.OkHttpClient;\nimport okhttp3.Request;\nimport okhttp3.Response;\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static io.javalin.http.HttpStatus.OK;\nimport static io.javalin.http.HttpStatus.INTERNAL_SERVER_ERROR;\nimport static io.javalin.testtools.TestTool.TestLogsKey;\nimport static org.assertj.core.api.Assertions.assertThatExceptionOfType;\nimport static org.assertj.core.api.Assertions.assertThatNoException;\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\npublic class JavaTest {\n\n    static class MyJavaClass {\n        public String field1;\n        public String field2;\n\n        public MyJavaClass() {\n        }\n\n        public MyJavaClass(String field1, String field2) {\n            this.field1 = field1;\n            this.field2 = field2;\n        }\n    }\n\n    @Test\n    public void get_method_works() {\n        JavalinTest.test((server, client) -> {\n            server.get(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n            Response response = client.get(\"/hello\");\n            assertThat(response.code()).isEqualTo(OK.getCode());\n            assertThat(response.body().string()).isEqualTo(\"Hello, World!\");\n        });\n    }\n\n    @Test\n    public void can_do_query_params_and_headers() {\n        JavalinTest.test((server, client) -> {\n            server.get(\"/hello\", ctx -> {\n                String response = ctx.queryParam(\"from\") + \" \" + ctx.header(Header.FROM);\n                ctx.result(response);\n            });\n            Response response = client.get(\"/hello?from=From\", req -> req.header(Header.FROM, \"Paris to Berlin\"));\n            assertThat(response.body().string()).isEqualTo(\"From Paris to Berlin\");\n        });\n    }\n\n    @Test\n    public void post_with_json_serialization_works() {\n        JavalinTest.test((server, client) -> {\n            server.post(\"/hello\", ctx -> ctx.result(ctx.bodyAsClass(MyJavaClass.class).field1));\n            Response response = client.post(\"/hello\", new MyJavaClass(\"v1\", \"v2\"));\n            assertThat(response.body().string()).isEqualTo(\"v1\");\n        });\n    }\n\n    @Test\n    public void all_common_verbs_work() {\n        JavalinTest.test((server, client) -> {\n            server.get(\"/\", ctx -> ctx.result(\"GET\"));\n            assertThat(client.get(\"/\").body().string()).isEqualTo(\"GET\");\n\n            server.post(\"/\", ctx -> ctx.result(\"POST\"));\n            assertThat(client.post(\"/\").body().string()).isEqualTo(\"POST\");\n\n            server.patch(\"/\", ctx -> ctx.result(\"PATCH\"));\n            assertThat(client.patch(\"/\").body().string()).isEqualTo(\"PATCH\");\n\n            server.put(\"/\", ctx -> ctx.result(\"PUT\"));\n            assertThat(client.put(\"/\").body().string()).isEqualTo(\"PUT\");\n\n            server.delete(\"/\", ctx -> ctx.result(\"DELETE\"));\n            assertThat(client.delete(\"/\").body().string()).isEqualTo(\"DELETE\");\n        });\n    }\n\n    @Test\n    public void request_method_works() {\n        JavalinTest.test((server, client) -> {\n            server.post(\"/form\", ctx -> ctx.result(ctx.formParam(\"username\")));\n            Response response = client.request(\"/form\", requestBuilder -> {\n                requestBuilder.post(new FormBody.Builder().add(\"username\", \"test\").build());\n            });\n            assertThat(response.body().string()).isEqualTo(\"test\");\n        });\n    }\n\n    @Test\n    public void custom_javalin_works() {\n        Javalin app = Javalin.create()\n            .get(\"/hello\", ctx -> ctx.result(\"Hello, World!\"));\n        JavalinTest.test(app, (server, client) -> {\n            assertThat(client.get(\"/hello\").body().string()).isEqualTo(\"Hello, World!\");\n        });\n    }\n\n    @Test\n    public void capture_std_out_works() {\n        Logger logger = LoggerFactory.getLogger(JavaTest.class);\n        JavalinTest.test((server, client) -> {\n            server.get(\"/hello\", ctx -> {\n                System.out.println(\"sout was called\");\n                logger.info(\"logger was called\");\n            });\n            String stdOut = JavalinTest.captureStdOut(() -> client.get(\"/hello\"));\n            assertThat(stdOut).contains(\"sout was called\");\n            assertThat(stdOut).contains(\"logger was called\");\n        });\n    }\n\n    @Test\n    public void testing_full_app_works() {\n        JavalinTest.test(new JavaApp().app, (server, client) -> {\n            assertThat(client.get(\"/hello\").body().string()).isEqualTo(\"Hello, app!\");\n            assertThat(client.get(\"/hello/\").body().string()).isEqualTo(\"Endpoint GET /hello/ not found\"); // JavaApp.app won't ignore trailing slashes\n        });\n    }\n\n    @Test\n    void custom_okHttpClient_is_used() {\n        Javalin app = Javalin.create()\n            .get(\"/hello\", ctx -> ctx.result(\"Hello, \" + ctx.header(\"X-Welcome\") + \"!\"));\n\n        OkHttpClient okHttpClientAddingHeader = new OkHttpClient.Builder()\n            .addInterceptor(chain -> {\n                Request userRequest = chain.request();\n                return chain.proceed(userRequest.newBuilder()\n                    .addHeader(\"X-Welcome\", \"Javalin\")\n                    .build());\n            })\n            .build();\n\n        TestConfig config = new TestConfig(true, true, okHttpClientAddingHeader);\n\n        JavalinTest.test(app, config, (server, client) -> {\n            assertThat(client.get(\"/hello\").body().string()).isEqualTo(\"Hello, Javalin!\");\n        });\n    }\n\n    TestTool javalinTest = new TestTool(new TestConfig(false));\n\n    @Test\n    void instantiate_JavalinTestTool() {\n        javalinTest.test((server, client) -> {\n            server.get(\"/hello\", ctx -> ctx.result(\"Hello world\"));\n            assertThat(client.get(\"/hello\").body().string()).isEqualTo(\"Hello world\");\n        });\n    }\n\n    public void exceptions_in_test_code_get_rethrown() {\n        assertThatExceptionOfType(Exception.class).isThrownBy(() ->\n            JavalinTest.test((server, client) -> {\n                throw new Exception(\"Error in test code\");\n            })\n        ).withMessageMatching(\"Error in test code\");\n    }\n\n    @Test\n    public void exceptions_in_handler_code_are_caught_by_exception_handler_and_not_thrown() {\n        assertThatNoException().isThrownBy(() ->\n            JavalinTest.test((server, client) -> {\n                server.get(\"/hello\", ctx -> {\n                    throw new Exception(\"Error in handler code\");\n                });\n\n                assertThat(client.get(\"/hello\").code()).isEqualTo(INTERNAL_SERVER_ERROR.getCode());\n            })\n        );\n    }\n\n    @Test\n    public void exception_in_handler_code_is_included_in_test_logs() {\n        Javalin app = Javalin.create();\n\n        try {\n            JavalinTest.test(app, (server, client) -> {\n                server.get(\"/hello\", ctx -> {\n                    throw new Exception(\"Error in handler code\");\n                });\n\n                assertThat(client.get(\"/hello\").code()).isEqualTo(OK.getCode());\n            });\n        } catch (Throwable t) {\n            // Ignore\n        }\n\n        assertThat(app.unsafeConfig().pvt.appDataManager.get(TestLogsKey)).contains(\"Error in handler code\");\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/apibuilder_EndpointGroup/EndpointGroup.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.apibuilder;\n\n@FunctionalInterface\npublic interface EndpointGroup {\n    void addEndpoints();\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/vue_VueDependencyResolver/VueDependencyResolver.java",
        "copies": "1",
        "content": "/*\n * Copyright 2020 tareq.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.javalin.vue;\n\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * @author tareq\n */\npublic class VueDependencyResolver {\n\n    private final Map<String, String> componentIdToOwnContent; // {component-id: component-content}\n    private final Map<String, String> componentIdToDependencyContent; // {component-id: required-dependencies}\n    private final Pattern tagRegex = Pattern.compile(\"<\\\\s*([a-z0-9|-]*).*?>\", Pattern.DOTALL);\n    private final Pattern componentRegex;\n    private final String appName;\n\n    public VueDependencyResolver(final Set<Path> paths, String appVarName) {\n        appName = appVarName != null ? appVarName : \"Vue\"; // appname should be \"Vue\" for vue2 apps\n        componentIdToOwnContent = new HashMap<>();\n        componentIdToDependencyContent = new HashMap<>();\n        componentRegex = Pattern.compile(appName + \".component\\\\s*\\\\(\\\\s*[\\\"|'](.*)[\\\"|']\\\\s*,.*\");\n        paths.stream().filter(VueHandlerKt::isVueFile).forEach(path -> {\n            String fileContent = VueHandlerKt.readText(path);\n            Matcher matcher = componentRegex.matcher(fileContent); // check for a vue component\n            while (matcher.find()) {\n                componentIdToOwnContent.put(matcher.group(1), fileContent); // cache the file content, bound to the component name\n            }\n        });\n    }\n\n    /**\n     * Build the HTML of components needed for this component\n     *\n     * @param componentId the component-id to build the HTMl for.\n     * @return a HTML string of the components needed for this page/view if the\n     * component is found, an error string otherwise.\n     */\n    public String resolve(final String componentId) {\n        if (!componentIdToOwnContent.containsKey(componentId)) {\n            throw new IllegalArgumentException(String.format(\"Component %s not found in app %s\", componentId, appName));\n        }\n        if (componentIdToDependencyContent.containsKey(componentId)) {\n            return componentIdToDependencyContent.get(componentId);\n        }\n        Set<String> dependencies = resolveTransitiveDependencies(componentId);\n\n        StringBuilder builder = new StringBuilder();\n        dependencies.forEach(dependency -> {\n            builder.append(\"<!-- \").append(dependency).append(\" -->\\n\");\n            builder.append(componentIdToOwnContent.get(dependency));\n            builder.append(\"\\n\");\n        });\n        String allDependencies = builder.toString();\n        componentIdToDependencyContent.put(componentId, allDependencies);\n        return allDependencies;\n    }\n\n    /**\n     * Resolve the dependencies for a required component based on the contents\n     * of its file\n     *\n     * @param componentId the name of the component, without tags\n     * @return a Set of dependencies needed to render this component\n     */\n    private Set<String> resolveTransitiveDependencies(final String componentId) {\n        Set<String> requiredComponents = new HashSet<>();\n        requiredComponents.add(componentId);// add it to the dependency list\n        Set<String> directDependencies = resolveDirectDependencies(componentId); // get its dependencies\n        requiredComponents.addAll(directDependencies); // add all its dependencies  to the required components list\n        directDependencies.forEach(dependency -> {\n            // resolve each dependency\n            requiredComponents.addAll(resolveTransitiveDependencies(dependency));\n        });\n        return requiredComponents;\n    }\n\n    /**\n     * Resolve the direct dependencies for a component\n     *\n     * @param componentId the component to resolve dependencies for.\n     * @return a set of dependencies.\n     */\n    private Set<String> resolveDirectDependencies(final String componentId) {\n        Set<String> dependencies = new HashSet<>();\n        String componentContent = componentIdToOwnContent.get(componentId);\n        Matcher matcher = tagRegex.matcher(componentContent); // match for HTML tags\n        while (matcher.find()) {\n            String match = matcher.group(1);\n            if (!match.equals(componentId) && componentIdToOwnContent.containsKey(match)) { // if it isn't the component itself, and its in the component map\n                dependencies.add(match); // add it to the list of dependencies\n            }\n        }\n        return dependencies;\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldSecure/HelloWorldSecure.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport org.eclipse.jetty.server.ServerConnector;\nimport org.eclipse.jetty.util.ssl.SslContextFactory;\n\npublic class HelloWorldSecure {\n\n    // This is a very basic example, a better one can be found at:\n    // https://github.com/eclipse/jetty.project/blob/jetty-9.4.x/examples/embedded/src/main/java/org/eclipse/jetty/embedded/LikeJettyXml.java#L139-L163\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.jetty.addConnector((server, httpConfiguration) -> {\n                    ServerConnector sslConnector = new ServerConnector(server, getSslContextFactory());\n                    sslConnector.setPort(443);\n                    return sslConnector;\n            });\n            config.jetty.addConnector((server, httpConfiguration) -> {\n                    ServerConnector connector = new ServerConnector(server);\n                    connector.setPort(80);\n                    return connector;\n            });\n\n        }).start().get(\"/\", ctx -> ctx.result(\"Hello World\")); // valid endpoint for both connectors\n    }\n\n    private static SslContextFactory.Server getSslContextFactory() {\n        SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();\n        sslContextFactory.setKeyStorePath(HelloWorldSecure.class.getResource(\"/keystore.jks\").toExternalForm());\n        sslContextFactory.setKeyStorePassword(\"password\");\n        return sslContextFactory;\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_matchFirstStream_jmhTest/PathMatcherBenchmark_matchFirstStream_jmhTest.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\nimport org.openjdk.jmh.annotations.CompilerControl;\nimport org.openjdk.jmh.runner.InfraControl;\nimport org.openjdk.jmh.infra.ThreadParams;\nimport org.openjdk.jmh.results.BenchmarkTaskResult;\nimport org.openjdk.jmh.results.Result;\nimport org.openjdk.jmh.results.ThroughputResult;\nimport org.openjdk.jmh.results.AverageTimeResult;\nimport org.openjdk.jmh.results.SampleTimeResult;\nimport org.openjdk.jmh.results.SingleShotResult;\nimport org.openjdk.jmh.util.SampleBuffer;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.results.RawResults;\nimport org.openjdk.jmh.results.ResultRole;\nimport java.lang.reflect.Field;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.infra.IterationParams;\nimport org.openjdk.jmh.infra.Blackhole;\nimport org.openjdk.jmh.infra.Control;\nimport org.openjdk.jmh.results.ScalarResult;\nimport org.openjdk.jmh.results.AggregationPolicy;\nimport org.openjdk.jmh.runner.FailureAssistException;\n\nimport io.javalin.performance.jmh_generated.PathMatcherBenchmark_jmhType;\npublic final class PathMatcherBenchmark_matchFirstStream_jmhTest {\n\n    byte p000, p001, p002, p003, p004, p005, p006, p007, p008, p009, p010, p011, p012, p013, p014, p015;\n    byte p016, p017, p018, p019, p020, p021, p022, p023, p024, p025, p026, p027, p028, p029, p030, p031;\n    byte p032, p033, p034, p035, p036, p037, p038, p039, p040, p041, p042, p043, p044, p045, p046, p047;\n    byte p048, p049, p050, p051, p052, p053, p054, p055, p056, p057, p058, p059, p060, p061, p062, p063;\n    byte p064, p065, p066, p067, p068, p069, p070, p071, p072, p073, p074, p075, p076, p077, p078, p079;\n    byte p080, p081, p082, p083, p084, p085, p086, p087, p088, p089, p090, p091, p092, p093, p094, p095;\n    byte p096, p097, p098, p099, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111;\n    byte p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126, p127;\n    byte p128, p129, p130, p131, p132, p133, p134, p135, p136, p137, p138, p139, p140, p141, p142, p143;\n    byte p144, p145, p146, p147, p148, p149, p150, p151, p152, p153, p154, p155, p156, p157, p158, p159;\n    byte p160, p161, p162, p163, p164, p165, p166, p167, p168, p169, p170, p171, p172, p173, p174, p175;\n    byte p176, p177, p178, p179, p180, p181, p182, p183, p184, p185, p186, p187, p188, p189, p190, p191;\n    byte p192, p193, p194, p195, p196, p197, p198, p199, p200, p201, p202, p203, p204, p205, p206, p207;\n    byte p208, p209, p210, p211, p212, p213, p214, p215, p216, p217, p218, p219, p220, p221, p222, p223;\n    byte p224, p225, p226, p227, p228, p229, p230, p231, p232, p233, p234, p235, p236, p237, p238, p239;\n    byte p240, p241, p242, p243, p244, p245, p246, p247, p248, p249, p250, p251, p252, p253, p254, p255;\n    int startRndMask;\n    BenchmarkParams benchmarkParams;\n    IterationParams iterationParams;\n    ThreadParams threadParams;\n    Blackhole blackhole;\n    Control notifyControl;\n\n    public BenchmarkTaskResult matchFirstStream_Throughput(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchFirstStream_thrpt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new ThroughputResult(ResultRole.PRIMARY, \"matchFirstStream\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstStream_thrpt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstStream_AverageTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchFirstStream_avgt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new AverageTimeResult(ResultRole.PRIMARY, \"matchFirstStream\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstStream_avgt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstStream_SampleTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            int targetSamples = (int) (control.getDuration(TimeUnit.MILLISECONDS) * 20); // at max, 20 timestamps per millisecond\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            SampleBuffer buffer = new SampleBuffer();\n            matchFirstStream_sample_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, buffer, targetSamples, opsPerInv, batchSize, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps * batchSize;\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new SampleTimeResult(ResultRole.PRIMARY, \"matchFirstStream\", buffer, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstStream_sample_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, SampleBuffer buffer, int targetSamples, long opsPerInv, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        long operations = 0;\n        int rnd = (int)System.nanoTime();\n        int rndMask = startRndMask;\n        long time = 0;\n        int currentStride = 0;\n        do {\n            rnd = (rnd * 1664525 + 1013904223);\n            boolean sample = (rnd & rndMask) == 0;\n            if (sample) {\n                time = System.nanoTime();\n            }\n            for (int b = 0; b < batchSize; b++) {\n                if (control.volatileSpoiler) return;\n                l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n            }\n            if (sample) {\n                buffer.add((System.nanoTime() - time) / opsPerInv);\n                if (currentStride++ > targetSamples) {\n                    buffer.half();\n                    currentStride = 0;\n                    rndMask = (rndMask << 1) + 1;\n                }\n            }\n            operations++;\n        } while(!control.isDone);\n        startRndMask = Math.max(startRndMask, rndMask);\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchFirstStream_SingleShotTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            notifyControl.startMeasurement = true;\n            RawResults res = new RawResults();\n            int batchSize = iterationParams.getBatchSize();\n            matchFirstStream_ss_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, batchSize, l_pathmatcherbenchmark0_G);\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            int opsPerInv = control.benchmarkParams.getOpsPerInvocation();\n            long totalOps = opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult(totalOps, totalOps);\n            results.add(new SingleShotResult(ResultRole.PRIMARY, \"matchFirstStream\", res.getTime(), totalOps, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchFirstStream_ss_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        for (int b = 0; b < batchSize; b++) {\n            if (control.volatileSpoiler) return;\n            l_pathmatcherbenchmark0_G.matchFirstStream(blackhole);\n        }\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n    }\n\n    \n    static volatile PathMatcherBenchmark_jmhType f_pathmatcherbenchmark0_G;\n    \n    PathMatcherBenchmark_jmhType _jmh_tryInit_f_pathmatcherbenchmark0_G(InfraControl control) throws Throwable {\n        PathMatcherBenchmark_jmhType val = f_pathmatcherbenchmark0_G;\n        if (val != null) {\n            return val;\n        }\n        synchronized(this.getClass()) {\n            try {\n            if (control.isFailing) throw new FailureAssistException();\n            val = f_pathmatcherbenchmark0_G;\n            if (val != null) {\n                return val;\n            }\n            val = new PathMatcherBenchmark_jmhType();\n            val.setup();\n            val.readyTrial = true;\n            f_pathmatcherbenchmark0_G = val;\n            } catch (Throwable t) {\n                control.isFailing = true;\n                throw t;\n            }\n        }\n        return val;\n    }\n\n\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testing_SerializableObject/SerializableObject.java",
        "copies": "1",
        "content": "package io.javalin.testing;\n\nimport java.io.Serializable;\n\npublic class SerializableObject implements Serializable {\n    public String value1 = \"FirstValue\";\n    public String value2 = \"SecondValue\";\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/performance_PathMatcherBenchmark/PathMatcherBenchmark.java",
        "copies": "1",
        "content": "package io.javalin.performance;\n\nimport io.javalin.config.JavalinConfig;\nimport io.javalin.config.RouterConfig;\nimport static io.javalin.http.HandlerType.GET;\n\nimport io.javalin.http.HandlerType;\nimport io.javalin.router.Endpoint;\nimport io.javalin.router.ParsedEndpoint;\nimport io.javalin.router.matcher.PathMatcher;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.Setup;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.infra.Blackhole;\nimport org.openjdk.jmh.runner.Runner;\nimport org.openjdk.jmh.runner.options.OptionsBuilder;\nimport java.util.ArrayList;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n@State(Scope.Benchmark)\n@Fork(value = 1)\n@Warmup(iterations = 2)\n@Measurement(iterations = 2)\n@SuppressWarnings({ \"OptionalGetWithoutIsPresent\" })\npublic class PathMatcherBenchmark {\n\n    public static void main(String[] args) throws Exception {\n        var opt = new OptionsBuilder()\n            .include(PathMatcherBenchmark.class.getName())\n            .build();\n        new Runner(opt).run();\n    }\n\n    private OldPathMatcher oldPathMatcher;\n    private PathMatcher pathMatcher;\n\n    @Setup\n    public void setup() {\n        this.oldPathMatcher = new OldPathMatcher();\n        this.pathMatcher = new PathMatcher();\n        var routingConfig = new RouterConfig(new JavalinConfig());\n        for (int i = 0; i < 50; i++) {\n            this.pathMatcher.add(new ParsedEndpoint(new Endpoint(GET, \"/hello\" + i, (ctx) -> {}), routingConfig));\n            this.oldPathMatcher.add(new ParsedEndpoint(new Endpoint(GET, \"/hello\" + i, (ctx) -> {}), routingConfig));\n        }\n    }\n\n    @Benchmark\n    public void matchFirstStream(Blackhole blackhole) {\n        blackhole.consume(pathMatcher.findEntries(GET, \"/hello0\").findFirst().get());\n    }\n\n    @Benchmark\n    public void matchLastStream(Blackhole blackhole) {\n        blackhole.consume(pathMatcher.findEntries(GET, \"/hello49\").findFirst().get());\n    }\n\n    @Benchmark\n    public void matchFirstList(Blackhole blackhole) {\n        blackhole.consume(oldPathMatcher.findEntries(GET, \"/hello0\").iterator().next());\n    }\n\n    @Benchmark\n    public void matchLastList(Blackhole blackhole) {\n        blackhole.consume(oldPathMatcher.findEntries(GET, \"/hello49\").iterator().next());\n    }\n\n}\n\nfinal class OldPathMatcher {\n    @SuppressWarnings(\"Convert2Diamond\")\n    private final EnumMap<HandlerType, ArrayList<ParsedEndpoint>> handlerEntries = new EnumMap<HandlerType, ArrayList<ParsedEndpoint>>(\n        HandlerType.getEntries().stream().collect(Collectors.toMap((handler) -> handler, (handler) -> new ArrayList<>()))\n    );\n\n    public void add(ParsedEndpoint entry) {\n        handlerEntries.get(entry.getEndpoint().getMethod()).add(entry);\n    }\n\n    public List<ParsedEndpoint> findEntries(HandlerType handlerType, String requestUri) {\n        var results = new ArrayList<ParsedEndpoint>();\n        handlerEntries.get(handlerType).forEach(entry -> {\n            if (match(entry, requestUri)) {\n                results.add(entry);\n            }\n        });\n        return results;\n    }\n\n    private boolean match(ParsedEndpoint entry, String requestPath) {\n        if (entry.getEndpoint().getPath().equals(\"*\")) return true;\n        if (entry.getEndpoint().getPath().equals(requestPath)) return true;\n        return entry.matches(requestPath);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_matchLastList_jmhTest/PathMatcherBenchmark_matchLastList_jmhTest.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.concurrent.TimeUnit;\nimport org.openjdk.jmh.annotations.CompilerControl;\nimport org.openjdk.jmh.runner.InfraControl;\nimport org.openjdk.jmh.infra.ThreadParams;\nimport org.openjdk.jmh.results.BenchmarkTaskResult;\nimport org.openjdk.jmh.results.Result;\nimport org.openjdk.jmh.results.ThroughputResult;\nimport org.openjdk.jmh.results.AverageTimeResult;\nimport org.openjdk.jmh.results.SampleTimeResult;\nimport org.openjdk.jmh.results.SingleShotResult;\nimport org.openjdk.jmh.util.SampleBuffer;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Threads;\nimport org.openjdk.jmh.annotations.Warmup;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.results.RawResults;\nimport org.openjdk.jmh.results.ResultRole;\nimport java.lang.reflect.Field;\nimport org.openjdk.jmh.infra.BenchmarkParams;\nimport org.openjdk.jmh.infra.IterationParams;\nimport org.openjdk.jmh.infra.Blackhole;\nimport org.openjdk.jmh.infra.Control;\nimport org.openjdk.jmh.results.ScalarResult;\nimport org.openjdk.jmh.results.AggregationPolicy;\nimport org.openjdk.jmh.runner.FailureAssistException;\n\nimport io.javalin.performance.jmh_generated.PathMatcherBenchmark_jmhType;\npublic final class PathMatcherBenchmark_matchLastList_jmhTest {\n\n    byte p000, p001, p002, p003, p004, p005, p006, p007, p008, p009, p010, p011, p012, p013, p014, p015;\n    byte p016, p017, p018, p019, p020, p021, p022, p023, p024, p025, p026, p027, p028, p029, p030, p031;\n    byte p032, p033, p034, p035, p036, p037, p038, p039, p040, p041, p042, p043, p044, p045, p046, p047;\n    byte p048, p049, p050, p051, p052, p053, p054, p055, p056, p057, p058, p059, p060, p061, p062, p063;\n    byte p064, p065, p066, p067, p068, p069, p070, p071, p072, p073, p074, p075, p076, p077, p078, p079;\n    byte p080, p081, p082, p083, p084, p085, p086, p087, p088, p089, p090, p091, p092, p093, p094, p095;\n    byte p096, p097, p098, p099, p100, p101, p102, p103, p104, p105, p106, p107, p108, p109, p110, p111;\n    byte p112, p113, p114, p115, p116, p117, p118, p119, p120, p121, p122, p123, p124, p125, p126, p127;\n    byte p128, p129, p130, p131, p132, p133, p134, p135, p136, p137, p138, p139, p140, p141, p142, p143;\n    byte p144, p145, p146, p147, p148, p149, p150, p151, p152, p153, p154, p155, p156, p157, p158, p159;\n    byte p160, p161, p162, p163, p164, p165, p166, p167, p168, p169, p170, p171, p172, p173, p174, p175;\n    byte p176, p177, p178, p179, p180, p181, p182, p183, p184, p185, p186, p187, p188, p189, p190, p191;\n    byte p192, p193, p194, p195, p196, p197, p198, p199, p200, p201, p202, p203, p204, p205, p206, p207;\n    byte p208, p209, p210, p211, p212, p213, p214, p215, p216, p217, p218, p219, p220, p221, p222, p223;\n    byte p224, p225, p226, p227, p228, p229, p230, p231, p232, p233, p234, p235, p236, p237, p238, p239;\n    byte p240, p241, p242, p243, p244, p245, p246, p247, p248, p249, p250, p251, p252, p253, p254, p255;\n    int startRndMask;\n    BenchmarkParams benchmarkParams;\n    IterationParams iterationParams;\n    ThreadParams threadParams;\n    Blackhole blackhole;\n    Control notifyControl;\n\n    public BenchmarkTaskResult matchLastList_Throughput(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchLastList_thrpt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new ThroughputResult(ResultRole.PRIMARY, \"matchLastList\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastList_thrpt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastList_AverageTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            matchLastList_avgt_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps;\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            res.measuredOps /= batchSize;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new AverageTimeResult(ResultRole.PRIMARY, \"matchLastList\", res.measuredOps, res.getTime(), benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastList_avgt_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long operations = 0;\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        do {\n            l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n            operations++;\n        } while(!control.isDone);\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastList_SampleTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            RawResults res = new RawResults();\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            control.announceWarmupReady();\n            while (control.warmupShouldWait) {\n                l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                if (control.shouldYield) Thread.yield();\n                res.allOps++;\n            }\n\n            notifyControl.startMeasurement = true;\n            int targetSamples = (int) (control.getDuration(TimeUnit.MILLISECONDS) * 20); // at max, 20 timestamps per millisecond\n            int batchSize = iterationParams.getBatchSize();\n            int opsPerInv = benchmarkParams.getOpsPerInvocation();\n            SampleBuffer buffer = new SampleBuffer();\n            matchLastList_sample_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, buffer, targetSamples, opsPerInv, batchSize, l_pathmatcherbenchmark0_G);\n            notifyControl.stopMeasurement = true;\n            control.announceWarmdownReady();\n            try {\n                while (control.warmdownShouldWait) {\n                    l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n                    if (control.shouldYield) Thread.yield();\n                    res.allOps++;\n                }\n            } catch (Throwable e) {\n                if (!(e instanceof InterruptedException)) throw e;\n            }\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            res.allOps += res.measuredOps * batchSize;\n            res.allOps *= opsPerInv;\n            res.allOps /= batchSize;\n            res.measuredOps *= opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult((long)res.allOps, (long)res.measuredOps);\n            results.add(new SampleTimeResult(ResultRole.PRIMARY, \"matchLastList\", buffer, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastList_sample_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, SampleBuffer buffer, int targetSamples, long opsPerInv, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        long operations = 0;\n        int rnd = (int)System.nanoTime();\n        int rndMask = startRndMask;\n        long time = 0;\n        int currentStride = 0;\n        do {\n            rnd = (rnd * 1664525 + 1013904223);\n            boolean sample = (rnd & rndMask) == 0;\n            if (sample) {\n                time = System.nanoTime();\n            }\n            for (int b = 0; b < batchSize; b++) {\n                if (control.volatileSpoiler) return;\n                l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n            }\n            if (sample) {\n                buffer.add((System.nanoTime() - time) / opsPerInv);\n                if (currentStride++ > targetSamples) {\n                    buffer.half();\n                    currentStride = 0;\n                    rndMask = (rndMask << 1) + 1;\n                }\n            }\n            operations++;\n        } while(!control.isDone);\n        startRndMask = Math.max(startRndMask, rndMask);\n        result.realTime = realTime;\n        result.measuredOps = operations;\n    }\n\n\n    public BenchmarkTaskResult matchLastList_SingleShotTime(InfraControl control, ThreadParams threadParams) throws Throwable {\n        this.benchmarkParams = control.benchmarkParams;\n        this.iterationParams = control.iterationParams;\n        this.threadParams    = threadParams;\n        this.notifyControl   = control.notifyControl;\n        if (this.blackhole == null) {\n            this.blackhole = new Blackhole(\"Today's password is swordfish. I understand instantiating Blackholes directly is dangerous.\");\n        }\n        if (threadParams.getSubgroupIndex() == 0) {\n            PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G = _jmh_tryInit_f_pathmatcherbenchmark0_G(control);\n\n            control.preSetup();\n\n\n            notifyControl.startMeasurement = true;\n            RawResults res = new RawResults();\n            int batchSize = iterationParams.getBatchSize();\n            matchLastList_ss_jmhStub(control, res, benchmarkParams, iterationParams, threadParams, blackhole, notifyControl, startRndMask, batchSize, l_pathmatcherbenchmark0_G);\n            control.preTearDown();\n\n            if (control.isLastIteration()) {\n                if (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.compareAndSet(l_pathmatcherbenchmark0_G, 0, 1)) {\n                    try {\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (l_pathmatcherbenchmark0_G.readyTrial) {\n                            l_pathmatcherbenchmark0_G.readyTrial = false;\n                        }\n                    } catch (Throwable t) {\n                        control.isFailing = true;\n                        throw t;\n                    } finally {\n                        PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.set(l_pathmatcherbenchmark0_G, 0);\n                    }\n                } else {\n                    long l_pathmatcherbenchmark0_G_backoff = 1;\n                    while (PathMatcherBenchmark_jmhType.tearTrialMutexUpdater.get(l_pathmatcherbenchmark0_G) == 1) {\n                        TimeUnit.MILLISECONDS.sleep(l_pathmatcherbenchmark0_G_backoff);\n                        l_pathmatcherbenchmark0_G_backoff = Math.max(1024, l_pathmatcherbenchmark0_G_backoff * 2);\n                        if (control.isFailing) throw new FailureAssistException();\n                        if (Thread.interrupted()) throw new InterruptedException();\n                    }\n                }\n                synchronized(this.getClass()) {\n                    f_pathmatcherbenchmark0_G = null;\n                }\n            }\n            int opsPerInv = control.benchmarkParams.getOpsPerInvocation();\n            long totalOps = opsPerInv;\n            BenchmarkTaskResult results = new BenchmarkTaskResult(totalOps, totalOps);\n            results.add(new SingleShotResult(ResultRole.PRIMARY, \"matchLastList\", res.getTime(), totalOps, benchmarkParams.getTimeUnit()));\n            this.blackhole.evaporate(\"Yes, I am Stephen Hawking, and know a thing or two about black holes.\");\n            return results;\n        } else\n            throw new IllegalStateException(\"Harness failed to distribute threads among groups properly\");\n    }\n\n    public static void matchLastList_ss_jmhStub(InfraControl control, RawResults result, BenchmarkParams benchmarkParams, IterationParams iterationParams, ThreadParams threadParams, Blackhole blackhole, Control notifyControl, int startRndMask, int batchSize, PathMatcherBenchmark_jmhType l_pathmatcherbenchmark0_G) throws Throwable {\n        long realTime = 0;\n        result.startTime = System.nanoTime();\n        for (int b = 0; b < batchSize; b++) {\n            if (control.volatileSpoiler) return;\n            l_pathmatcherbenchmark0_G.matchLastList(blackhole);\n        }\n        result.stopTime = System.nanoTime();\n        result.realTime = realTime;\n    }\n\n    \n    static volatile PathMatcherBenchmark_jmhType f_pathmatcherbenchmark0_G;\n    \n    PathMatcherBenchmark_jmhType _jmh_tryInit_f_pathmatcherbenchmark0_G(InfraControl control) throws Throwable {\n        PathMatcherBenchmark_jmhType val = f_pathmatcherbenchmark0_G;\n        if (val != null) {\n            return val;\n        }\n        synchronized(this.getClass()) {\n            try {\n            if (control.isFailing) throw new FailureAssistException();\n            val = f_pathmatcherbenchmark0_G;\n            if (val != null) {\n                return val;\n            }\n            val = new PathMatcherBenchmark_jmhType();\n            val.setup();\n            val.readyTrial = true;\n            f_pathmatcherbenchmark0_G = val;\n            } catch (Throwable t) {\n                control.isFailing = true;\n                throw t;\n            }\n        }\n        return val;\n    }\n\n\n}\n\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldPlugin/HelloWorldPlugin.java",
        "copies": "1",
        "content": "package io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.Context;\nimport io.javalin.http.TooManyRequestsResponse;\nimport io.javalin.plugin.ContextPlugin;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Consumer;\n\npublic class HelloWorldPlugin {\n    public static void main(String[] args) {\n        var app = Javalin.create(config -> {\n            config.registerPlugin(new JRate(it -> it.limit = 1)); // register plugin with config\n        });\n        app.get(\"/\", ctx -> {\n            ctx.with(JRate.class).tryConsume(2);\n            ctx.result(\"Hello World\");\n        });\n        app.start(7070);\n    }\n}\n\n// this class demonstrates the most advanced use case of a plugin,\n// where the plugin has a config and a plugin extension\n// we recommend using inner classes for plugins, as it keeps the whole plugin in one place\nclass JRate extends ContextPlugin<JRate.Config, JRate.Extension> {\n    public JRate(Consumer<Config> userConfig) {\n        super(userConfig, new Config());\n    }\n    Map<String, Integer> ipToCounter = new HashMap<>();\n    @Override\n    public Extension createExtension(@NotNull Context context) {\n        return new Extension(context);\n    }\n    public static class Config {\n        public int limit = 1;\n    }\n    public class Extension {\n        private final Context context;\n        public Extension(Context context) {\n            this.context = context;\n        }\n        public void tryConsume(int cost) {\n            String ip = context.ip();\n            int counter = ipToCounter.compute(ip, (k, v) -> v == null ? cost : v + cost);\n            if (counter > pluginConfig.limit) {\n                throw new TooManyRequestsResponse();\n            }\n        }\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_jmhType_B1/PathMatcherBenchmark_jmhType_B1.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\nimport io.javalin.performance.PathMatcherBenchmark;\npublic class PathMatcherBenchmark_jmhType_B1 extends io.javalin.performance.PathMatcherBenchmark {\n    byte b1_000, b1_001, b1_002, b1_003, b1_004, b1_005, b1_006, b1_007, b1_008, b1_009, b1_010, b1_011, b1_012, b1_013, b1_014, b1_015;\n    byte b1_016, b1_017, b1_018, b1_019, b1_020, b1_021, b1_022, b1_023, b1_024, b1_025, b1_026, b1_027, b1_028, b1_029, b1_030, b1_031;\n    byte b1_032, b1_033, b1_034, b1_035, b1_036, b1_037, b1_038, b1_039, b1_040, b1_041, b1_042, b1_043, b1_044, b1_045, b1_046, b1_047;\n    byte b1_048, b1_049, b1_050, b1_051, b1_052, b1_053, b1_054, b1_055, b1_056, b1_057, b1_058, b1_059, b1_060, b1_061, b1_062, b1_063;\n    byte b1_064, b1_065, b1_066, b1_067, b1_068, b1_069, b1_070, b1_071, b1_072, b1_073, b1_074, b1_075, b1_076, b1_077, b1_078, b1_079;\n    byte b1_080, b1_081, b1_082, b1_083, b1_084, b1_085, b1_086, b1_087, b1_088, b1_089, b1_090, b1_091, b1_092, b1_093, b1_094, b1_095;\n    byte b1_096, b1_097, b1_098, b1_099, b1_100, b1_101, b1_102, b1_103, b1_104, b1_105, b1_106, b1_107, b1_108, b1_109, b1_110, b1_111;\n    byte b1_112, b1_113, b1_114, b1_115, b1_116, b1_117, b1_118, b1_119, b1_120, b1_121, b1_122, b1_123, b1_124, b1_125, b1_126, b1_127;\n    byte b1_128, b1_129, b1_130, b1_131, b1_132, b1_133, b1_134, b1_135, b1_136, b1_137, b1_138, b1_139, b1_140, b1_141, b1_142, b1_143;\n    byte b1_144, b1_145, b1_146, b1_147, b1_148, b1_149, b1_150, b1_151, b1_152, b1_153, b1_154, b1_155, b1_156, b1_157, b1_158, b1_159;\n    byte b1_160, b1_161, b1_162, b1_163, b1_164, b1_165, b1_166, b1_167, b1_168, b1_169, b1_170, b1_171, b1_172, b1_173, b1_174, b1_175;\n    byte b1_176, b1_177, b1_178, b1_179, b1_180, b1_181, b1_182, b1_183, b1_184, b1_185, b1_186, b1_187, b1_188, b1_189, b1_190, b1_191;\n    byte b1_192, b1_193, b1_194, b1_195, b1_196, b1_197, b1_198, b1_199, b1_200, b1_201, b1_202, b1_203, b1_204, b1_205, b1_206, b1_207;\n    byte b1_208, b1_209, b1_210, b1_211, b1_212, b1_213, b1_214, b1_215, b1_216, b1_217, b1_218, b1_219, b1_220, b1_221, b1_222, b1_223;\n    byte b1_224, b1_225, b1_226, b1_227, b1_228, b1_229, b1_230, b1_231, b1_232, b1_233, b1_234, b1_235, b1_236, b1_237, b1_238, b1_239;\n    byte b1_240, b1_241, b1_242, b1_243, b1_244, b1_245, b1_246, b1_247, b1_248, b1_249, b1_250, b1_251, b1_252, b1_253, b1_254, b1_255;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/testtools_JavaApp/JavaApp.java",
        "copies": "1",
        "content": "package io.javalin.testtools;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.Context;\n\nimport static io.javalin.apibuilder.ApiBuilder.get;\n\n// We're using statics for simplicity's sake, but you could\n// make it non static and do dependency injection or whatever\npublic class JavaApp {\n\n    public Javalin app = Javalin.create(javalin -> {\n        javalin.router.ignoreTrailingSlashes = false;\n        javalin.router.apiBuilder(() -> {\n            get(\"/hello\", HelloController::hello);\n        });\n    });\n\n    static class HelloController {\n        public static void hello(Context ctx) {\n            ctx.result(\"Hello, app!\");\n        }\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorld/HelloWorld.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n *\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        var app = Javalin.create(/*config*/)\n            .get(\"/\", ctx -> ctx.result(\"Hello World\"))\n            .start(7070);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/routeoverview_TestRouteOverviewInJava/TestRouteOverviewInJava.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.routeoverview;\n\nimport io.javalin.http.Context;\nimport io.javalin.http.Handler;\nimport io.javalin.plugin.bundled.RouteOverviewUtil;\nimport io.javalin.routeoverview.VisualTest.HandlerImplementation;\nimport org.jetbrains.annotations.NotNull;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n\npublic class TestRouteOverviewInJava {\n\n    private static final Handler lambdaField = ctx -> {};\n\n    @Test\n    public void field_works() {\n        assertThat(RouteOverviewUtil.getMetaInfo(lambdaField)).isEqualTo(\"io.javalin.routeoverview.TestRouteOverviewInJava.lambdaField\");\n    }\n\n    @Test\n    public void class_works() {\n        assertThat(RouteOverviewUtil.getMetaInfo(new InnerHandlerImplementation())).isEqualTo(\"io.javalin.routeoverview.TestRouteOverviewInJava$InnerHandlerImplementation.class\");\n        assertThat(RouteOverviewUtil.getMetaInfo(new HandlerImplementation())).isEqualTo(\"io.javalin.routeoverview.VisualTest$HandlerImplementation.class\");\n    }\n\n    @Test\n    public void lambda_works() {\n        assertThat(RouteOverviewUtil.getMetaInfo((Handler) (ctx -> ctx.result(\"\")))).isEqualTo(\"io.javalin.routeoverview.TestRouteOverviewInJava::??? (anonymous lambda)\");\n    }\n\n    private static class InnerHandlerImplementation implements Handler {\n        @Override\n        public void handle(@NotNull Context context) {}\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldStaticFiles_linked/HelloWorldStaticFiles_linked.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\nimport io.javalin.http.staticfiles.Location;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport org.eclipse.jetty.server.handler.ContextHandler;\n\npublic class HelloWorldStaticFiles_linked {\n\n    public static void main(String[] args) {\n        createSymLink(\"src/test/external/html.html\", \"src/test/external/linked_html.html\");\n\n        Javalin.create(javalin -> {\n            javalin.staticFiles.add(staticFiles -> {\n                staticFiles.directory = \"src/test/external/\";\n                staticFiles.location = Location.EXTERNAL;\n                staticFiles.aliasCheck = new ContextHandler.ApproveAliases();\n            });\n        }).start(7070);\n    }\n\n    private static void createSymLink(String targetPath, String linkPath) {\n        Path target = Paths.get(targetPath).toAbsolutePath();\n        Path link = Paths.get(linkPath).toAbsolutePath();\n        try {\n            Files.createSymbolicLink(link, target);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/javalinvue_TestJavalinVueResolution/TestJavalinVueResolution.java",
        "copies": "1",
        "content": "/*\n * Copyright 2020 tareq.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.javalin.javalinvue;\n\nimport io.javalin.vue.VueComponent;\nimport org.junit.jupiter.api.Test;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author tareq\n */\npublic class TestJavalinVueResolution {\n\n    @Test\n    public void resoleAllDependenciesTest() {\n        VueTestUtil.test(config -> {\n            config.vue.optimizeDependencies = false;\n        }, (server, httpUtil) -> {\n            server.get(\"/non-optimized\", new VueComponent(\"<test-component></test-component>\"));\n            String body = httpUtil.getBody(\"/non-optimized\");\n            assertThat(body).contains(\"<body><test-component></test-component></body>\");\n            assertThat(body).contains(\"view-one\");\n            assertThat(body).contains(\"view-two\");\n            assertThat(body).contains(\"view-three\");\n            assertThat(body).contains(\"dependency-one\");\n            assertThat(body).contains(\"dependency-two\");\n            assertThat(body).contains(\"dependency-three\");\n            assertThat(body).contains(\"dependency-four\");\n            assertThat(body).contains(\"nested-dependency\");\n            assertThat(body).contains(\"view-nested-dependency\");\n            assertThat(body).contains(\"multi-dependency\");\n        });\n    }\n\n    @Test\n    public void resolveSingleDependencyTest() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/single-view\", new VueComponent(\"<view-one></view-one>\"));\n            String body = httpUtil.getBody(\"/single-view\");\n            assertThat(body).contains(\"<body><view-one></view-one></body>\");\n            assertThat(body).doesNotContain(\"<view-two>\");\n            assertThat(body).doesNotContain(\"<view-three>\");\n            assertThat(body).doesNotContain(\"<view-nested-dependency>\");\n            assertThat(body).contains(\"dependency-one\");\n            assertThat(body).doesNotContain(\"dependency-two\");\n            assertThat(body).doesNotContain(\"dependency-three\");\n            assertThat(body).doesNotContain(\"dependency-four\");\n            assertThat(body).doesNotContain(\"nested-dependency\");\n        });\n    }\n\n    @Test\n    public void resolveVue3DependencyTest() {\n        VueTestUtil.test(config -> {\n            config.vue.vueInstanceNameInJs = \"app\";\n        }, (server, httpUtil) -> {\n            server.get(\"/single-view\", new VueComponent(\"<view-one-3></view-one-3>\"));\n            String body = httpUtil.getBody(\"/single-view\");\n            assertThat(body).contains(\"<body><view-one-3></view-one-3></body>\");\n            assertThat(body).doesNotContain(\"<view-two-3>\");\n            assertThat(body).doesNotContain(\"<view-three-3>\");\n            assertThat(body).doesNotContain(\"<view-nested-dependency-3>\");\n            assertThat(body).doesNotContain(\"<view-two>\");\n            assertThat(body).doesNotContain(\"<view-three>\");\n            assertThat(body).doesNotContain(\"<view-nested-dependency>\");\n            assertThat(body).contains(\"dependency-one\");\n            assertThat(body).contains(\"dependency-one-3\");\n            assertThat(body).doesNotContain(\"dependency-two\");\n            assertThat(body).doesNotContain(\"dependency-three\");\n            assertThat(body).doesNotContain(\"dependency-four\");\n            assertThat(body).doesNotContain(\"nested-dependency\");\n            assertThat(body).doesNotContain(\"dependency-two-3\");\n            assertThat(body).doesNotContain(\"dependency-three\");\n            assertThat(body).doesNotContain(\"dependency-four\");\n            assertThat(body).doesNotContain(\"nested-dependency\");\n            assertThat(body).doesNotContain(\"Vue.component\");\n            assertThat(body).contains(\"app.component\");\n        });\n    }\n\n    @Test\n    public void resolveNestedDependencyTest() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/nested-view\", new VueComponent(\"<view-nested-dependency></view-nested-dependency>\"));\n            String body = httpUtil.getBody(\"/nested-view\");\n            assertThat(body).doesNotContain(\"<view-one>\");\n            assertThat(body).doesNotContain(\"<view-two>\");\n            assertThat(body).doesNotContain(\"<view-three>\");\n            assertThat(body).contains(\"<body><view-nested-dependency></view-nested-dependency></body>\");\n            assertThat(body).contains(\"dependency-one\");\n            assertThat(body).contains(\"dependency-two\");\n            assertThat(body).doesNotContain(\"dependency-three\");\n            assertThat(body).doesNotContain(\"dependency-four\");\n            assertThat(body).contains(\"nested-dependency\");\n        });\n    }\n\n    @Test\n    public void resolveMultiComponentFileDependencyTest() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/multi-view-one\", new VueComponent(\"<view-two></view-two>\"));\n            String body = httpUtil.getBody(\"/multi-view-one\");\n            assertThat(body).doesNotContain(\"<view-one>\");\n            assertThat(body).contains(\"<body><view-two></view-two></body>\");\n            assertThat(body).doesNotContain(\"<view-three>\");\n            assertThat(body).doesNotContain(\"<view-nested-dependency>\");\n            assertThat(body).doesNotContain(\"dependency-one\");\n            assertThat(body).doesNotContain(\"dependency-two\");\n            assertThat(body).contains(\"dependency-three\");\n            assertThat(body).contains(\"dependency-four\");\n            assertThat(body).doesNotContain(\"nested-dependency\");\n\n            server.get(\"/multi-view-two\", new VueComponent(\"<view-three></view-three>\"));\n            body = httpUtil.getBody(\"/multi-view-two\");\n            assertThat(body).doesNotContain(\"<view-one>\");\n            assertThat(body).doesNotContain(\"<view-two>\");\n            assertThat(body).contains(\"<body><view-three></view-three></body>\");\n            assertThat(body).doesNotContain(\"<view-nested-dependency>\");\n            assertThat(body).doesNotContain(\"dependency-one\");\n            assertThat(body).doesNotContain(\"dependency-two\");\n            assertThat(body).contains(\"dependency-three\");\n            assertThat(body).contains(\"dependency-four\");\n            assertThat(body).doesNotContain(\"nested-dependency\");\n        });\n    }\n\n    @Test\n    public void componentWithNumberTest() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/multi-view-number\", new VueComponent(\"<view-number-dependency></view-number-dependency>\"));\n            String body = httpUtil.getBody(\"/multi-view-number\");\n            assertThat(body).contains(\"<dependency-1></dependency-1>\");\n            assertThat(body).contains(\"<dependency-1-foo></dependency-1-foo>\");\n            assertThat(body).contains(\"Vue.component(\\\"view-number-dependency\\\",{template:\\\"#view-number-dependency\\\"})\");\n            assertThat(body).contains(\"Vue.component('dependency-1',{template:\\\"#dependency-1\\\"})\");\n            assertThat(body).contains(\"Vue.component('dependency-1-foo',{template:\\\"#dependency-1-foo\\\"})\");\n            assertThat(body).doesNotContain(\"Vue.component('dependency-123',{template:\\\"#dependency-123\\\"})\");\n            assertThat(body).doesNotContain(\"<dependency-123\");\n        });\n    }\n\n    @Test\n    public void componentWithMultilineComponentsUsageTest() {\n        VueTestUtil.test((server, httpUtil) -> {\n            server.get(\"/multiline-view-number\", new VueComponent(\"<view-multiline-dependency></view-multiline-dependency>\"));\n            String body = httpUtil.getBody(\"/multiline-view-number\");\n            assertThat(body).contains(\"Vue.component(\\\"view-multiline-dependency\\\",{template:\\\"#view-multiline-dependency\\\"})\");\n            assertThat(body).contains(\"Vue.component('dependency-1',{template:\\\"#dependency-1\\\"})\");\n            assertThat(body).contains(\"Vue.component('dependency-1-foo',{template:\\\"#dependency-1-foo\\\"})\");\n            assertThat(body).contains(\"Vue.component('dependency-one',{template:\\\"#dependency-one\\\"})\");\n            assertThat(body).doesNotContain(\"Vue.component('dependency-123',{template:\\\"#dependency-123\\\"})\");\n            assertThat(body).doesNotContain(\"<dependency-123\");\n        });\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldWebSockets/HelloWorldWebSockets.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\n\n// WebSockets also work with ssl,\n// see HelloWorldSecure for how to set that up\npublic class HelloWorldWebSockets {\n    public static void main(String[] args) {\n        Javalin app = Javalin.create(cfg -> cfg.bundledPlugins.enableDevLogging());\n        app.ws(\"/websocket\", ws -> {\n            ws.onConnect(ctx -> {\n                System.out.println(\"Connected\");\n                ctx.send(\"[MESSAGE FROM SERVER] Connection established\");\n            });\n            ws.onMessage(ctx -> {\n                System.out.println(\"Received: \" + ctx.message());\n                ctx.send(\"[MESSAGE FROM SERVER] Echo: \" + ctx.message());\n            });\n            ws.onClose(ctx -> {\n                System.out.println(\"Closed\");\n            });\n            ws.onError(ctx -> {\n                System.out.println(\"Errored\");\n            });\n        });\n        app.get(\"/\", ctx -> {\n            ctx.html(\"<h1>WebSocket example</h1>\\n\" +\n                \"<script>\\n\" +\n                \"   let ws = new WebSocket(\\\"ws://localhost:7070/websocket\\\");\\n\" +\n                \"   ws.onmessage = e => document.body.insertAdjacentHTML(\\\"beforeEnd\\\", \\\"<pre>\\\" + e.data + \\\"</pre>\\\");\\n\" +\n                \"   ws.onclose = () => alert(\\\"WebSocket connection closed\\\");\\n\" +\n                \"   setInterval(() => ws.send(\\\"Repeating request every 2 seconds\\\"), 2000);\\n\" +\n                \"</script>\");\n        });\n        app.start(7070);\n    }\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/jmh_generated_PathMatcherBenchmark_jmhType_B2/PathMatcherBenchmark_jmhType_B2.java",
        "copies": "1",
        "content": "package io.javalin.performance.jmh_generated;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\npublic class PathMatcherBenchmark_jmhType_B2 extends PathMatcherBenchmark_jmhType_B1 {\n    public volatile int setupTrialMutex;\n    public volatile int tearTrialMutex;\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> setupTrialMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"setupTrialMutex\");\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> tearTrialMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"tearTrialMutex\");\n\n    public volatile int setupIterationMutex;\n    public volatile int tearIterationMutex;\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> setupIterationMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"setupIterationMutex\");\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> tearIterationMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"tearIterationMutex\");\n\n    public volatile int setupInvocationMutex;\n    public volatile int tearInvocationMutex;\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> setupInvocationMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"setupInvocationMutex\");\n    public final static AtomicIntegerFieldUpdater<PathMatcherBenchmark_jmhType_B2> tearInvocationMutexUpdater = AtomicIntegerFieldUpdater.newUpdater(PathMatcherBenchmark_jmhType_B2.class, \"tearInvocationMutex\");\n\n    public volatile boolean readyTrial;\n    public volatile boolean readyIteration;\n    public volatile boolean readyInvocation;\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/routeoverview_VisualTest/VisualTest.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.routeoverview;\n\nimport io.javalin.Javalin;\nimport io.javalin.apibuilder.CrudHandler;\nimport io.javalin.http.Context;\nimport io.javalin.http.Handler;\nimport io.javalin.http.HandlerType;\nimport io.javalin.plugin.bundled.CorsPlugin;\nimport io.javalin.plugin.bundled.RouteOverviewPlugin;\nimport io.javalin.websocket.WsConfig;\nimport org.jetbrains.annotations.NotNull;\n\nimport static io.javalin.TestAccessManager.MyRole.ROLE_ONE;\nimport static io.javalin.TestAccessManager.MyRole.ROLE_THREE;\nimport static io.javalin.TestAccessManager.MyRole.ROLE_TWO;\nimport static io.javalin.apibuilder.ApiBuilder.crud;\nimport static io.javalin.apibuilder.ApiBuilder.delete;\nimport static io.javalin.apibuilder.ApiBuilder.get;\nimport static io.javalin.apibuilder.ApiBuilder.patch;\nimport static io.javalin.apibuilder.ApiBuilder.path;\nimport static io.javalin.apibuilder.ApiBuilder.post;\n\npublic class VisualTest {\n\n    private static final Handler lambdaField = ctx -> {};\n\n    public static void main(String[] args) {\n        Javalin app = Javalin.create((config) -> {\n            config.router.contextPath = \"/context-path\";\n            config.registerPlugin(new CorsPlugin(cors -> cors.addRule(corsConfig -> corsConfig.reflectClientOrigin = true)));\n            config.registerPlugin(new RouteOverviewPlugin(cfg -> cfg.path = \"/route-overview\"));\n        }).start();\n        setupJavalinRoutes(app);\n    }\n\n    static void setupJavalinRoutes(Javalin app) {\n        app.get(\"/\", ctx -> ctx.redirect(\"/context-path/route-overview\"))\n            .get(\"/just-some-path\", new HandlerImplementation())\n            .post(\"/test/{hmm}/\", VisualTest::methodReference)\n            .put(\"/user/*\", ctx -> ctx.result(\"\"), ROLE_ONE)\n            .get(\"/nonsense-paths/{test}\", VisualTest.lambdaField, ROLE_ONE, ROLE_THREE)\n            .delete(\"/just-words\", VisualTest::methodReference, ROLE_ONE, ROLE_TWO)\n            .before(\"*\", VisualTest.lambdaField)\n            .after(\"*\", VisualTest.lambdaField)\n            .head(\"/check/the/head\", VisualTest::methodReference)\n            .get(\"/{path1}/{path2}\", VisualTest.lambdaField)\n            .post(\"/user/create\", VisualTest::methodReference, ROLE_ONE, ROLE_TWO)\n            .put(\"/user/{user-id}\", VisualTest.lambdaField)\n            .patch(\"/patchy-mcpatchface\", new ImplementingClass(), ROLE_ONE, ROLE_TWO)\n            .delete(\"/users/{user-id}\", new HandlerImplementation())\n            .options(\"/what/{are}/*/my-options\", new HandlerImplementation())\n            .options(\"/what/{are}/*/my-options2\", new HandlerImplementation(), ROLE_ONE, ROLE_TWO)\n            .wsBefore(VisualTest::wsMethodRef)\n            .ws(\"/websocket\", VisualTest::wsMethodRef)\n            .wsAfter(\"/my-path\", VisualTest::wsMethodRef)\n            .addHttpHandler(HandlerType.CONNECT, \"/test\", VisualTest.lambdaField)\n            .addHttpHandler(HandlerType.TRACE, \"/tracer\", new HandlerImplementation())\n            .addHttpHandler(HandlerType.CONNECT, \"/test2\", VisualTest.lambdaField, ROLE_ONE, ROLE_TWO)\n            .addHttpHandler(HandlerType.TRACE, \"/tracer2\", new HandlerImplementation(), ROLE_ONE, ROLE_TWO)\n            .sse(\"/sse\", sse -> { });\n\n        app.unsafeConfig().router.apiBuilder(() -> {\n            path(\"users\", () -> {\n                get(new HandlerImplementation());\n                post(new HandlerImplementation());\n                path(\"{id}\", () -> {\n                    get(new HandlerImplementation());\n                    patch(new HandlerImplementation());\n                    delete(new HandlerImplementation());\n                });\n            });\n            crud(\"/movies/{movie-id}\", new CrudHandlerImpl());\n        });\n    }\n\n    private static void wsMethodRef(WsConfig wsConfig) {\n        wsConfig.onConnect(ctx -> ctx.session.getRemote().sendString(\"Connected!\"));\n    }\n\n    private static void methodReference(Context context) {\n    }\n\n    private static class ImplementingClass implements Handler {\n        @Override\n        public void handle(@NotNull Context context) {\n        }\n    }\n\n    public static class HandlerImplementation implements Handler {\n        @Override\n        public void handle(@NotNull Context context) {\n        }\n    }\n\n    static class CrudHandlerImpl implements CrudHandler {\n        @Override\n        public void getAll(@NotNull Context ctx) {\n        }\n        @Override\n        public void getOne(@NotNull Context ctx, @NotNull String resourceId) {\n        }\n        @Override\n        public void create(@NotNull Context ctx) {\n        }\n        @Override\n        public void update(@NotNull Context ctx, @NotNull String resourceId) {\n        }\n        @Override\n        public void delete(@NotNull Context ctx, @NotNull String resourceId) {\n        }\n    }\n\n}\n"
    },
    {
        "repo_name": "UPCBarcelonaTech/TFG-J2K",
        "ref": "refs/heads/master",
        "path": "javalin/examples_HelloWorldCors/HelloWorldCors.java",
        "copies": "1",
        "content": "/*\n * Javalin - https://javalin.io\n * Copyright 2017 David se\n * Licensed under Apache 2.0: https://github.com/tipsy/javalin/blob/master/LICENSE\n */\n\npackage io.javalin.examples;\n\nimport io.javalin.Javalin;\n\nimport static io.javalin.apibuilder.ApiBuilder.get;\nimport static io.javalin.apibuilder.ApiBuilder.patch;\nimport static io.javalin.apibuilder.ApiBuilder.post;\n\npublic class HelloWorldCors {\n\n    public static void main(String[] args) {\n        Javalin.create(config -> {\n            config.bundledPlugins.enableCors(cors -> {\n                cors.addRule(corsConfig -> {\n                    corsConfig.allowHost(\"http://localhost:7001/\", \"http://localhost:7002\");\n                });\n            });\n            config.router.apiBuilder(() -> {\n                get(ctx -> ctx.json(\"Hello Get\"));\n                post(ctx -> ctx.json(\"Hello Post\"));\n                patch(ctx -> ctx.json(\"Hello Patch\"));\n            });\n        }).start(7070);\n\n        Javalin.create().start(7001).get(\"/\", ctx -> ctx.html(\"Try some CORS\"));\n        Javalin.create().start(7002).get(\"/\", ctx -> ctx.html(\"Try some CORS\"));\n        Javalin.create().start(7003).get(\"/\", ctx -> ctx.html(\"No CORS here\"));\n    }\n\n}\n"
    }
]