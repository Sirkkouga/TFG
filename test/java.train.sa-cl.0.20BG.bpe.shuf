 public boolean is@@ L@@ on@@ g@@ C@@ li@@ c@@ k@@ En@@ able@@ d ( ) { return searchResult@@ H@@ asht@@ ags != null ; }
 public void set@@ I@@ d ( int id ) { this . id = id ; }
 public Option@@ Builder v@@ alu@@ e@@ Se@@ par@@ ator ( ch@@ a@@ r v@@ alu@@ e@@ Se@@ par@@ ator ) { this . v@@ alu@@ e@@ Se@@ par@@ ator = v@@ alu@@ e@@ Se@@ par@@ ator ; return this ; }
 @ Test public static void m@@ ul@@ ti@@ Th@@ rea@@ de@@ d@@ L@@ et@@ Test ( ) throws Script@@ Exception , In@@ ter@@ r@@ up@@ te@@ d@@ Exception { final N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory f@@ actory = new N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory ( ) ; final Script@@ En@@ gin@@ e e = f@@ actory . get@@ Script@@ En@@ gin@@ e ( L@@ A@@ N@@ G@@ U@@ A@@ G@@ E_@@ E@@ S@@ 6 ) ; final B@@ in@@ d@@ ings b = e . c@@ rea@@ te@@ B@@ in@@ d@@ ings ( ) ; final Script@@ Context or@@ i@@ g@@ Context = e . get@@ Context ( ) ; final Script@@ Context new@@ C@@ t@@ xt = new Si@@ mp@@ le@@ Script@@ Context ( ) ; new@@ C@@ t@@ xt . set@@ B@@ in@@ d@@ ings ( b , Script@@ Context . E@@ N@@ G@@ IN@@ E_@@ S@@ C@@ O@@ P@@ E ) ; final String shared@@ Script = " foo " ; assertEquals ( e . eval ( " le@@ t ▁ foo ▁ = ▁ ' or@@ i@@ gin@@ al ▁ context ' ; " , or@@ i@@ g@@ Context ) , null ) ; assertEquals ( e . eval ( " le@@ t ▁ foo ▁ = ▁ ' new ▁ context ' ; " , new@@ C@@ t@@ xt ) , null ) ; final Th@@ rea@@ d t@@ 1 = new Th@@ rea@@ d ( new Script@@ R@@ un@@ n@@ er ( e , or@@ i@@ g@@ Context , shared@@ Script , " or@@ i@@ gin@@ al ▁ context " , 1@@ 0@@ 0@@ 0 ) ) ; final Th@@ rea@@ d t@@ 2 = new Th@@ rea@@ d ( new Script@@ R@@ un@@ n@@ er ( e , new@@ C@@ t@@ xt , shared@@ Script , " new ▁ context " , 1@@ 0@@ 0@@ 0 ) ) ; t@@ 1 . st@@ ar@@ t ( ) ; t@@ 2 . st@@ ar@@ t ( ) ; t@@ 1 . j@@ o@@ in ( ) ; t@@ 2 . j@@ o@@ in ( ) ; assertEquals ( e . eval ( " foo ▁ = ▁ ' new@@ er ▁ context ' ; " , new@@ C@@ t@@ xt ) , " new@@ er ▁ context " ) ; final Th@@ rea@@ d t@@ 3 = new Th@@ rea@@ d ( new Script@@ R@@ un@@ n@@ er ( e , or@@ i@@ g@@ Context , shared@@ Script , " or@@ i@@ gin@@ al ▁ context " , 1@@ 0@@ 0@@ 0 ) ) ; final Th@@ rea@@ d t@@ 4 = new Th@@ rea@@ d ( new Script@@ R@@ un@@ n@@ er ( e , new@@ C@@ t@@ xt , shared@@ Script , " new@@ er ▁ context " , 1@@ 0@@ 0@@ 0 ) ) ; t@@ 3 . st@@ ar@@ t ( ) ; t@@ 4 . st@@ ar@@ t ( ) ; t@@ 3 . j@@ o@@ in ( ) ; t@@ 4 . j@@ o@@ in ( ) ; assertEquals ( e . eval ( shared@@ Script ) , " or@@ i@@ gin@@ al ▁ context " ) ; assertEquals ( e . eval ( shared@@ Script , new@@ C@@ t@@ xt ) , " new@@ er ▁ context " ) ; }
 public int get@@ Result@@ L@@ ength ( ) { return res@@ ult@@ L@@ ength ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ no@@ t ▁ throw ▁ ex@@ ce@@ ption ▁ if ▁ at@@ tribu@@ te ▁ type ▁ is ▁ null " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ N@@ ot@@ Th@@ ro@@ w@@ Exce@@ ption@@ I@@ f@@ Attribu@@ te@@ T@@ yp@@ e@@ I@@ d@@ I@@ sN@@ ull ( ) throws Exception { A@@ s@@ ser@@ t . assertTrue ( new PersonAttribute ( 1 ) . compareT@@ o ( new PersonAttribute ( 1 ) ) == 0 ) ; }
 @ Override public String op@@ Name ( ) { return " se@@ g@@ m@@ ent _ m@@ in " ; }
 public Option@@ Builder sh@@ or@@ t@@ Name ( ch@@ a@@ r n ) { sh@@ or@@ t@@ Name = n ; return this ; }
 public boolean Par@@ se ( String [ ] ar@@ g@@ s ) throws Exception { int p@@ os = 0 ; boolean s@@ w@@ it@@ ch@@ Mo@@ de = true ; for ( int i = 0 ; i < ar@@ g@@ s . length ; i ++ ) { String s = ar@@ g@@ s [ i ] ; if ( s . length ( ) == 0 ) return false ; if ( s@@ w@@ it@@ ch@@ Mo@@ de ) { if ( s . compareT@@ o ( " - - " ) == 0 ) { s@@ w@@ it@@ ch@@ Mo@@ de = false ; con@@ t@@ in@@ ue ; } if ( s . ch@@ ar@@ A@@ t ( 0 ) == ' - ' ) { String s@@ w = s . substring ( 1 ) . to@@ Lo@@ w@@ er@@ C@@ ase ( ) ; if ( s@@ w . length ( ) == 0 ) return false ; try { if ( ! Par@@ se@@ S@@ w@@ it@@ ch ( s@@ w ) ) return false ; } catch ( N@@ um@@ b@@ er@@ F@@ orm@@ at@@ Exception e ) { return false ; } con@@ t@@ in@@ ue ; } } if ( p@@ os == 0 ) { if ( s . e@@ qual@@ s@@ I@@ g@@ no@@ re@@ C@@ ase ( " e " ) ) Command = k@@ En@@ co@@ de ; else if ( s . e@@ qual@@ s@@ I@@ g@@ no@@ re@@ C@@ ase ( " d " ) ) Command = k@@ De@@ co@@ de ; else if ( s . e@@ qual@@ s@@ I@@ g@@ no@@ re@@ C@@ ase ( " b " ) ) Command = k@@ B@@ en@@ ch@@ ma@@ k ; else return false ; } else if ( p@@ os == 1 ) { if ( Command == k@@ B@@ en@@ ch@@ ma@@ k ) { try { N@@ um@@ B@@ en@@ ch@@ mar@@ k@@ P@@ ass@@ es = Integer . par@@ se@@ Int ( s ) ; if ( N@@ um@@ B@@ en@@ ch@@ mar@@ k@@ P@@ ass@@ es < 1 ) return false ; } catch ( N@@ um@@ b@@ er@@ F@@ orm@@ at@@ Exception e ) { return false ; } } else In@@ File = s ; } else if ( p@@ os == 2 ) O@@ ut@@ File = s ; else return false ; p@@ os ++ ; con@@ t@@ in@@ ue ; } return true ; }
 public Option@@ Builder is@@ P@@ roper@@ ty ( boolean is@@ P@@ roper@@ ty ) { this . is@@ P@@ roper@@ ty = is@@ P@@ roper@@ ty ; return this ; }
 public Integer ap@@ pl@@ y ( Integer in ) { return in * in ; }
 public int get@@ I@@ d ( ) { return id ; }
 public void set@@ P@@ ro@@ v@@ in@@ ce@@ _@@ id ( int p@@ ro@@ v@@ in@@ ce@@ _@@ id ) { this . p@@ ro@@ v@@ in@@ ce@@ _@@ id = p@@ ro@@ v@@ in@@ ce@@ _@@ id ; }
 public int co@@ m@@ par@@ e ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareT@@ o ( o@@ 2 ) ; }
 boolean Par@@ se@@ S@@ w@@ it@@ ch ( String s ) { if ( s . startsWith ( " d " ) ) { D@@ ic@@ tion@@ ar@@ y@@ Size = 1 <@@ < Integer . par@@ se@@ Int ( s . substring ( 1 ) ) ; D@@ ic@@ tion@@ ar@@ y@@ Si@@ z@@ e@@ I@@ s@@ De@@ fin@@ ed = true ; } else if ( s . startsWith ( " f@@ b " ) ) { F@@ b = Integer . par@@ se@@ Int ( s . substring ( 2 ) ) ; F@@ b@@ I@@ s@@ De@@ fin@@ ed = true ; } else if ( s . startsWith ( " a " ) ) A@@ l@@ g@@ or@@ i@@ th@@ m = Integer . par@@ se@@ Int ( s . substring ( 1 ) ) ; else if ( s . startsWith ( " l@@ c " ) ) L@@ c = Integer . par@@ se@@ Int ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " l@@ p " ) ) L@@ p = Integer . par@@ se@@ Int ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " p@@ b " ) ) P@@ b = Integer . par@@ se@@ Int ( s . substring ( 2 ) ) ; else if ( s . startsWith ( " e@@ os " ) ) E@@ os = true ; else if ( s . startsWith ( " m@@ f " ) ) { String m@@ f@@ s = s . substring ( 2 ) ; if ( m@@ f@@ s . equals ( " b@@ t@@ 2@@ " ) ) M@@ at@@ ch@@ F@@ in@@ der = 0 ; else if ( m@@ f@@ s . equals ( " b@@ t@@ 4@@ " ) ) M@@ at@@ ch@@ F@@ in@@ der = 1 ; else if ( m@@ f@@ s . equals ( " b@@ t@@ 4@@ b " ) ) M@@ at@@ ch@@ F@@ in@@ der = 2 ; else return false ; } else return false ; return true ; }
 @ Test public static void m@@ e@@ g@@ am@@ or@@ p@@ h@@ ic@@ S@@ ing@@ le@@ G@@ l@@ ob@@ al@@ L@@ et@@ Test ( ) throws Script@@ Exception , In@@ ter@@ r@@ up@@ te@@ d@@ Exception { final N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory f@@ actory = new N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory ( ) ; final Script@@ En@@ gin@@ e e = f@@ actory . get@@ Script@@ En@@ gin@@ e ( L@@ A@@ N@@ G@@ U@@ A@@ G@@ E_@@ E@@ S@@ 6 ) ; final String shared@@ G@@ et@@ ter@@ Script = " foo " ; final String shared@@ Set@@ ter@@ Script = " foo ▁ = ▁ 1@@ " ; for ( int i = 0 ; i < M@@ E@@ G@@ A@@ M@@ O@@ R@@ P@@ H@@ I@@ C@@ _@@ L@@ O@@ O@@ P@@ _@@ C@@ O@@ U@@ N@@ T ; i ++ ) { assertEquals ( e . eval ( shared@@ Set@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( " d@@ el@@ et@@ e ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , i ) ; } assertEquals ( e . eval ( " le@@ t ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , " foo " ) ; assertEquals ( e . eval ( shared@@ Set@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , M@@ E@@ G@@ A@@ M@@ O@@ R@@ P@@ H@@ I@@ C@@ _@@ L@@ O@@ O@@ P@@ _@@ C@@ O@@ U@@ N@@ T - 1 ) ; }
 @ Test public void te@@ st@@ F@@ all@@ 2 ( ) { String key = "@@ 1@@ 9@@ 7@@ 9@@ 1@@ 1@@ 2@@ 3@@ -@@ 9@@ 2@@ 6@@ 2@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 2 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 01@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 1 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 0@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 public J@@ ar@@ En@@ try get@@ J@@ ar@@ En@@ try ( String name ) { J@@ ar@@ En@@ try entry = s@@ up@@ er . get@@ J@@ ar@@ En@@ try ( name ) ; if ( ( entry != null ) && ( entry . get@@ Size ( ) == 0 ) && ! entry . is@@ D@@ i@@ rec@@ tory ( ) ) { J@@ ar@@ En@@ try di@@ r@@ En@@ try = s@@ up@@ er . get@@ J@@ ar@@ En@@ try ( name + ' / ' ) ; if ( di@@ r@@ En@@ try != null ) { entry = di@@ r@@ En@@ try ; } } return entry ; }
 public void te@@ st@@ M@@ er@@ ge@@ 3 ( ) { List < String > a = Array@@ s . as@@ List ( " a " , " b " , " d " , " e " ) ; List < String > b = Array@@ s . as@@ List ( " b " , " c " , " d " , " e " ) ; List < String > c = Array@@ s . as@@ List ( " a " , " b " , " c " , " e " , " f " ) ; Co@@ m@@ par@@ ator < String > co@@ m@@ par@@ ator = new Co@@ m@@ par@@ ator < String > ( ) { public int co@@ m@@ par@@ e ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareT@@ o ( o@@ 2 ) ; } } ; I@@ ter@@ ator < T@@ ri@@ p@@ le < String , String , String > > i@@ ter = I@@ ter@@ able@@ s . m@@ er@@ g@@ e ( a , b , c , co@@ m@@ par@@ ator ) . i@@ ter@@ ator ( ) ; assertEquals ( i@@ ter . ne@@ xt ( ) , new T@@ ri@@ p@@ le < String , String , String > ( " b " , " b " , " b " ) ) ; assertEquals ( i@@ ter . ne@@ xt ( ) , new T@@ ri@@ p@@ le < String , String , String > ( " e " , " e " , " e " ) ) ; assertTrue ( ! i@@ ter . has@@ N@@ e@@ xt ( ) ) ; }
 public void te@@ st@@ Z@@ i@@ p ( ) { String [ ] s@@ 1 = new String [ ] { " a " , " b " , " c " } ; Integer [ ] s@@ 2 = new Integer [ ] { 1 , 2 , 3 , 4 } ; int co@@ unt = 0 ; for ( P@@ a@@ i@@ r < String , Integer > p@@ a@@ i@@ r : I@@ ter@@ able@@ s . z@@ i@@ p ( s@@ 1 , s@@ 2 ) ) { assertEquals ( p@@ a@@ i@@ r . fi@@ r@@ st , s@@ 1 [ co@@ unt ] ) ; assertEquals ( p@@ a@@ i@@ r . se@@ con@@ d , s@@ 2 [ co@@ unt ] ) ; co@@ unt ++ ; } assertEquals ( s@@ 1 . length < s@@ 2 . length ? s@@ 1 . length : s@@ 2 . length , co@@ unt ) ; }
 public static String get@@ St@@ ack@@ Tr@@ ac@@ e ( final Th@@ ro@@ w@@ able e@@ x ) { final S@@ tr@@ ing@@ W@@ ri@@ ter s@@ w = new S@@ tr@@ ing@@ W@@ ri@@ ter ( ) ; final P@@ r@@ int@@ W@@ ri@@ ter p@@ w = new P@@ r@@ int@@ W@@ ri@@ ter ( s@@ w , true ) ; e@@ x . p@@ r@@ int@@ St@@ ack@@ Tr@@ ac@@ e ( p@@ w ) ; p@@ w . f@@ lu@@ s@@ h ( ) ; s@@ w . f@@ lu@@ s@@ h ( ) ; return s@@ w . to@@ String ( ) ; }
 public void set@@ Ch@@ at@@ In@@ fo ( T@@ L@@ R@@ P@@ C . Ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ ts ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ ts ) { in@@ fo = ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ ts ; if ( l@@ ast@@ Te@@ xt != null ) { search@@ User@@ n@@ ame@@ O@@ r@@ H@@ ash@@ ta@@ g ( l@@ ast@@ Te@@ xt , l@@ ast@@ P@@ o@@ si@@ tion , m@@ essag@@ es ) ; } }
 public void search@@ User@@ n@@ ame@@ O@@ r@@ H@@ ash@@ ta@@ g ( String text , int p@@ o@@ si@@ tion , ArrayList < Messag@@ e@@ Object > m@@ essag@@ e@@ Ob@@ jec@@ ts ) { if ( text == null || text . length ( ) == 0 ) { de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; l@@ ast@@ Te@@ xt = null ; return ; } int search@@ P@@ o@@ s@@ tion = p@@ o@@ si@@ tion ; if ( text . length ( ) > 0 ) { search@@ P@@ o@@ s@@ tion -@@ - ; } l@@ ast@@ Te@@ xt = null ; S@@ tr@@ ing@@ Builder result = new S@@ tr@@ ing@@ Builder ( ) ; int fo@@ und@@ Type = - 1 ; boolean has@@ I@@ l@@ leg@@ al@@ User@@ n@@ ame@@ Ch@@ arac@@ ters = false ; for ( int a = search@@ P@@ o@@ s@@ tion ; a >@@ = 0 ; a -@@ - ) { if ( a >@@ = text . length ( ) ) { con@@ t@@ in@@ ue ; } ch@@ a@@ r ch = text . ch@@ ar@@ A@@ t ( a ) ; if ( a == 0 || text . ch@@ ar@@ A@@ t ( a - 1 ) == ' ▁ ' || text . ch@@ ar@@ A@@ t ( a - 1 ) == ' \n ' ) { if ( ne@@ ed@@ User@@ names && ch == ' @ ' ) { if ( has@@ I@@ l@@ leg@@ al@@ User@@ n@@ ame@@ Ch@@ arac@@ ters ) { de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; return ; } if ( in@@ fo == null ) { l@@ ast@@ Te@@ xt = text ; l@@ ast@@ P@@ o@@ si@@ tion = p@@ o@@ si@@ tion ; m@@ essag@@ es = m@@ essag@@ e@@ Ob@@ jec@@ ts ; de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; return ; } fo@@ und@@ Type = 0 ; res@@ ult@@ St@@ art@@ P@@ o@@ si@@ tion = a ; res@@ ult@@ L@@ ength = result . length ( ) + 1 ; b@@ rea@@ k ; } else if ( ch == ' # ' ) { if ( ! h@@ asht@@ ag@@ s@@ Lo@@ a@@ de@@ d@@ F@@ ro@@ m@@ D@@ b ) { lo@@ ad@@ R@@ ec@@ en@@ t@@ H@@ asht@@ ags ( ) ; l@@ ast@@ Te@@ xt = text ; l@@ ast@@ P@@ o@@ si@@ tion = p@@ o@@ si@@ tion ; m@@ essag@@ es = m@@ essag@@ e@@ Ob@@ jec@@ ts ; de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; return ; } fo@@ und@@ Type = 1 ; res@@ ult@@ St@@ art@@ P@@ o@@ si@@ tion = a ; res@@ ult@@ L@@ ength = result . length ( ) + 1 ; result . in@@ ser@@ t ( 0 , ch ) ; b@@ rea@@ k ; } else if ( a == 0 && b@@ ot@@ In@@ fo != null && ch == ' / ' ) { fo@@ und@@ Type = 2 ; res@@ ult@@ St@@ art@@ P@@ o@@ si@@ tion = a ; res@@ ult@@ L@@ ength = result . length ( ) + 1 ; b@@ rea@@ k ; } } if ( ! ( ch >@@ = '@@ 0@@ ' && ch <@@ = '@@ 9@@ ' || ch >@@ = ' a ' && ch <@@ = ' z ' || ch >@@ = ' A ' && ch <@@ = ' Z ' || ch == ' _ ' ) ) { has@@ I@@ l@@ leg@@ al@@ User@@ n@@ ame@@ Ch@@ arac@@ ters = true ; } result . in@@ ser@@ t ( 0 , ch ) ; } if ( fo@@ und@@ Type == - 1 ) { de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; return ; } if ( fo@@ und@@ Type == 0 ) { final ArrayList < Integer > u@@ ser@@ s = new ArrayList < > ( ) ; for ( int a = 0 ; a < M@@ ath . m@@ in ( 1@@ 0@@ 0 , m@@ essag@@ e@@ Ob@@ jec@@ ts . size ( ) ) ; a ++ ) { int f@@ ro@@ m@@ _@@ id = m@@ essag@@ e@@ Ob@@ jec@@ ts . get ( a ) . m@@ essag@@ e@@ O@@ w@@ n@@ er . f@@ ro@@ m@@ _@@ id ; if ( ! u@@ ser@@ s . con@@ ta@@ ins ( f@@ ro@@ m@@ _@@ id ) ) { u@@ ser@@ s . add ( f@@ ro@@ m@@ _@@ id ) ; } } String u@@ ser@@ n@@ ame@@ String = result . to@@ String ( ) . to@@ Lo@@ w@@ er@@ C@@ ase ( ) ; ArrayList < T@@ L@@ R@@ P@@ C . U@@ ser > new@@ Res@@ ult = new ArrayList < > ( ) ; for ( T@@ L@@ R@@ P@@ C . T@@ L@@ _@@ ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ t ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ t : in@@ fo . par@@ ti@@ c@@ i@@ p@@ an@@ ts ) { T@@ L@@ R@@ P@@ C . U@@ ser u@@ ser = Messag@@ es@@ Con@@ tr@@ ol@@ l@@ er . get@@ In@@ stan@@ c@@ e ( ) . get@@ U@@ ser ( ch@@ at@@ Par@@ ti@@ c@@ i@@ p@@ an@@ t . u@@ ser@@ _@@ id ) ; if ( u@@ ser == null || User@@ Object . is@@ User@@ S@@ el@@ f ( u@@ ser ) ) { con@@ t@@ in@@ ue ; } if ( u@@ ser . u@@ ser@@ name != null && u@@ ser . u@@ ser@@ name . length ( ) > 0 && ( u@@ ser@@ n@@ ame@@ String . length ( ) > 0 && u@@ ser . u@@ ser@@ name . to@@ Lo@@ w@@ er@@ C@@ ase ( ) . startsWith ( u@@ ser@@ n@@ ame@@ String ) || u@@ ser@@ n@@ ame@@ String . length ( ) == 0 ) ) { new@@ Res@@ ult . add ( u@@ ser ) ; } } searchResult@@ H@@ asht@@ ags = null ; searchResultCommand@@ s = null ; searchResultCommand@@ s@@ H@@ el@@ p = null ; searchResultCommand@@ s@@ User@@ s = null ; searchResult@@ User@@ names = new@@ Res@@ ult ; Co@@ l@@ le@@ c@@ tion@@ s . s@@ or@@ t ( searchResult@@ User@@ names , new Co@@ m@@ par@@ ator < T@@ L@@ R@@ P@@ C . U@@ ser > ( ) { @ Override public int co@@ m@@ par@@ e ( T@@ L@@ R@@ P@@ C . U@@ ser l@@ h@@ s , T@@ L@@ R@@ P@@ C . U@@ ser r@@ h@@ s ) { int l@@ hsNum = u@@ ser@@ s . in@@ de@@ x@@ O@@ f ( l@@ h@@ s . id ) ; int r@@ hsNum = u@@ ser@@ s . in@@ de@@ x@@ O@@ f ( r@@ h@@ s . id ) ; if ( l@@ hsNum != - 1 && r@@ hsNum != - 1 ) { return l@@ hsNum < r@@ hsNum ? - 1 : ( l@@ hsNum == r@@ hsNum ? 0 : 1 ) ; } else if ( l@@ hsNum != - 1 && r@@ hsNum == - 1 ) { return - 1 ; } else if ( l@@ hsNum == - 1 && r@@ hsNum != - 1 ) { return 1 ; } return 0 ; } } ) ; no@@ ti@@ f@@ y@@ Data@@ Set@@ Ch@@ an@@ ge@@ d ( ) ; de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( ! new@@ Res@@ ult . is@@ E@@ mp@@ ty ( ) ) ; } else if ( fo@@ und@@ Type == 1 ) { ArrayList < String > new@@ Res@@ ult = new ArrayList < > ( ) ; String h@@ asht@@ ag@@ String = result . to@@ String ( ) . to@@ Lo@@ w@@ er@@ C@@ ase ( ) ; for ( H@@ asht@@ ag@@ Object h@@ asht@@ ag@@ Object : h@@ asht@@ ags ) { if ( h@@ asht@@ ag@@ Object != null && h@@ asht@@ ag@@ Object . h@@ ash@@ ta@@ g != null && h@@ asht@@ ag@@ Object . h@@ ash@@ ta@@ g . startsWith ( h@@ asht@@ ag@@ String ) ) { new@@ Res@@ ult . add ( h@@ asht@@ ag@@ Object . h@@ ash@@ ta@@ g ) ; } } searchResult@@ H@@ asht@@ ags = new@@ Res@@ ult ; searchResult@@ User@@ names = null ; searchResultCommand@@ s = null ; searchResultCommand@@ s@@ H@@ el@@ p = null ; searchResultCommand@@ s@@ User@@ s = null ; no@@ ti@@ f@@ y@@ Data@@ Set@@ Ch@@ an@@ ge@@ d ( ) ; de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( ! new@@ Res@@ ult . is@@ E@@ mp@@ ty ( ) ) ; } else if ( fo@@ und@@ Type == 2 ) { ArrayList < String > new@@ Res@@ ult = new ArrayList < > ( ) ; ArrayList < String > new@@ Result@@ H@@ el@@ p = new ArrayList < > ( ) ; ArrayList < T@@ L@@ R@@ P@@ C . U@@ ser > new@@ Result@@ User@@ s = new ArrayList < > ( ) ; String comm@@ and = result . to@@ String ( ) . to@@ Lo@@ w@@ er@@ C@@ ase ( ) ; for ( H@@ ash@@ Map . En@@ try < Integer , T@@ L@@ R@@ P@@ C . B@@ ot@@ In@@ fo > entry : b@@ ot@@ In@@ fo . en@@ tr@@ y@@ Se@@ t ( ) ) { for ( T@@ L@@ R@@ P@@ C . T@@ L@@ _@@ b@@ ot@@ Command b@@ ot@@ Command : entry . get@@ Value ( ) . comm@@ and@@ s ) { if ( b@@ ot@@ Command != null && b@@ ot@@ Command . comm@@ and != null && b@@ ot@@ Command . comm@@ and . startsWith ( comm@@ and ) ) { new@@ Res@@ ult . add ( " / " + b@@ ot@@ Command . comm@@ and ) ; new@@ Result@@ H@@ el@@ p . add ( b@@ ot@@ Command . d@@ es@@ cri@@ ption ) ; new@@ Result@@ User@@ s . add ( Messag@@ es@@ Con@@ tr@@ ol@@ l@@ er . get@@ In@@ stan@@ c@@ e ( ) . get@@ U@@ ser ( entry . get@@ Value ( ) . u@@ ser@@ _@@ id ) ) ; } } } searchResult@@ H@@ asht@@ ags = null ; searchResult@@ User@@ names = null ; searchResultCommand@@ s = new@@ Res@@ ult ; searchResultCommand@@ s@@ H@@ el@@ p = new@@ Result@@ H@@ el@@ p ; searchResultCommand@@ s@@ User@@ s = new@@ Result@@ User@@ s ; no@@ ti@@ f@@ y@@ Data@@ Set@@ Ch@@ an@@ ge@@ d ( ) ; de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( ! new@@ Res@@ ult . is@@ E@@ mp@@ ty ( ) ) ; } }
 @ Override p@@ ro@@ te@@ c@@ ted void set@@ H@@ asht@@ ags ( ArrayList < H@@ asht@@ ag@@ Object > ar@@ r@@ ay@@ List , H@@ ash@@ Map < String , H@@ asht@@ ag@@ Object > h@@ ash@@ Map ) { s@@ up@@ er . set@@ H@@ asht@@ ags ( ar@@ r@@ ay@@ List , h@@ ash@@ Map ) ; if ( l@@ ast@@ Te@@ xt != null ) { search@@ User@@ n@@ ame@@ O@@ r@@ H@@ ash@@ ta@@ g ( l@@ ast@@ Te@@ xt , l@@ ast@@ P@@ o@@ si@@ tion , m@@ essag@@ es ) ; } }
 public void set@@ C@@ it@@ y@@ _@@ co@@ de ( String c@@ it@@ y@@ _@@ co@@ de ) { this . c@@ it@@ y@@ _@@ co@@ de = c@@ it@@ y@@ _@@ co@@ de ; }
 @ Override public boolean has@@ St@@ able@@ I@@ d@@ s ( ) { return true ; }
 @ Test public void te@@ st@@ F@@ all@@ 7 ( ) { String key = "@@ 1@@ 9@@ 8@@ 0@@ 0@@ 2@@ 2@@ 8@@ -@@ 9@@ 2@@ 2@@ 4@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; assert@@ N@@ ull ( map . get ( key ) ) ; }
 public static void res@@ ol@@ ve@@ Con@@ fi@@ g ( En@@ vi@@ r@@ on@@ m@@ ent en@@ v , final I@@ mm@@ ut@@ able@@ Set@@ t@@ ings . Builder set@@ t@@ ing@@ s@@ Builder ) { try { File@@ s . w@@ al@@ k@@ File@@ T@@ re@@ e ( en@@ v . con@@ fi@@ g@@ File ( ) . to@@ P@@ ath ( ) , En@@ um@@ Se@@ t . of ( File@@ V@@ is@@ it@@ O@@ ption . F@@ O@@ L@@ L@@ O@@ W@@ _@@ L@@ IN@@ K@@ S ) , Integer . M@@ A@@ X@@ _@@ V@@ A@@ L@@ U@@ E , new Si@@ mp@@ le@@ File@@ V@@ is@@ it@@ or < P@@ ath > ( ) { @ Override public File@@ V@@ is@@ it@@ Res@@ ult v@@ is@@ it@@ File ( P@@ ath fil@@ e , B@@ as@@ ic@@ File@@ Attribu@@ te@@ s at@@ tr@@ s ) throws IOException { if ( fil@@ e . get@@ File@@ Name ( ) . to@@ String ( ) . startsWith ( " lo@@ g@@ g@@ ing . " ) ) { lo@@ ad@@ Con@@ fi@@ g ( fil@@ e , set@@ t@@ ing@@ s@@ Builder ) ; } return File@@ V@@ is@@ it@@ Res@@ ult . C@@ ON@@ T@@ IN@@ U@@ E ; } } ) ; } catch ( IOException i@@ o@@ e ) { throw new E@@ l@@ as@@ ti@@ c@@ search@@ Exception ( " F@@ a@@ ile@@ d ▁ t@@ o ▁ lo@@ a@@ d ▁ lo@@ g@@ g@@ ing ▁ con@@ fi@@ g@@ ur@@ ati@@ on " , i@@ o@@ e ) ; } }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ true ▁ if ▁ at@@ tribu@@ teType ▁ value ▁ and ▁ void ▁ st@@ at@@ u@@ s ▁ ar@@ e ▁ th@@ e ▁ s@@ ame " , m@@ et@@ ho@@ d = " e@@ qual@@ s@@ Con@@ te@@ n@@ t ( PersonAttribute ) " ) public void e@@ qual@@ s@@ Con@@ te@@ n@@ t@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ Tr@@ u@@ e@@ I@@ f@@ Attribu@@ te@@ T@@ yp@@ e@@ V@@ alu@@ e@@ A@@ n@@ d@@ V@@ o@@ id@@ St@@ at@@ u@@ s@@ A@@ re@@ Th@@ e@@ S@@ ame ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; pa . set@@ Value ( "@@ 1@@ " ) ; pa . set@@ V@@ o@@ ide@@ d ( false ) ; PersonAttribute other = new PersonAttribute ( 1 ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; pa . set@@ Value ( "@@ 1@@ " ) ; pa . set@@ V@@ o@@ ide@@ d ( false ) ; A@@ s@@ ser@@ t . assertTrue ( pa . e@@ qual@@ s@@ Con@@ te@@ n@@ t ( other ) ) ; }
 public void add ( T@@ as@@ k@@ At@@ te@@ mp@@ t@@ In@@ fo t@@ as@@ k@@ at@@ te@@ mp@@ t@@ In@@ fo ) { t@@ as@@ k@@ At@@ te@@ mp@@ t . add ( t@@ as@@ k@@ at@@ te@@ mp@@ t@@ In@@ fo ) ; }
 @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { if ( historyRes . get@@ P@@ u@@ bli@@ sh@@ Date ( ) != null ) { return historyRes . get@@ P@@ u@@ bli@@ sh@@ Date ( ) . get@@ D@@ ate@@ Te@@ xt ( ) ; } return " - " ; }
 private void add@@ Re@@ ver@@ t@@ Column ( ) { Cms@@ Bu@@ t@@ t@@ on@@ C@@ el@@ l < CmsHistoryResourceBean > re@@ pl@@ a@@ ce@@ C@@ el@@ l = new Cms@@ Bu@@ t@@ t@@ on@@ C@@ el@@ l < CmsHistoryResourceBean > ( CmsHistory@@ Messag@@ es . ti@@ t@@ le@@ Re@@ ver@@ t ( ) , I@@ _@@ Cms@@ I@@ m@@ ag@@ e@@ B@@ und@@ le . IN@@ S@@ T@@ A@@ N@@ C@@ E . st@@ y@@ le ( ) . t@@ able@@ Re@@ pl@@ a@@ ce@@ I@@ c@@ on ( ) , new A@@ c@@ tion@@ C@@ el@@ l . De@@ leg@@ ate < CmsHistoryResourceBean > ( ) { @ S@@ up@@ p@@ res@@ sW@@ ar@@ n@@ ings ( " s@@ y@@ n@@ th@@ et@@ i@@ c - ac@@ c@@ es@@ s " ) public void ex@@ ec@@ u@@ te ( CmsHistoryResourceBean historyRes ) { m@@ _@@ h@@ and@@ l@@ er . re@@ ver@@ t ( historyRes ) ; } } , new P@@ re@@ d@@ ic@@ ate < CmsHistoryResourceBean > ( ) { public boolean ap@@ pl@@ y ( CmsHistoryResourceBean b@@ e@@ an ) { return b@@ e@@ an . get@@ V@@ er@@ sion ( ) . get@@ V@@ er@@ si@@ on@@ N@@ um@@ b@@ er ( ) != null ; } } ) ; add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ Re@@ pl@@ ac@@ e ( ) , 3@@ 0 , new I@@ d@@ en@@ ti@@ ty@@ Column < CmsHistoryResourceBean > ( re@@ pl@@ a@@ ce@@ C@@ el@@ l ) ) ; }
 public void mar@@ sh@@ al ( Object s@@ our@@ c@@ e , H@@ i@@ er@@ ar@@ ch@@ ic@@ al@@ St@@ re@@ am@@ W@@ ri@@ ter wri@@ ter , M@@ ar@@ sh@@ all@@ ing@@ Context context ) { B@@ ri@@ c@@ k@@ C@@ an@@ v@@ as c@@ an@@ v@@ as = ( B@@ ri@@ c@@ k@@ C@@ an@@ v@@ as ) s@@ our@@ c@@ e ; wri@@ ter . start@@ N@@ o@@ de ( " c@@ an@@ v@@ as@@ B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e " ) ; context . con@@ ver@@ t@@ A@@ no@@ ther ( c@@ an@@ v@@ as . get@@ B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e ( ) ) ; wri@@ ter . end@@ N@@ o@@ de ( ) ; wri@@ ter . start@@ N@@ o@@ de ( " b@@ ri@@ c@@ k@@ s@@ O@@ n@@ C@@ an@@ v@@ as " ) ; for ( Object ob@@ j : c@@ an@@ v@@ as . get@@ B@@ ri@@ c@@ k@@ s ( ) ) { if ( ob@@ j in@@ stan@@ ce@@ of B@@ ri@@ c@@ k ) { wri@@ ter . start@@ N@@ o@@ de ( ob@@ j . get@@ Cl@@ ass ( ) . get@@ Name ( ) ) ; context . con@@ ver@@ t@@ A@@ no@@ ther ( ob@@ j ) ; wri@@ ter . end@@ N@@ o@@ de ( ) ; } } wri@@ ter . end@@ N@@ o@@ de ( ) ; }
 public String get@@ C@@ it@@ y@@ _@@ name ( ) { return c@@ it@@ y@@ _@@ name ; }
 @ Override public String te@@ n@@ s@@ or@@ f@@ lo@@ w@@ Name ( ) { return " Se@@ g@@ m@@ en@@ t@@ M@@ in " ; }
 private static File p@@ at@@ h@@ O@@ f@@ File@@ In@@ De@@ fa@@ ult@@ File@@ s ( String fi@@ le@@ P@@ ath ) { return new File ( M@@ ul@@ ti@@ p@@ le@@ Ex@@ te@@ n@@ si@@ on@@ P@@ lu@@ gin@@ W@@ i@@ th@@ P@@ lu@@ gin@@ M@@ an@@ ag@@ er@@ In@@ te@@ g@@ r@@ ati@@ on@@ Test . cl@@ ass . get@@ Cl@@ ass@@ Lo@@ a@@ der ( ) . get@@ Resour@@ c@@ e ( " de@@ fa@@ ult@@ File@@ s / " + fi@@ le@@ P@@ ath ) . get@@ File ( ) ) ; }
 @ Override public List < S@@ D@@ V@@ ar@@ i@@ able > d@@ o@@ D@@ i@@ f@@ f ( List < S@@ D@@ V@@ ar@@ i@@ able > g@@ r@@ ad@@ i@@ en@@ ts ) { return Array@@ s . as@@ List ( f ( ) . se@@ g@@ m@@ en@@ t@@ M@@ in@@ B@@ p ( ar@@ g ( 0 ) , ar@@ g ( 1 ) , g@@ r@@ ad@@ i@@ en@@ ts . get ( 0 ) ) ) ; }
 public Option@@ Builder re@@ qu@@ i@@ re@@ d ( boolean re@@ qu@@ i@@ re@@ d ) { this . re@@ qu@@ i@@ re@@ d = re@@ qu@@ i@@ re@@ d ; return this ; }
 public void set@@ B@@ ot@@ In@@ fo ( H@@ ash@@ Map < Integer , T@@ L@@ R@@ P@@ C . B@@ ot@@ In@@ fo > in@@ fo ) { b@@ ot@@ In@@ fo = in@@ fo ; }
 @ Override public File@@ V@@ is@@ it@@ Res@@ ult v@@ is@@ it@@ File ( P@@ ath fil@@ e , B@@ as@@ ic@@ File@@ Attribu@@ te@@ s at@@ tr@@ s ) throws IOException { if ( fil@@ e . get@@ File@@ Name ( ) . to@@ String ( ) . startsWith ( " lo@@ g@@ g@@ ing . " ) ) { lo@@ ad@@ Con@@ fi@@ g ( fil@@ e , set@@ t@@ ing@@ s@@ Builder ) ; } return File@@ V@@ is@@ it@@ Res@@ ult . C@@ ON@@ T@@ IN@@ U@@ E ; }
 @ Override public void r@@ u@@ n ( H@@ el@@ lo@@ W@@ or@@ l@@ d@@ Con@@ fi@@ g@@ ur@@ ati@@ on con@@ fi@@ g , En@@ vi@@ r@@ on@@ m@@ ent en@@ vi@@ r@@ on@@ m@@ ent ) { final J@@ d@@ bi@@ F@@ actory f@@ actory = new J@@ d@@ bi@@ F@@ actory ( ) ; final J@@ d@@ b@@ i j@@ d@@ b@@ i = f@@ actory . bu@@ il@@ d ( en@@ vi@@ r@@ on@@ m@@ ent , con@@ fi@@ g . get@@ Dat@@ ab@@ as@@ e@@ Con@@ fi@@ g@@ ur@@ ati@@ on ( ) , " R@@ D@@ B@@ M@@ S " ) ; en@@ vi@@ r@@ on@@ m@@ ent . j@@ er@@ se@@ y ( ) . re@@ g@@ is@@ ter ( new W@@ or@@ l@@ d@@ Resour@@ c@@ e ( new W@@ or@@ l@@ d@@ Re@@ p@@ o@@ s@@ it@@ or@@ y ( j@@ d@@ b@@ i ) ) ) ; en@@ vi@@ r@@ on@@ m@@ ent . j@@ er@@ se@@ y ( ) . re@@ g@@ is@@ ter ( new F@@ or@@ t@@ u@@ ne@@ Resour@@ c@@ e ( new F@@ or@@ t@@ u@@ ne@@ Re@@ p@@ o@@ s@@ it@@ or@@ y ( j@@ d@@ b@@ i ) ) ) ; }
 private void add@@ V@@ er@@ si@@ on@@ Column ( ) { A@@ b@@ str@@ ac@@ t@@ C@@ el@@ l < CmsHistoryResourceBean > ce@@ l@@ l = new Cms@@ V@@ er@@ si@@ on@@ C@@ el@@ l ( ) ; add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ V@@ er@@ sion ( ) , 4@@ 0 , new I@@ d@@ en@@ ti@@ ty@@ Column < CmsHistoryResourceBean > ( ce@@ l@@ l ) ) ; }
 public void te@@ st@@ S@@ am@@ p@@ le ( ) { I@@ ter@@ able < Integer > i@@ tem@@ s = Array@@ s . as@@ List ( 5 , 4 , 3 , 2 , 1 ) ; int co@@ unt = 0 ; for ( Integer item : I@@ ter@@ able@@ s . s@@ am@@ p@@ le ( i@@ tem@@ s , 5 , 2 , new R@@ and@@ o@@ m ( ) ) ) { ++ co@@ unt ; A@@ s@@ ser@@ t . assertTrue ( item <@@ = 5 ) ; A@@ s@@ ser@@ t . assertTrue ( item >@@ = 1 ) ; } A@@ s@@ ser@@ t . assertEquals ( 2 , co@@ unt ) ; }
 private void add@@ P@@ re@@ vie@@ w@@ Column ( ) { Cms@@ Bu@@ t@@ t@@ on@@ C@@ el@@ l < CmsHistoryResourceBean > p@@ re@@ vie@@ w@@ C@@ el@@ l = new Cms@@ Bu@@ t@@ t@@ on@@ C@@ el@@ l < CmsHistoryResourceBean > ( CmsHistory@@ Messag@@ es . ti@@ t@@ le@@ P@@ re@@ vie@@ w ( ) , I@@ _@@ Cms@@ I@@ m@@ ag@@ e@@ B@@ und@@ le . IN@@ S@@ T@@ A@@ N@@ C@@ E . st@@ y@@ le ( ) . t@@ able@@ P@@ re@@ vie@@ w@@ I@@ c@@ on ( ) , new A@@ c@@ tion@@ C@@ el@@ l . De@@ leg@@ ate < CmsHistoryResourceBean > ( ) { @ S@@ up@@ p@@ res@@ sW@@ ar@@ n@@ ings ( " s@@ y@@ n@@ th@@ et@@ i@@ c - ac@@ c@@ es@@ s " ) public void ex@@ ec@@ u@@ te ( CmsHistoryResourceBean historyRes ) { m@@ _@@ h@@ and@@ l@@ er . sho@@ w@@ P@@ re@@ vie@@ w ( historyRes ) ; } } , new P@@ re@@ d@@ ic@@ ate < CmsHistoryResourceBean > ( ) { public boolean ap@@ pl@@ y ( CmsHistoryResourceBean b@@ e@@ an ) { return true ; } } ) ; add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ P@@ re@@ vie@@ w ( ) , 3@@ 0 , new I@@ d@@ en@@ ti@@ ty@@ Column < CmsHistoryResourceBean > ( p@@ re@@ vie@@ w@@ C@@ el@@ l ) ) ; }
 public Option@@ Builder o@@ ption@@ Type ( Option@@ Type o@@ ption@@ Type ) { this . o@@ ption@@ Type = o@@ ption@@ Type ; return this ; }
 @ Bean public S@@ er@@ v@@ er j@@ a@@ x@@ R@@ s@@ S@@ er@@ v@@ er ( ) { J@@ A@@ X@@ R@@ S@@ S@@ er@@ ver@@ F@@ ac@@ tor@@ y@@ Bean f@@ actory = R@@ un@@ ti@@ m@@ e@@ De@@ leg@@ ate . get@@ In@@ stan@@ c@@ e ( ) . c@@ rea@@ te@@ En@@ d@@ p@@ o@@ int ( j@@ a@@ x@@ R@@ s@@ A@@ p@@ i@@ A@@ p@@ p@@ li@@ c@@ ati@@ on ( ) , J@@ A@@ X@@ R@@ S@@ S@@ er@@ ver@@ F@@ ac@@ tor@@ y@@ Bean . cl@@ ass ) ; f@@ actory . set@@ S@@ er@@ vi@@ ce@@ Be@@ an@@ s ( Array@@ s . < Object > as@@ List ( p@@ e@@ op@@ le@@ Res@@ t@@ S@@ er@@ vic@@ e ( ) ) ) ; f@@ actory . set@@ A@@ d@@ d@@ res@@ s ( " / " + f@@ actory . get@@ A@@ d@@ d@@ res@@ s ( ) ) ; f@@ actory . set@@ P@@ ro@@ v@@ id@@ er@@ s ( Array@@ s . < Object > as@@ List ( j@@ son@@ P@@ ro@@ vi@@ der ( ) ) ) ; return f@@ actory . cre@@ ate ( ) ; }
 public boolean ap@@ pl@@ y ( CmsHistoryResourceBean b@@ e@@ an ) { return b@@ e@@ an . get@@ V@@ er@@ sion ( ) . get@@ V@@ er@@ si@@ on@@ N@@ um@@ b@@ er ( ) != null ; }
 public Option@@ Builder fi@@ el@@ d@@ Name ( String fi@@ el@@ d@@ Name ) { this . fi@@ el@@ d@@ Name = fi@@ el@@ d@@ Name ; return this ; }
 public Option@@ Builder add@@ De@@ fa@@ ult@@ Value ( String de@@ fa@@ ult@@ Value ) { this . de@@ fa@@ ult@@ V@@ alu@@ es . add ( de@@ fa@@ ult@@ Value ) ; return this ; }
 public static void lo@@ ad@@ Con@@ fi@@ g ( P@@ ath fil@@ e , I@@ mm@@ ut@@ able@@ Set@@ t@@ ings . Builder set@@ t@@ ing@@ s@@ Builder ) { try { set@@ t@@ ing@@ s@@ Builder . lo@@ ad@@ F@@ ro@@ m@@ U@@ r@@ l ( fil@@ e . to@@ U@@ r@@ i ( ) . to@@ U@@ R@@ L ( ) ) ; } catch ( F@@ a@@ ile@@ d@@ T@@ o@@ Res@@ ol@@ ve@@ Con@@ fi@@ g@@ Exception | N@@ o@@ Cl@@ ass@@ De@@ f@@ F@@ o@@ und@@ E@@ r@@ ro@@ r | M@@ al@@ form@@ ed@@ U@@ R@@ L@@ Exception e ) { } }
 @ Override public boolean is@@ En@@ able@@ d ( int p@@ o@@ si@@ tion ) { return true ; }
 public Object un@@ mar@@ sh@@ al ( H@@ i@@ er@@ ar@@ ch@@ ic@@ al@@ St@@ re@@ am@@ Re@@ a@@ der rea@@ der , U@@ n@@ mar@@ sh@@ all@@ ing@@ Context context ) { B@@ ri@@ c@@ k@@ C@@ an@@ v@@ as c@@ an@@ v@@ as = B@@ ri@@ c@@ k@@ C@@ an@@ v@@ as . get@@ In@@ stan@@ c@@ e ( ) ; w@@ h@@ il@@ e ( rea@@ der . has@@ Mo@@ re@@ Ch@@ il@@ d@@ re@@ n ( ) ) { rea@@ der . m@@ o@@ ve@@ D@@ o@@ w@@ n ( ) ; if ( rea@@ der . get@@ N@@ o@@ de@@ Name ( ) . equals ( " c@@ an@@ v@@ as@@ B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e " ) ) { c@@ an@@ v@@ as . set@@ B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e ( ( B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e ) context . con@@ ver@@ t@@ A@@ no@@ ther ( rea@@ der , B@@ ack@@ g@@ ro@@ und@@ I@@ m@@ ag@@ e . cl@@ ass ) ) ; } if ( rea@@ der . get@@ N@@ o@@ de@@ Name ( ) . equals ( " b@@ ri@@ c@@ k@@ s@@ O@@ n@@ C@@ an@@ v@@ as " ) ) { w@@ h@@ il@@ e ( rea@@ der . has@@ Mo@@ re@@ Ch@@ il@@ d@@ re@@ n ( ) ) { rea@@ der . m@@ o@@ ve@@ D@@ o@@ w@@ n ( ) ; if ( rea@@ der . get@@ N@@ o@@ de@@ Name ( ) . equals ( B@@ ri@@ c@@ k . cl@@ ass . get@@ Name ( ) ) ) { c@@ an@@ v@@ as . get@@ L@@ ay@@ er ( ) . add@@ Ch@@ il@@ d ( ( B@@ ri@@ c@@ k ) context . con@@ ver@@ t@@ A@@ no@@ ther ( rea@@ der , B@@ ri@@ c@@ k . cl@@ ass ) ) ; } rea@@ der . m@@ o@@ ve@@ U@@ p ( ) ; } } rea@@ der . m@@ o@@ ve@@ U@@ p ( ) ; } return c@@ an@@ v@@ as ; }
 public boolean c@@ an@@ Con@@ ver@@ t ( Cl@@ ass type ) { return ( type == B@@ ri@@ c@@ k@@ C@@ an@@ v@@ as . cl@@ ass ) ; }
 @ Te@@ mp@@ l@@ ate ( " < s@@ p@@ an ▁ ti@@ t@@ le = \@@ " { 1 } \@@ " > { 0 } < / s@@ p@@ an > " ) S@@ a@@ f@@ e@@ H@@ t@@ m@@ l te@@ x@@ t@@ S@@ p@@ an@@ W@@ i@@ th@@ T@@ it@@ le ( String text , String ti@@ t@@ le ) ;
 public void te@@ st@@ M@@ er@@ g@@ e ( ) { List < String > a = Array@@ s . as@@ List ( " a " , " b " , " d " , " e " ) ; List < String > b = Array@@ s . as@@ List ( " b " , " c " , " d " , " e " ) ; Co@@ m@@ par@@ ator < String > co@@ m@@ par@@ ator = new Co@@ m@@ par@@ ator < String > ( ) { public int co@@ m@@ par@@ e ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . compareT@@ o ( o@@ 2 ) ; } } ; I@@ ter@@ ator < P@@ a@@ i@@ r < String , String > > i@@ ter = I@@ ter@@ able@@ s . m@@ er@@ g@@ e ( a , b , co@@ m@@ par@@ ator ) . i@@ ter@@ ator ( ) ; assertEquals ( i@@ ter . ne@@ xt ( ) , new P@@ a@@ i@@ r < String , String > ( " b " , " b " ) ) ; assertEquals ( i@@ ter . ne@@ xt ( ) , new P@@ a@@ i@@ r < String , String > ( " d " , " d " ) ) ; assertEquals ( i@@ ter . ne@@ xt ( ) , new P@@ a@@ i@@ r < String , String > ( " e " , " e " ) ) ; assertTrue ( ! i@@ ter . has@@ N@@ e@@ xt ( ) ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ ne@@ g@@ ati@@ v@@ e ▁ if ▁ this ▁ at@@ tribu@@ te ▁ h@@ as ▁ lo@@ w@@ er ▁ at@@ tribu@@ te ▁ type ▁ th@@ an ▁ ar@@ g@@ um@@ ent " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ N@@ e@@ g@@ ati@@ ve@@ I@@ f@@ Th@@ is@@ Attribu@@ te@@ Has@@ Lo@@ w@@ er@@ Attribu@@ te@@ T@@ yp@@ e@@ Th@@ an@@ Ar@@ g@@ um@@ ent ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 2 ) ) ; A@@ s@@ ser@@ t . assertTrue ( pa . compareT@@ o ( other ) < 0 ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ set ▁ vo@@ ide@@ d ▁ bi@@ t ▁ t@@ o ▁ true " , m@@ et@@ ho@@ d = " vo@@ id@@ Attribu@@ te ( String ) " ) public void vo@@ id@@ Attribu@@ te@@ _@@ shoul@@ d@@ Set@@ V@@ o@@ ide@@ d@@ B@@ it@@ T@@ o@@ True ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . set@@ V@@ o@@ ide@@ d ( false ) ; pa . vo@@ id@@ Attribu@@ te ( " B@@ ec@@ a@@ u@@ se " ) ; A@@ s@@ ser@@ t . assertTrue ( pa . is@@ V@@ o@@ ide@@ d ( ) ) ; }
 @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return historyRes . get@@ Mo@@ di@@ f@@ ic@@ ati@@ on@@ Date ( ) . get@@ D@@ ate@@ Te@@ xt ( ) ; }
 public void set@@ N@@ e@@ ed@@ User@@ names ( boolean value ) { ne@@ ed@@ User@@ names = value ; }
 @ S@@ up@@ p@@ res@@ sW@@ ar@@ n@@ ings ( " s@@ y@@ n@@ th@@ et@@ i@@ c - ac@@ c@@ es@@ s " ) public void ex@@ ec@@ u@@ te ( CmsHistoryResourceBean historyRes ) { m@@ _@@ h@@ and@@ l@@ er . re@@ ver@@ t ( historyRes ) ; }
 private void add@@ P@@ u@@ bli@@ sh@@ D@@ ate@@ Column ( ) { add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ P@@ u@@ bli@@ sh@@ Date ( ) , 1@@ 9@@ 0 , new T@@ ex@@ t@@ Column < CmsHistoryResourceBean > ( ) { @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { if ( historyRes . get@@ P@@ u@@ bli@@ sh@@ Date ( ) != null ) { return historyRes . get@@ P@@ u@@ bli@@ sh@@ Date ( ) . get@@ D@@ ate@@ Te@@ xt ( ) ; } return " - " ; } } ) ; }
 public static void con@@ fi@@ g@@ ur@@ e ( Set@@ t@@ ings set@@ t@@ ings ) { if ( lo@@ a@@ de@@ d ) { return ; } lo@@ a@@ de@@ d = true ; En@@ vi@@ r@@ on@@ m@@ ent en@@ vi@@ r@@ on@@ m@@ ent = new En@@ vi@@ r@@ on@@ m@@ ent ( set@@ t@@ ings ) ; I@@ mm@@ ut@@ able@@ Set@@ t@@ ings . Builder set@@ t@@ ing@@ s@@ Builder = set@@ t@@ ing@@ s@@ Builder ( ) . pu@@ t ( set@@ t@@ ings ) ; res@@ ol@@ ve@@ Con@@ fi@@ g ( en@@ vi@@ r@@ on@@ m@@ ent , set@@ t@@ ing@@ s@@ Builder ) ; set@@ t@@ ing@@ s@@ Builder . put@@ P@@ roperties ( " el@@ as@@ ti@@ c@@ sear@@ ch . " , Sy@@ s@@ tem . get@@ P@@ roperties ( ) ) . put@@ P@@ roperties ( " es . " , Sy@@ s@@ tem . get@@ P@@ roperties ( ) ) . re@@ pl@@ a@@ ce@@ P@@ roper@@ ty@@ Pl@@ a@@ ce@@ ho@@ l@@ d@@ er@@ s ( ) ; P@@ roperties p@@ rop@@ s = new P@@ roperties ( ) ; for ( Map . En@@ try < String , String > entry : set@@ t@@ ing@@ s@@ Builder . bu@@ il@@ d ( ) . get@@ A@@ s@@ Map ( ) . en@@ tr@@ y@@ Se@@ t ( ) ) { String key = " lo@@ g@@ 4@@ j . " + entry . get@@ K@@ ey ( ) ; String value = entry . get@@ Value ( ) ; if ( re@@ pl@@ a@@ ce@@ m@@ en@@ ts . con@@ ta@@ in@@ s@@ K@@ ey ( value ) ) { value = re@@ pl@@ a@@ ce@@ m@@ en@@ ts . get ( value ) ; } if ( key . end@@ sWith ( " . value " ) ) { p@@ rop@@ s . set@@ P@@ roper@@ ty ( key . substring ( 0 , key . length ( ) - " . value " . length ( ) ) , value ) ; } else if ( key . end@@ sWith ( " . type " ) ) { p@@ rop@@ s . set@@ P@@ roper@@ ty ( key . substring ( 0 , key . length ( ) - " . type " . length ( ) ) , value ) ; } else { p@@ rop@@ s . set@@ P@@ roper@@ ty ( key , value ) ; } } P@@ roper@@ ty@@ Con@@ fi@@ g@@ ur@@ ator . con@@ fi@@ g@@ ur@@ e ( p@@ rop@@ s ) ; }
 @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . get@@ Size ( ) ; }
 private void add@@ P@@ at@@ h@@ Column ( ) { Column < CmsHistoryResourceBean , ? > co@@ l = new T@@ ex@@ t@@ Column < CmsHistoryResourceBean > ( ) { @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { String path = historyRes . get@@ R@@ oo@@ t@@ P@@ ath ( ) ; String si@@ te@@ R@@ oo@@ t = Cms@@ Co@@ re@@ P@@ ro@@ vi@@ der . get ( ) . get@@ Si@@ te@@ R@@ oo@@ t ( ) ; if ( path . startsWith ( si@@ te@@ R@@ oo@@ t ) ) { path = path . substring ( si@@ te@@ R@@ oo@@ t . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; } } ; add@@ Column ( co@@ l , CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ P@@ ath ( ) ) ; set@@ Colum@@ n@@ W@@ id@@ t@@ h ( co@@ l , 1@@ 0@@ 0 , U@@ n@@ i@@ t . P@@ C@@ T ) ; }
 public void st@@ op@@ Tim@@ e ( ) throws IOException { fin@@ is@@ h@@ Tim@@ e@@ E@@ p@@ o@@ ch = Sy@@ s@@ tem . c@@ ur@@ re@@ n@@ t@@ Tim@@ e@@ M@@ il@@ li@@ s ( ) ; }
 @ Override public Object g@@ en@@ er@@ ate ( C@@ li@@ ent < ? > c@@ li@@ ent , String d@@ at@@ a@@ Type ) { final String g@@ en@@ er@@ ate@@ d@@ I@@ d = " Se@@ le@@ c@@ t ▁ no@@ w ( ) ▁ f@@ ro@@ m ▁ s@@ y@@ s@@ tem . s@@ ch@@ e@@ m@@ a _ co@@ lum@@ n@@ s " ; Result@@ Se@@ t r@@ Se@@ t = ( ( D@@ S@@ C@@ li@@ ent ) c@@ li@@ ent ) . ex@@ ec@@ u@@ te ( g@@ en@@ er@@ ate@@ d@@ I@@ d , null ) ; U@@ U@@ ID u@@ u@@ id = r@@ Se@@ t . i@@ ter@@ ator ( ) . ne@@ xt ( ) . get@@ U@@ U@@ ID ( 0 ) ; return u@@ u@@ id ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ ne@@ g@@ ati@@ v@@ e ▁ if ▁ other ▁ at@@ tribu@@ te ▁ h@@ as ▁ lo@@ w@@ er ▁ value " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ N@@ e@@ g@@ ati@@ ve@@ I@@ f@@ O@@ th@@ er@@ Attribu@@ te@@ Has@@ Lo@@ w@@ er@@ Value ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; pa . set@@ Value ( "@@ 2@@ " ) ; PersonAttribute other = new PersonAttribute ( ) ; other . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; other . set@@ Value ( "@@ 1@@ " ) ; A@@ s@@ ser@@ t . assertTrue ( pa . compareT@@ o ( other ) > 0 ) ; }
 public Option@@ Builder has@@ M@@ ul@@ ti@@ p@@ le@@ V@@ alu@@ es ( boolean has@@ M@@ ul@@ ti@@ p@@ le@@ V@@ alu@@ es ) { this . has@@ M@@ ul@@ ti@@ p@@ le@@ V@@ alu@@ es = has@@ M@@ ul@@ ti@@ p@@ le@@ V@@ alu@@ es ; return this ; }
 public int get@@ Result@@ St@@ art@@ P@@ o@@ si@@ tion ( ) { return res@@ ult@@ St@@ art@@ P@@ o@@ si@@ tion ; }
 @ Override public boolean is@@ E@@ mp@@ ty ( ) { if ( searchResult@@ User@@ names != null ) { return searchResult@@ User@@ names . is@@ E@@ mp@@ ty ( ) ; } else if ( searchResult@@ H@@ asht@@ ags != null ) { return searchResult@@ H@@ asht@@ ags . is@@ E@@ mp@@ ty ( ) ; } else if ( searchResultCommand@@ s != null ) { return searchResultCommand@@ s . is@@ E@@ mp@@ ty ( ) ; } return true ; }
 @ Test public void te@@ st@@ C@@ re@@ at@@ ing@@ Map ( ) { Map < String , List < SjukfallIntyg > > map = cre@@ ator . c@@ rea@@ te@@ Map ( intyg@@ Data@@ List , param@@ e@@ ters ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 7 ▁ bu@@ t ▁ w@@ as ▁ " + map . size ( ) , map . size ( ) == 7 ) ; }
 public Object get@@ K@@ ey ( CmsHistoryResourceBean item ) { return item . get@@ S@@ tr@@ u@@ c@@ t@@ u@@ re@@ I@@ d ( ) + " _ " + item . get@@ V@@ er@@ sion ( ) ; }
 public static b@@ y@@ te [ ] con@@ ver@@ t@@ Ob@@ jec@@ t@@ T@@ o@@ J@@ son@@ By@@ te@@ s ( Object ob@@ ject ) throws IOException { Ob@@ jec@@ t@@ M@@ ap@@ p@@ er ma@@ p@@ p@@ er = new Ob@@ jec@@ t@@ M@@ ap@@ p@@ er ( ) ; ma@@ p@@ p@@ er . set@@ S@@ eri@@ ali@@ z@@ ati@@ on@@ In@@ clu@@ sion ( J@@ son@@ In@@ clu@@ de . In@@ clu@@ de . N@@ ON@@ _@@ N@@ U@@ L@@ L ) ; J@@ o@@ d@@ a@@ Mo@@ d@@ ul@@ e m@@ o@@ d@@ ul@@ e = new J@@ o@@ d@@ a@@ Mo@@ d@@ ul@@ e ( ) ; D@@ ate@@ Tim@@ e@@ F@@ orm@@ at@@ ter@@ F@@ actory form@@ at@@ ter@@ F@@ actory = new D@@ ate@@ Tim@@ e@@ F@@ orm@@ at@@ ter@@ F@@ actory ( ) ; form@@ at@@ ter@@ F@@ actory . set@@ I@@ s@@ o ( D@@ ate@@ Tim@@ e@@ F@@ or@@ ma@@ t . I@@ S@@ O . D@@ A@@ T@@ E ) ; m@@ o@@ d@@ ul@@ e . add@@ S@@ eri@@ ali@@ z@@ er ( D@@ ate@@ Tim@@ e . cl@@ ass , new D@@ ate@@ Tim@@ e@@ S@@ eri@@ ali@@ z@@ er ( new J@@ ack@@ son@@ J@@ o@@ d@@ a@@ F@@ or@@ ma@@ t ( form@@ at@@ ter@@ F@@ actory . c@@ rea@@ te@@ D@@ ate@@ Tim@@ e@@ F@@ orm@@ at@@ ter ( ) . w@@ i@@ th@@ Z@@ on@@ e@@ U@@ T@@ C ( ) ) ) ) ; ma@@ p@@ p@@ er . re@@ g@@ is@@ ter@@ Mo@@ d@@ ul@@ e ( m@@ o@@ d@@ ul@@ e ) ; return ma@@ p@@ p@@ er . wri@@ te@@ V@@ alu@@ e@@ A@@ s@@ By@@ te@@ s ( ob@@ ject ) ; }
 public Option@@ Builder comp@@ le@@ ter ( Option@@ Co@@ mp@@ le@@ ter comp@@ le@@ ter ) { this . comp@@ le@@ ter = comp@@ le@@ ter ; return this ; }
 @ Override public boolean are@@ A@@ l@@ l@@ I@@ te@@ ms@@ En@@ able@@ d ( ) { return true ; }
 public Option@@ Builder type ( Cl@@ ass < ? > type ) { this . type = type ; return this ; }
 public Option@@ Builder d@@ es@@ cri@@ ption ( String d@@ es@@ cri@@ ption ) { this . d@@ es@@ cri@@ ption = d@@ es@@ cri@@ ption ; return this ; }
 @ Bean public P@@ e@@ op@@ le@@ S@@ er@@ vic@@ e p@@ e@@ op@@ le@@ S@@ er@@ vic@@ e ( ) { return new P@@ e@@ op@@ le@@ S@@ er@@ vic@@ e ( ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ s@@ ti@@ l@@ l ▁ lo@@ a@@ d ▁ cl@@ ass ▁ in ▁ f@@ or@@ ma@@ t ▁ p@@ roper@@ ty ▁ if ▁ no@@ t ▁ Attribu@@ t@@ able " , m@@ et@@ ho@@ d = " get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) " ) public void get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Ob@@ jec@@ t@@ _@@ shoul@@ d@@ S@@ ti@@ l@@ l@@ Lo@@ ad@@ Cl@@ ass@@ In@@ F@@ orm@@ at@@ P@@ roper@@ ty@@ I@@ f@@ N@@ ot@@ Attribu@@ t@@ able ( ) throws Exception { PersonAttribu@@ teType type = new PersonAttribu@@ teType ( ) ; type . set@@ F@@ or@@ ma@@ t ( " java . l@@ an@@ g . String " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . set@@ Attribu@@ teType ( type ) ; pa . set@@ Value ( " l@@ al@@ ap@@ al@@ oo@@ z@@ a " ) ; String value = ( String ) pa . get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) ; A@@ s@@ ser@@ t . assertEquals ( " l@@ al@@ ap@@ al@@ oo@@ z@@ a " , value ) ; }
 @ Test public void te@@ st@@ F@@ all@@ 3 ( ) { String key = "@@ 1@@ 9@@ 7@@ 9@@ 1@@ 2@@ 1@@ 2@@ -@@ 9@@ 2@@ 8@@ 0@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 3 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 01@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 2 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 5@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 @ Be@@ f@@ or@@ e public void set@@ U@@ p@@ P@@ lu@@ gin@@ In@@ f@@ r@@ as@@ tr@@ u@@ c@@ tur@@ e ( ) throws IOException { P@@ L@@ U@@ G@@ IN@@ _@@ D@@ I@@ R . m@@ k@@ di@@ r@@ s ( ) ; B@@ U@@ N@@ D@@ L@@ E_@@ D@@ I@@ R . m@@ k@@ di@@ r@@ s ( ) ; try { p@@ lu@@ gin@@ M@@ an@@ ag@@ er . start@@ In@@ f@@ r@@ as@@ tr@@ u@@ c@@ tur@@ e ( ) ; } catch ( Exception e ) { e . p@@ r@@ int@@ St@@ ack@@ Tr@@ ac@@ e ( ) ; } j@@ ar@@ Ch@@ an@@ ge@@ Lis@@ te@@ n@@ er . p@@ lu@@ gin@@ J@@ ar@@ A@@ d@@ de@@ d ( new P@@ lu@@ gin@@ File@@ D@@ et@@ a@@ il@@ s ( p@@ at@@ h@@ O@@ f@@ File@@ In@@ De@@ fa@@ ult@@ File@@ s ( " p@@ lu@@ g@@ in - w@@ ith - m@@ ul@@ ti@@ p@@ le - ex@@ te@@ n@@ si@@ on@@ s . j@@ a@@ r " ) , false ) ) ; }
 @ Test public static void m@@ e@@ g@@ am@@ or@@ p@@ h@@ ic@@ In@@ h@@ eri@@ te@@ d@@ G@@ l@@ ob@@ al@@ L@@ et@@ Test ( ) throws Script@@ Exception , In@@ ter@@ r@@ up@@ te@@ d@@ Exception { final N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory f@@ actory = new N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory ( ) ; final Script@@ En@@ gin@@ e e = f@@ actory . get@@ Script@@ En@@ gin@@ e ( L@@ A@@ N@@ G@@ U@@ A@@ G@@ E_@@ E@@ S@@ 6 ) ; final String shared@@ G@@ et@@ ter@@ Script = " foo " ; final String shared@@ Set@@ ter@@ Script = " foo ▁ = ▁ 1@@ " ; for ( int i = 0 ; i < M@@ E@@ G@@ A@@ M@@ O@@ R@@ P@@ H@@ I@@ C@@ _@@ L@@ O@@ O@@ P@@ _@@ C@@ O@@ U@@ N@@ T ; i ++ ) { assertEquals ( e . eval ( shared@@ Set@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( " d@@ el@@ et@@ e ▁ foo ; ▁ a " + i + " ▁ = ▁ 1 ; ▁ Object . p@@ ro@@ to@@ type . foo ▁ = ▁ " + i + " ; " ) , i ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , i ) ; } assertEquals ( e . eval ( " le@@ t ▁ foo ▁ = ▁ ' foo ' ; " ) , null ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , " foo " ) ; assertEquals ( e . eval ( shared@@ Set@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( shared@@ G@@ et@@ ter@@ Script ) , 1 ) ; assertEquals ( e . eval ( " this . foo " ) , M@@ E@@ G@@ A@@ M@@ O@@ R@@ P@@ H@@ I@@ C@@ _@@ L@@ O@@ O@@ P@@ _@@ C@@ O@@ U@@ N@@ T - 1 ) ; }
 @ A@@ f@@ ter public void te@@ ar@@ D@@ o@@ w@@ n ( ) throws Exception { Sy@@ s@@ tem . c@@ le@@ ar@@ P@@ roper@@ ty ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ E@@ S@@ C@@ _@@ P@@ R@@ O@@ P@@ ER@@ T@@ Y@@ _@@ S@@ E@@ T@@ _@@ B@@ Y@@ _@@ P@@ L@@ U@@ G@@ IN@@ _@@ E@@ X@@ T@@ _@@ 1 ) ; Sy@@ s@@ tem . c@@ le@@ ar@@ P@@ roper@@ ty ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ E@@ S@@ C@@ _@@ P@@ R@@ O@@ P@@ ER@@ T@@ Y@@ _@@ S@@ E@@ T@@ _@@ B@@ Y@@ _@@ P@@ L@@ U@@ G@@ IN@@ _@@ E@@ X@@ T@@ _@@ 2 ) ; File@@ U@@ ti@@ l@@ s . de@@ le@@ te@@ Q@@ u@@ i@@ et@@ l@@ y ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ I@@ R ) ; File@@ U@@ ti@@ l@@ s . de@@ le@@ te@@ Q@@ u@@ i@@ et@@ l@@ y ( B@@ U@@ N@@ D@@ L@@ E_@@ D@@ I@@ R ) ; p@@ lu@@ gin@@ M@@ an@@ ag@@ er . st@@ op@@ In@@ f@@ r@@ as@@ tr@@ u@@ c@@ tur@@ e ( ) ; File@@ U@@ ti@@ l@@ s . de@@ le@@ te@@ Q@@ u@@ i@@ et@@ l@@ y ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ I@@ R ) ; File@@ U@@ ti@@ l@@ s . de@@ le@@ te@@ Q@@ u@@ i@@ et@@ l@@ y ( B@@ U@@ N@@ D@@ L@@ E_@@ D@@ I@@ R ) ; }
 public boolean is@@ B@@ ot@@ Command@@ s ( ) { return searchResultCommand@@ s != null ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ ne@@ g@@ ati@@ v@@ e ▁ if ▁ other ▁ at@@ tribu@@ te ▁ h@@ as ▁ e@@ ar@@ li@@ er ▁ d@@ ate ▁ c@@ rea@@ ted " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ N@@ e@@ g@@ ati@@ ve@@ I@@ f@@ O@@ th@@ er@@ Attribu@@ te@@ Has@@ E@@ ar@@ li@@ er@@ D@@ ate@@ C@@ rea@@ ted ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; pa . set@@ D@@ ate@@ C@@ rea@@ ted ( new Date ( ) ) ; PersonAttribute other = new PersonAttribute ( ) ; pa . set@@ D@@ ate@@ C@@ rea@@ ted ( new Date ( pa . get@@ D@@ ate@@ C@@ rea@@ ted ( ) . get@@ Tim@@ e ( ) - 1@@ 0@@ 0@@ 0 ) ) ; A@@ s@@ ser@@ t . assertTrue ( pa . compareT@@ o ( other ) < 0 ) ; }
 public Option@@ Builder con@@ ver@@ ter ( Cl@@ ass < ? ex@@ te@@ n@@ d@@ s C@@ L@@ Con@@ ver@@ ter > con@@ ver@@ ter ) { this . con@@ ver@@ ter = con@@ ver@@ ter ; return this ; }
 public String get@@ C@@ it@@ y@@ _@@ co@@ de ( ) { return c@@ it@@ y@@ _@@ co@@ de ; }
 public void start@@ Tim@@ e ( ) throws IOException { start@@ Tim@@ e@@ E@@ p@@ o@@ ch = Sy@@ s@@ tem . c@@ ur@@ re@@ n@@ t@@ Tim@@ e@@ M@@ il@@ li@@ s ( ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ lo@@ a@@ d ▁ cl@@ ass ▁ in ▁ f@@ or@@ ma@@ t ▁ p@@ roper@@ ty " , m@@ et@@ ho@@ d = " get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) " ) public void get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Ob@@ jec@@ t@@ _@@ shoul@@ d@@ Lo@@ ad@@ Cl@@ ass@@ In@@ F@@ orm@@ at@@ P@@ roper@@ ty ( ) throws Exception { PersonAttribu@@ teType type = new PersonAttribu@@ teType ( ) ; type . set@@ F@@ or@@ ma@@ t ( " or@@ g . open@@ m@@ r@@ s . Con@@ ce@@ p@@ t " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . set@@ Attribu@@ teType ( type ) ; pa . set@@ Value ( "@@ 5@@ 0@@ 8@@ 9@@ " ) ; Con@@ ce@@ p@@ t con@@ ce@@ p@@ t = ( Con@@ ce@@ p@@ t ) pa . get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) ; A@@ s@@ ser@@ t . assertEquals ( 5@@ 0@@ 8@@ 9 , con@@ ce@@ p@@ t . get@@ Con@@ ce@@ p@@ t@@ I@@ d ( ) . int@@ Value ( ) ) ; }
 public void te@@ st@@ Group ( ) { String [ ] in@@ pu@@ t = new String [ ] { "@@ 0 ▁ a@@ b " , "@@ 0 ▁ b@@ b " , "@@ 0 ▁ c@@ c " , "@@ 1 ▁ d@@ d " , "@@ 2 ▁ d@@ d " , "@@ 2 ▁ k@@ j " , "@@ 3 ▁ k@@ j " , "@@ 3 ▁ k@@ k " } ; int [ ] co@@ un@@ ts = new int [ ] { 3 , 1 , 2 , 2 } ; Co@@ m@@ par@@ ator < String > fi@@ el@@ d@@ O@@ n@@ e = new Co@@ m@@ par@@ ator < String > ( ) { public int co@@ m@@ par@@ e ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . s@@ p@@ li@@ t ( " ▁ " ) [ 0 ] . compareT@@ o ( o@@ 2 . s@@ p@@ li@@ t ( " ▁ " ) [ 0 ] ) ; } } ; int in@@ de@@ x = 0 ; int g@@ rou@@ p = 0 ; for ( I@@ ter@@ able < String > set : I@@ ter@@ able@@ s . g@@ rou@@ p ( Array@@ s . as@@ List ( in@@ pu@@ t ) , fi@@ el@@ d@@ O@@ n@@ e ) ) { String shared@@ K@@ ey = null ; int th@@ is@@ Co@@ unt = 0 ; for ( String l@@ in@@ e : set ) { String th@@ is@@ K@@ ey = l@@ in@@ e . s@@ p@@ li@@ t ( " ▁ " ) [ 0 ] ; if ( shared@@ K@@ ey == null ) { shared@@ K@@ ey = th@@ is@@ K@@ ey ; } else { assertEquals ( " W@@ r@@ ong ▁ key " , shared@@ K@@ ey , th@@ is@@ K@@ ey ) ; } assertEquals ( " W@@ r@@ ong ▁ in@@ pu@@ t ▁ l@@ in@@ e " , l@@ in@@ e , in@@ pu@@ t [ in@@ de@@ x ++ ] ) ; th@@ is@@ Co@@ unt ++ ; } assertEquals ( " W@@ r@@ ong ▁ n@@ um@@ b@@ er ▁ of ▁ i@@ tem@@ s ▁ in ▁ this ▁ i@@ ter@@ ator " , co@@ un@@ ts [ g@@ rou@@ p ++ ] , th@@ is@@ Co@@ unt ) ; } assertEquals ( " D@@ id@@ n ' t ▁ get ▁ al@@ l ▁ in@@ put@@ s " , in@@ pu@@ t . length , in@@ de@@ x ) ; assertEquals ( " W@@ r@@ ong ▁ n@@ um@@ b@@ er ▁ of ▁ g@@ rou@@ p@@ s " , co@@ un@@ ts . length , g@@ rou@@ p ) ; }
 @ S@@ up@@ p@@ res@@ sW@@ ar@@ n@@ ings ( " s@@ y@@ n@@ th@@ et@@ i@@ c - ac@@ c@@ es@@ s " ) public void ex@@ ec@@ u@@ te ( CmsHistoryResourceBean historyRes ) { m@@ _@@ h@@ and@@ l@@ er . sho@@ w@@ P@@ re@@ vie@@ w ( historyRes ) ; }
 @ Override public void c@@ le@@ ar@@ R@@ ec@@ en@@ t@@ H@@ asht@@ ags ( ) { s@@ up@@ er . c@@ le@@ ar@@ R@@ ec@@ en@@ t@@ H@@ asht@@ ags ( ) ; searchResult@@ H@@ asht@@ ags . c@@ le@@ a@@ r ( ) ; no@@ ti@@ f@@ y@@ Data@@ Set@@ Ch@@ an@@ ge@@ d ( ) ; if ( de@@ leg@@ ate != null ) { de@@ leg@@ ate . ne@@ ed@@ Ch@@ an@@ ge@@ P@@ an@@ el@@ V@@ is@@ i@@ bi@@ li@@ ty ( false ) ; } }
 public void te@@ st@@ Fil@@ ter ( ) { List < String > v@@ alu@@ es = Array@@ s . as@@ List ( " a " , " H@@ I " , " t@@ H@@ er@@ e " , " Y@@ O " ) ; I@@ ter@@ ator < String > i@@ ter@@ ator = I@@ ter@@ able@@ s . fil@@ ter ( v@@ alu@@ es , new F@@ un@@ ction < String , B@@ oolean > ( ) { public B@@ oolean ap@@ pl@@ y ( String in ) { return in . equals ( in . to@@ U@@ p@@ p@@ er@@ C@@ ase ( ) ) ; } } ) . i@@ ter@@ ator ( ) ; assertTrue ( i@@ ter@@ ator . has@@ N@@ e@@ xt ( ) ) ; assertEquals ( i@@ ter@@ ator . ne@@ xt ( ) , " H@@ I " ) ; assertEquals ( i@@ ter@@ ator . ne@@ xt ( ) , " Y@@ O " ) ; assert@@ F@@ al@@ se ( i@@ ter@@ ator . has@@ N@@ e@@ xt ( ) ) ; }
 public long get@@ In@@ ter@@ v@@ al@@ M@@ il@@ li@@ s ( ) throws IOException { return fin@@ is@@ h@@ Tim@@ e@@ E@@ p@@ o@@ ch - start@@ Tim@@ e@@ E@@ p@@ o@@ ch ; }
 public String form@@ at@@ Tim@@ e ( long m@@ il@@ li@@ s ) { return form@@ at@@ ter . f@@ or@@ ma@@ t ( m@@ il@@ li@@ s ) ; }
 public boolean ap@@ pl@@ y ( CmsHistoryResourceBean b@@ e@@ an ) { return true ; }
 @ Test public void te@@ st@@ S@@ or@@ te@@ d@@ Map ( ) { Map < String , List < SjukfallIntyg > > map = cre@@ ator . c@@ rea@@ te@@ Map ( intyg@@ Data@@ List , param@@ e@@ ters ) ; Map < String , List < SjukfallIntyg > > s@@ or@@ te@@ d@@ Map = cre@@ ator . s@@ or@@ t@@ V@@ alu@@ es ( map ) ; for ( Map . En@@ try < String , List < SjukfallIntyg > > entry : s@@ or@@ te@@ d@@ Map . en@@ tr@@ y@@ Se@@ t ( ) ) { if ( entry . get@@ Value ( ) . size ( ) > 1 ) { SjukfallIntyg [ ] ar@@ r = entry . get@@ Value ( ) . to@@ Arr@@ a@@ y ( new SjukfallIntyg [ entry . get@@ Value ( ) . size ( ) ] ) ; for ( int i = 0 ; i < ar@@ r . length - 1 ; i ++ ) { assertTrue ( ar@@ r [ i ] . get@@ S@@ lu@@ t@@ Dat@@ um ( ) . is@@ Be@@ f@@ or@@ e ( ar@@ r [ i + 1 ] . get@@ S@@ lu@@ t@@ Dat@@ um ( ) ) ) ; } } } }
 @ Override public int get@@ View@@ T@@ yp@@ e@@ Co@@ unt ( ) { return 1 ; }
 @ Override public int get@@ Co@@ unt ( ) { if ( searchResult@@ User@@ names != null ) { return searchResult@@ User@@ names . size ( ) ; } else if ( searchResult@@ H@@ asht@@ ags != null ) { return searchResult@@ H@@ asht@@ ags . size ( ) ; } else if ( searchResultCommand@@ s != null ) { return searchResultCommand@@ s . size ( ) ; } return 0 ; }
 public void te@@ st@@ Tr@@ an@@ s@@ f@@ or@@ m ( ) { List < Integer > v@@ alu@@ es = Array@@ s . as@@ List ( 1 , 2 , 3 , 4 ) ; List < Integer > s@@ qu@@ are@@ s = Array@@ s . as@@ List ( 1 , 4 , 9 , 1@@ 6 ) ; F@@ un@@ ction < Integer , Integer > s@@ qu@@ are@@ r = new F@@ un@@ ction < Integer , Integer > ( ) { public Integer ap@@ pl@@ y ( Integer in ) { return in * in ; } } ; for ( P@@ a@@ i@@ r < Integer , Integer > p@@ a@@ i@@ r : I@@ ter@@ able@@ s . z@@ i@@ p ( I@@ ter@@ able@@ s . tr@@ an@@ s@@ f@@ or@@ m ( v@@ alu@@ es , s@@ qu@@ are@@ r ) , s@@ qu@@ are@@ s ) ) { assertEquals ( p@@ a@@ i@@ r . fi@@ r@@ st , p@@ a@@ i@@ r . se@@ con@@ d ) ; } }
 @ S@@ up@@ p@@ res@@ sW@@ ar@@ n@@ ings ( " un@@ ch@@ ec@@ k@@ ed " ) public void te@@ st@@ Ch@@ a@@ in ( ) { List < String > s@@ 1 = Array@@ s . as@@ List ( new String [ ] { " h@@ i " , " th@@ er@@ e " } ) ; List < String > s@@ 2 = Array@@ s . as@@ List ( new String [ ] { } ) ; List < String > s@@ 3 = Array@@ s . as@@ List ( new String [ ] { " y@@ o@@ o " } ) ; List < String > s@@ 4 = Array@@ s . as@@ List ( new String [ ] { } ) ; List < String > an@@ s@@ w@@ er = Array@@ s . as@@ List ( new String [ ] { " y@@ o@@ o " , " h@@ i " , " th@@ er@@ e " , " y@@ o@@ o " } ) ; List < String > ch@@ a@@ in@@ ed = new ArrayList < String > ( ) ; for ( String s : I@@ ter@@ able@@ s . ch@@ a@@ in ( s@@ 3 , s@@ 1 , s@@ 2 , s@@ 3 , s@@ 4 ) ) { ch@@ a@@ in@@ ed . add ( s ) ; } assertEquals ( an@@ s@@ w@@ er , ch@@ a@@ in@@ ed ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ ne@@ g@@ ati@@ v@@ e ▁ if ▁ this ▁ at@@ tribu@@ te ▁ h@@ as ▁ lo@@ w@@ er ▁ at@@ tribu@@ te ▁ id ▁ th@@ an ▁ ar@@ g@@ um@@ ent " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ N@@ e@@ g@@ ati@@ ve@@ I@@ f@@ Th@@ is@@ Attribu@@ te@@ Has@@ Lo@@ w@@ er@@ Attribu@@ te@@ I@@ d@@ Th@@ an@@ Ar@@ g@@ um@@ ent ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( 1 ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( 2 ) ; other . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; A@@ s@@ ser@@ t . assertTrue ( pa . compareT@@ o ( other ) < 0 ) ; }
 public Option@@ Builder ar@@ g@@ um@@ ent ( String ar@@ g@@ um@@ ent ) { this . ar@@ g@@ um@@ ent = ar@@ g@@ um@@ ent ; return this ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ lo@@ a@@ d ▁ u@@ ser ▁ cl@@ ass ▁ in ▁ f@@ or@@ ma@@ t ▁ p@@ roper@@ ty " , m@@ et@@ ho@@ d = " get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) " ) public void get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Ob@@ jec@@ t@@ _@@ shoul@@ d@@ Lo@@ ad@@ User@@ Cl@@ ass@@ In@@ F@@ orm@@ at@@ P@@ roper@@ ty ( ) throws Exception { PersonAttribu@@ teType type = new PersonAttribu@@ teType ( ) ; type . set@@ F@@ or@@ ma@@ t ( " or@@ g . open@@ m@@ r@@ s . U@@ ser " ) ; PersonAttribute pa = new PersonAttribute ( 2 ) ; pa . set@@ Attribu@@ teType ( type ) ; pa . set@@ Value ( "@@ 1@@ " ) ; Object value = pa . get@@ H@@ y@@ d@@ r@@ ate@@ d@@ Object ( ) ; A@@ s@@ ser@@ t . assertTrue ( " shoul@@ d ▁ lo@@ a@@ d ▁ u@@ ser ▁ cl@@ ass ▁ in ▁ f@@ or@@ ma@@ t ▁ p@@ roper@@ ty " , ( value in@@ stan@@ ce@@ of U@@ ser ) ) ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ ne@@ g@@ ati@@ v@@ e ▁ if ▁ other ▁ at@@ tribu@@ te ▁ is ▁ vo@@ ide@@ d " , m@@ et@@ ho@@ d = " compareT@@ o ( PersonAttribute ) " ) public void compareT@@ o@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ N@@ e@@ g@@ ati@@ ve@@ I@@ f@@ O@@ th@@ er@@ Attribu@@ te@@ I@@ s@@ V@@ o@@ ide@@ d ( ) throws Exception { PersonAttribute pa = new PersonAttribute ( ) ; pa . set@@ Attribu@@ teType ( new PersonAttribu@@ teType ( 1 ) ) ; PersonAttribute other = new PersonAttribute ( ) ; other . set@@ V@@ o@@ ide@@ d ( true ) ; A@@ s@@ ser@@ t . assertTrue ( pa . compareT@@ o ( other ) < 0 ) ; }
 public ArrayList < T@@ as@@ k@@ At@@ te@@ mp@@ t@@ In@@ fo > get@@ T@@ as@@ k@@ At@@ te@@ mp@@ ts ( ) { return t@@ as@@ k@@ At@@ te@@ mp@@ t ; }
 @ Bean public J@@ ack@@ son@@ J@@ son@@ P@@ ro@@ vi@@ der j@@ son@@ P@@ ro@@ vi@@ der ( ) { return new J@@ ack@@ son@@ J@@ son@@ P@@ ro@@ vi@@ der ( ) ; }
 @ Test public void te@@ st@@ F@@ all@@ 1 ( ) { String key = "@@ 1@@ 9@@ 7@@ 9@@ 1@@ 1@@ 1@@ 0@@ -@@ 9@@ 2@@ 9@@ 1@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 2 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 01@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 1 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 0@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 private void add@@ Mo@@ di@@ f@@ ic@@ ati@@ on@@ D@@ ate@@ Column ( ) { add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ Mo@@ di@@ f@@ ic@@ ati@@ on@@ Date ( ) , 1@@ 9@@ 0 , new T@@ ex@@ t@@ Column < CmsHistoryResourceBean > ( ) { @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return historyRes . get@@ Mo@@ di@@ f@@ ic@@ ati@@ on@@ Date ( ) . get@@ D@@ ate@@ Te@@ xt ( ) ; } } ) ; }
 static void P@@ r@@ int@@ H@@ el@@ p ( ) { Sy@@ s@@ tem . o@@ u@@ t . p@@ r@@ int@@ l@@ n ( " \n U@@ sag@@ e : ▁ ▁ L@@ Z@@ M@@ A ▁ < e | d > ▁ [ < s@@ w@@ it@@ ch@@ es > . . . ] ▁ in@@ put@@ File ▁ out@@ put@@ File \n " + " ▁ ▁ e : ▁ en@@ co@@ de ▁ fil@@ e \n " + " ▁ ▁ d : ▁ de@@ co@@ de ▁ fil@@ e \n " + " ▁ ▁ b : ▁ B@@ en@@ ch@@ mar@@ k \n " + " < S@@ w@@ it@@ ch@@ es > \n " + " ▁ ▁ - d { N } : ▁ ▁ set ▁ d@@ ic@@ tion@@ ar@@ y ▁ - ▁ [ 0@@ ,@@ 2@@ 8 ] , ▁ de@@ fa@@ ult : ▁ 2@@ 3 ▁ ( 8@@ M@@ B ) \n " + " ▁ ▁ - f@@ b { N } : ▁ set ▁ n@@ um@@ b@@ er ▁ of ▁ f@@ as@@ t ▁ b@@ y@@ te@@ s ▁ - ▁ [ 5 , ▁ 2@@ 7@@ 3 ] , ▁ de@@ fa@@ ult : ▁ 1@@ 2@@ 8 \n " + " ▁ ▁ - l@@ c { N } : ▁ set ▁ n@@ um@@ b@@ er ▁ of ▁ li@@ ter@@ al ▁ context ▁ b@@ it@@ s ▁ - ▁ [ 0 , ▁ 8 ] , ▁ de@@ fa@@ ult : ▁ 3 \n " + " ▁ ▁ - l@@ p { N } : ▁ set ▁ n@@ um@@ b@@ er ▁ of ▁ li@@ ter@@ al ▁ p@@ os ▁ b@@ it@@ s ▁ - ▁ [ 0 , ▁ 4 ] , ▁ de@@ fa@@ ult : ▁ 0 \n " + " ▁ ▁ - p@@ b { N } : ▁ set ▁ n@@ um@@ b@@ er ▁ of ▁ p@@ os ▁ b@@ it@@ s ▁ - ▁ [ 0 , ▁ 4 ] , ▁ de@@ fa@@ ult : ▁ 2 \n " + " ▁ ▁ - m@@ f { M@@ F _ ID } : ▁ set ▁ M@@ atch ▁ F@@ in@@ der : ▁ [ b@@ t@@ 2 , ▁ b@@ t@@ 4 ] , ▁ de@@ fa@@ ult : ▁ b@@ t@@ 4 \n " + " ▁ ▁ - e@@ os : ▁ ▁ ▁ wri@@ te ▁ En@@ d ▁ O@@ f ▁ Stream ▁ mar@@ k@@ er \n " ) ; }
 public Option@@ Builder has@@ Value ( boolean has@@ Value ) { this . has@@ Value = has@@ Value ; return this ; }
 @ Override public Object get@@ Item ( int i ) { if ( searchResult@@ User@@ names != null ) { if ( i < 0 || i >@@ = searchResult@@ User@@ names . size ( ) ) { return null ; } return searchResult@@ User@@ names . get ( i ) ; } else if ( searchResult@@ H@@ asht@@ ags != null ) { if ( i < 0 || i >@@ = searchResult@@ H@@ asht@@ ags . size ( ) ) { return null ; } return searchResult@@ H@@ asht@@ ags . get ( i ) ; } else if ( searchResultCommand@@ s != null ) { if ( i < 0 || i >@@ = searchResultCommand@@ s . size ( ) ) { return null ; } if ( searchResultCommand@@ s@@ User@@ s != null && b@@ ot@@ s@@ Co@@ unt != 1 ) { return String . f@@ or@@ ma@@ t ( " % s @ % s " , searchResultCommand@@ s . get ( i ) , searchResultCommand@@ s@@ User@@ s . get ( i ) . u@@ ser@@ name ) ; } return searchResultCommand@@ s . get ( i ) ; } return null ; }
 public void set@@ C@@ it@@ y@@ _@@ name ( String c@@ it@@ y@@ _@@ name ) { this . c@@ it@@ y@@ _@@ name = c@@ it@@ y@@ _@@ name ; }
 public Option@@ Builder name ( String name ) { this . name = name ; return this ; }
 @ Test @ V@@ eri@@ fi@@ es ( value = " shoul@@ d ▁ return ▁ to@@ String ▁ of ▁ h@@ y@@ d@@ r@@ ate@@ d ▁ value " , m@@ et@@ ho@@ d = " to@@ String ( ) " ) public void to@@ S@@ tr@@ ing@@ _@@ shoul@@ d@@ R@@ et@@ ur@@ n@@ T@@ o@@ S@@ tr@@ ing@@ O@@ f@@ H@@ y@@ d@@ r@@ ate@@ d@@ Value ( ) throws Exception { PersonAttribu@@ teType type = Context . get@@ Person@@ S@@ er@@ vic@@ e ( ) . get@@ PersonAttribu@@ teType ( 8 ) ; PersonAttribute at@@ t@@ r = new PersonAttribute ( type , "@@ 6@@ " ) ; A@@ s@@ ser@@ t . assertEquals ( " M@@ A@@ R@@ R@@ I@@ E@@ D " , at@@ t@@ r . to@@ String ( ) ) ; }
 @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return historyRes . get@@ User@@ L@@ ast@@ Mo@@ di@@ f@@ ie@@ d ( ) ; }
 @ Override public void r@@ u@@ n ( ) { try { for ( int i = 0 ; i < i@@ ter@@ ati@@ on@@ s ; i ++ ) { assertEquals ( en@@ gin@@ e . eval ( s@@ our@@ c@@ e , context ) , ex@@ p@@ ec@@ ted ) ; } } catch ( final Script@@ Exception se ) { throw new R@@ un@@ ti@@ m@@ e@@ Exception ( se ) ; } }
 @ Override public int co@@ m@@ par@@ e ( T@@ L@@ R@@ P@@ C . U@@ ser l@@ h@@ s , T@@ L@@ R@@ P@@ C . U@@ ser r@@ h@@ s ) { int l@@ hsNum = u@@ ser@@ s . in@@ de@@ x@@ O@@ f ( l@@ h@@ s . id ) ; int r@@ hsNum = u@@ ser@@ s . in@@ de@@ x@@ O@@ f ( r@@ h@@ s . id ) ; if ( l@@ hsNum != - 1 && r@@ hsNum != - 1 ) { return l@@ hsNum < r@@ hsNum ? - 1 : ( l@@ hsNum == r@@ hsNum ? 0 : 1 ) ; } else if ( l@@ hsNum != - 1 && r@@ hsNum == - 1 ) { return - 1 ; } else if ( l@@ hsNum == - 1 && r@@ hsNum != - 1 ) { return 1 ; } return 0 ; }
 @ Override public void cl@@ o@@ se ( ) { try { bi@@ gt@@ able@@ Result@@ S@@ c@@ an@@ n@@ er . cl@@ o@@ se ( ) ; } catch ( IOException i@@ o@@ e ) { throw Th@@ ro@@ w@@ able@@ s . p@@ rop@@ ag@@ ate ( i@@ o@@ e ) ; } }
 @ Override public int get@@ Item@@ View@@ Type ( int p@@ o@@ si@@ tion ) { return 0 ; }
 @ Bean public J@@ a@@ x@@ R@@ s@@ A@@ p@@ i@@ A@@ p@@ p@@ li@@ c@@ ati@@ on j@@ a@@ x@@ R@@ s@@ A@@ p@@ i@@ A@@ p@@ p@@ li@@ c@@ ati@@ on ( ) { return new J@@ a@@ x@@ R@@ s@@ A@@ p@@ i@@ A@@ p@@ p@@ li@@ c@@ ati@@ on ( ) ; }
 public Result@@ S@@ c@@ an@@ n@@ er ad@@ ap@@ t ( final co@@ m . g@@ oo@@ g@@ le . cl@@ o@@ u@@ d . bi@@ gt@@ able . g@@ r@@ p@@ c . s@@ c@@ an@@ n@@ er . Result@@ S@@ c@@ an@@ n@@ er < R@@ o@@ w > bi@@ gt@@ able@@ Result@@ S@@ c@@ an@@ n@@ er ) { return new A@@ b@@ str@@ ac@@ t@@ C@@ li@@ en@@ t@@ S@@ c@@ an@@ n@@ er ( ) { @ Override public Res@@ ult ne@@ xt ( ) throws IOException { R@@ o@@ w ro@@ w = bi@@ gt@@ able@@ Result@@ S@@ c@@ an@@ n@@ er . ne@@ xt ( ) ; if ( ro@@ w == null ) { return null ; } return ro@@ w@@ A@@ d@@ ap@@ ter . ad@@ ap@@ t@@ Res@@ p@@ on@@ se ( ro@@ w ) ; } @ Override public void cl@@ o@@ se ( ) { try { bi@@ gt@@ able@@ Result@@ S@@ c@@ an@@ n@@ er . cl@@ o@@ se ( ) ; } catch ( IOException i@@ o@@ e ) { throw Th@@ ro@@ w@@ able@@ s . p@@ rop@@ ag@@ ate ( i@@ o@@ e ) ; } } } ; }
 @ Test public void te@@ st@@ F@@ all@@ 6 ( ) { String key = "@@ 1@@ 9@@ 8@@ 0@@ 0@@ 2@@ 0@@ 7@@ -@@ 9@@ 2@@ 9@@ 4@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 2 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 1@@ 2@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 1 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 5@@ " ) ; assert@@ F@@ al@@ se ( list . get ( 0 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 @ Bean public P@@ e@@ op@@ le@@ Res@@ t@@ S@@ er@@ vic@@ e p@@ e@@ op@@ le@@ Res@@ t@@ S@@ er@@ vic@@ e ( ) { return new P@@ e@@ op@@ le@@ Res@@ t@@ S@@ er@@ vic@@ e ( ) ; }
 public int co@@ m@@ par@@ e ( String o@@ 1 , String o@@ 2 ) { return o@@ 1 . s@@ p@@ li@@ t ( " ▁ " ) [ 0 ] . compareT@@ o ( o@@ 2 . s@@ p@@ li@@ t ( " ▁ " ) [ 0 ] ) ; }
 private static void assert@@ En@@ d@@ Date ( SjukfallIntyg intyg@@ s@@ Dat@@ a , String d@@ at@@ um ) { assertTrue ( intyg@@ s@@ Dat@@ a . get@@ S@@ lu@@ t@@ Dat@@ um ( ) . equals ( Lo@@ c@@ al@@ Date . par@@ se ( d@@ at@@ um ) ) ) ; }
 @ Override public Res@@ ult ne@@ xt ( ) throws IOException { R@@ o@@ w ro@@ w = bi@@ gt@@ able@@ Result@@ S@@ c@@ an@@ n@@ er . ne@@ xt ( ) ; if ( ro@@ w == null ) { return null ; } return ro@@ w@@ A@@ d@@ ap@@ ter . ad@@ ap@@ t@@ Res@@ p@@ on@@ se ( ro@@ w ) ; }
 public String get@@ In@@ ter@@ v@@ al@@ String ( ) throws IOException { long ti@@ m@@ e = get@@ In@@ ter@@ v@@ al@@ M@@ il@@ li@@ s ( ) ; return form@@ at@@ Tim@@ e ( ti@@ m@@ e ) ; }
 private void add@@ Si@@ z@@ e@@ Column ( ) { Column < CmsHistoryResourceBean , ? > co@@ l = new T@@ ex@@ t@@ Column < CmsHistoryResourceBean > ( ) { @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return " " + historyRes . get@@ Size ( ) ; } } ; add@@ Column ( co@@ l , CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ Size ( ) ) ; set@@ Colum@@ n@@ W@@ id@@ t@@ h ( co@@ l , 1@@ 0@@ 0 , U@@ n@@ i@@ t . P@@ X ) ; }
 @ Test public void te@@ st@@ F@@ all@@ 4 ( ) { String key = "@@ 1@@ 9@@ 8@@ 0@@ 01@@ 1@@ 3@@ -@@ 9@@ 2@@ 9@@ 7@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 3 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 3 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 01@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 2 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 5@@ " ) ; assertTrue ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 public static String c@@ an@@ on@@ ic@@ ali@@ ze ( final String path ) { int state = S@@ T@@ A@@ R@@ T ; for ( int i = path . length ( ) - 1 ; i >@@ = 0 ; -@@ - i ) { final ch@@ a@@ r c = path . ch@@ ar@@ A@@ t ( i ) ; s@@ w@@ it@@ ch ( c ) { c@@ ase ' / ' : if ( state == F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ) { return re@@ al@@ C@@ an@@ on@@ ic@@ ali@@ ze ( path , i + 1 , F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ) ; } else if ( state == ON@@ E_@@ D@@ O@@ T ) { return re@@ al@@ C@@ an@@ on@@ ic@@ ali@@ ze ( path , i + 2 , F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ) ; } else if ( state == T@@ W@@ O@@ _@@ D@@ O@@ T ) { return re@@ al@@ C@@ an@@ on@@ ic@@ ali@@ ze ( path , i + 3 , F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ) ; } state = F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ; b@@ rea@@ k ; c@@ ase ' . ' : if ( state == F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H || state == S@@ T@@ A@@ R@@ T ) { state = ON@@ E_@@ D@@ O@@ T ; } else if ( state == ON@@ E_@@ D@@ O@@ T ) { state = T@@ W@@ O@@ _@@ D@@ O@@ T ; } else { state = N@@ O@@ R@@ M@@ A@@ L ; } b@@ rea@@ k ; de@@ fa@@ ult : state = N@@ O@@ R@@ M@@ A@@ L ; b@@ rea@@ k ; } } return path ; }
 @ Be@@ fo@@ re@@ Cl@@ ass public static void in@@ it@@ T@@ es@@ t@@ Dat@@ a ( ) throws IOException { Sjukfall@@ Inty@@ g@@ G@@ en@@ er@@ ator g@@ en@@ er@@ ator = new Sjukfall@@ Inty@@ g@@ G@@ en@@ er@@ ator ( L@@ O@@ C@@ A@@ T@@ I@@ ON@@ _@@ IN@@ T@@ Y@@ G@@ S@@ D@@ A@@ T@@ A ) ; intyg@@ Data@@ List = g@@ en@@ er@@ ator . g@@ en@@ er@@ ate ( ) . get ( ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 1@@ 6 ▁ bu@@ t ▁ w@@ as ▁ " + intyg@@ Data@@ List . size ( ) , intyg@@ Data@@ List . size ( ) == 1@@ 6 ) ; }
 public int get@@ P@@ ro@@ v@@ in@@ ce@@ _@@ id ( ) { return p@@ ro@@ v@@ in@@ ce@@ _@@ id ; }
 @ Bean ( d@@ es@@ tr@@ o@@ y@@ M@@ et@@ ho@@ d = " sh@@ ut@@ d@@ o@@ w@@ n " ) public S@@ p@@ r@@ ing@@ Bu@@ s c@@ x@@ f ( ) { return new S@@ p@@ r@@ ing@@ Bu@@ s ( ) ; }
 @ Te@@ mp@@ l@@ ate ( " < s@@ p@@ an ▁ cl@@ ass = \@@ " { 1 } \@@ " ▁ ti@@ t@@ le = \@@ " { 0 } \@@ " > < / s@@ p@@ an > " ) S@@ a@@ f@@ e@@ H@@ t@@ m@@ l bu@@ t@@ t@@ on ( String ti@@ t@@ le , String c@@ s@@ s@@ Cl@@ ass ) ;
 @ Test public static void m@@ e@@ g@@ am@@ or@@ p@@ h@@ ic@@ M@@ ul@@ ti@@ G@@ l@@ ob@@ al@@ L@@ et@@ Test ( ) throws Script@@ Exception , In@@ ter@@ r@@ up@@ te@@ d@@ Exception { final N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory f@@ actory = new N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory ( ) ; final Script@@ En@@ gin@@ e e = f@@ actory . get@@ Script@@ En@@ gin@@ e ( L@@ A@@ N@@ G@@ U@@ A@@ G@@ E_@@ E@@ S@@ 6 ) ; final Script@@ Context [ ] con@@ te@@ x@@ ts = new Script@@ Context [ N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ] ; final String shared@@ Script = " foo " ; for ( int i = 0 ; i < N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ; i ++ ) { final Script@@ Context context = con@@ te@@ x@@ ts [ i ] = new Si@@ mp@@ le@@ Script@@ Context ( ) ; final B@@ in@@ d@@ ings b = e . c@@ rea@@ te@@ B@@ in@@ d@@ ings ( ) ; context . set@@ B@@ in@@ d@@ ings ( b , Script@@ Context . E@@ N@@ G@@ IN@@ E_@@ S@@ C@@ O@@ P@@ E ) ; assertEquals ( e . eval ( " le@@ t ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ; i ++ ) { final Script@@ Context context = con@@ te@@ x@@ ts [ i ] ; assertEquals ( e . eval ( shared@@ Script , context ) , String . v@@ alu@@ e@@ O@@ f ( i ) ) ; } }
 @ Test public static void m@@ e@@ g@@ am@@ or@@ p@@ h@@ ic@@ V@@ ar@@ Test ( ) throws Script@@ Exception , In@@ ter@@ r@@ up@@ te@@ d@@ Exception { final N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory f@@ actory = new N@@ ash@@ or@@ n@@ Script@@ En@@ gin@@ e@@ F@@ actory ( ) ; final Script@@ En@@ gin@@ e e = f@@ actory . get@@ Script@@ En@@ gin@@ e ( ) ; final Script@@ Context [ ] con@@ te@@ x@@ ts = new Script@@ Context [ N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ] ; final String shared@@ Script = " foo " ; for ( int i = 0 ; i < N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ; i ++ ) { final Script@@ Context context = con@@ te@@ x@@ ts [ i ] = new Si@@ mp@@ le@@ Script@@ Context ( ) ; final B@@ in@@ d@@ ings b = e . c@@ rea@@ te@@ B@@ in@@ d@@ ings ( ) ; context . set@@ B@@ in@@ d@@ ings ( b , Script@@ Context . E@@ N@@ G@@ IN@@ E_@@ S@@ C@@ O@@ P@@ E ) ; assertEquals ( e . eval ( " v@@ a@@ r ▁ foo ▁ = ▁ ' " + i + " ' ; " , context ) , null ) ; } for ( int i = 0 ; i < N@@ U@@ M@@ B@@ ER@@ _@@ O@@ F@@ _@@ C@@ ON@@ T@@ E@@ X@@ T@@ S ; i ++ ) { final Script@@ Context context = con@@ te@@ x@@ ts [ i ] ; assertEquals ( e . eval ( shared@@ Script , context ) , String . v@@ alu@@ e@@ O@@ f ( i ) ) ; } }
 @ Test public void te@@ st@@ F@@ all@@ 5 ( ) { String key = "@@ 1@@ 9@@ 8@@ 0@@ 01@@ 2@@ 4@@ -@@ 9@@ 2@@ 8@@ 6@@ " ; Map < String , List < SjukfallIntyg > > map = cre@@ ator . cre@@ ate ( intyg@@ Data@@ List , param@@ e@@ ters ) ; List < SjukfallIntyg > list = map . get ( key ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 2 ▁ bu@@ t ▁ w@@ as ▁ " + list . size ( ) , list . size ( ) == 2 ) ; assert@@ St@@ art@@ Date ( list . get ( 0 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 1@@ 2@@ " ) ; assert@@ En@@ d@@ Date ( list . get ( 1 ) , "@@ 201@@ 6@@ -0@@ 2@@ -@@ 2@@ 5@@ " ) ; assertTrue ( list . get ( 0 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; assert@@ F@@ al@@ se ( list . get ( 1 ) . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) ; }
 public < T > In@@ vo@@ k@@ er < T > j@@ o@@ in ( D@@ i@@ rec@@ tory < T > di@@ rec@@ tory ) throws R@@ p@@ c@@ Exception { return new B@@ ro@@ ad@@ c@@ ast@@ C@@ lu@@ s@@ ter@@ In@@ vo@@ k@@ er < T > ( di@@ rec@@ tory ) ; }
 public B@@ oolean ap@@ pl@@ y ( String in ) { return in . equals ( in . to@@ U@@ p@@ p@@ er@@ C@@ ase ( ) ) ; }
 public Z@@ i@@ p@@ En@@ try get@@ En@@ try ( String name ) { Z@@ i@@ p@@ En@@ try entry = s@@ up@@ er . get@@ En@@ try ( name ) ; if ( ( entry != null ) && ( entry . get@@ Size ( ) == 0 ) && ! entry . is@@ D@@ i@@ rec@@ tory ( ) ) { Z@@ i@@ p@@ En@@ try di@@ r@@ En@@ try = s@@ up@@ er . get@@ En@@ try ( name + ' / ' ) ; if ( di@@ r@@ En@@ try != null ) { entry = di@@ r@@ En@@ try ; } } return entry ; }
 private void add@@ User@@ L@@ ast@@ Mo@@ di@@ f@@ ie@@ d@@ Column ( ) { add@@ Column ( CmsHistory@@ Messag@@ es . co@@ lum@@ n@@ User@@ L@@ ast@@ Mo@@ di@@ f@@ ie@@ d ( ) , 1@@ 2@@ 0 , new T@@ ex@@ t@@ Column < CmsHistoryResourceBean > ( ) { @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { return historyRes . get@@ User@@ L@@ ast@@ Mo@@ di@@ f@@ ie@@ d ( ) ; } } ) ; }
 @ Test public void shoul@@ d@@ P@@ ro@@ v@@ ide@@ Des@@ crip@@ tor@@ T@@ o@@ M@@ ul@@ ti@@ p@@ le@@ Ex@@ te@@ n@@ si@@ on@@ s@@ I@@ mp@@ le@@ m@@ en@@ t@@ ing@@ Th@@ e@@ P@@ lu@@ gin@@ Des@@ crip@@ tor@@ A@@ w@@ are@@ In@@ ter@@ f@@ ac@@ e ( ) throws Exception { G@@ o@@ P@@ lu@@ gin@@ Des@@ crip@@ t@@ or p@@ lu@@ g@@ in = p@@ lu@@ gin@@ M@@ an@@ ag@@ er . get@@ P@@ lu@@ gin@@ Des@@ crip@@ tor@@ F@@ or ( P@@ L@@ U@@ G@@ IN@@ _@@ ID ) ; assert@@ Th@@ a@@ t ( p@@ lu@@ g@@ in . id ( ) , is ( P@@ L@@ U@@ G@@ IN@@ _@@ ID ) ) ; assert@@ Th@@ a@@ t ( p@@ lu@@ g@@ in . bu@@ n@@ d@@ le@@ Sy@@ m@@ b@@ o@@ li@@ c@@ Name ( ) , is ( P@@ L@@ U@@ G@@ IN@@ _@@ ID ) ) ; assert@@ Th@@ a@@ t ( p@@ lu@@ g@@ in . bu@@ n@@ d@@ le@@ Cl@@ ass@@ P@@ ath ( ) , is ( " li@@ b / g@@ o - p@@ lu@@ g@@ in - ac@@ ti@@ v@@ ator . j@@ a@@ r , . " ) ) ; assert@@ Th@@ a@@ t ( p@@ lu@@ g@@ in . bu@@ n@@ d@@ le@@ A@@ c@@ ti@@ v@@ ator ( ) , is ( De@@ fa@@ ult@@ G@@ o@@ P@@ lu@@ gin@@ A@@ c@@ ti@@ v@@ ator . cl@@ ass . get@@ C@@ an@@ on@@ ic@@ al@@ Name ( ) ) ) ; assert@@ Th@@ a@@ t ( p@@ lu@@ g@@ in . is@@ In@@ v@@ ali@@ d ( ) , is ( false ) ) ; assert@@ Th@@ a@@ t ( Sy@@ s@@ tem . get@@ P@@ roper@@ ty ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ E@@ S@@ C@@ _@@ P@@ R@@ O@@ P@@ ER@@ T@@ Y@@ _@@ S@@ E@@ T@@ _@@ B@@ Y@@ _@@ P@@ L@@ U@@ G@@ IN@@ _@@ E@@ X@@ T@@ _@@ 1 ) , is ( p@@ lu@@ g@@ in . to@@ String ( ) ) ) ; assert@@ Th@@ a@@ t ( Sy@@ s@@ tem . get@@ P@@ roper@@ ty ( P@@ L@@ U@@ G@@ IN@@ _@@ D@@ E@@ S@@ C@@ _@@ P@@ R@@ O@@ P@@ ER@@ T@@ Y@@ _@@ S@@ E@@ T@@ _@@ B@@ Y@@ _@@ P@@ L@@ U@@ G@@ IN@@ _@@ E@@ X@@ T@@ _@@ 2 ) , is ( p@@ lu@@ g@@ in . to@@ String ( ) ) ) ; }
 @ Be@@ f@@ or@@ e public void set@@ u@@ p ( ) { cre@@ ator = new Sjukfall@@ Inty@@ g@@ En@@ h@@ et@@ C@@ re@@ ator ( ) ; param@@ e@@ ters = new Inty@@ g@@ Par@@ ame@@ tr@@ a@@ r ( 5 , Lo@@ c@@ al@@ Date . par@@ se ( "@@ 201@@ 6@@ -0@@ 2@@ -@@ 1@@ 6@@ " ) ) ; }
 public static void ma@@ in ( String [ ] ar@@ g@@ s ) throws Exception { new H@@ el@@ lo@@ J@@ D@@ B@@ I@@ S@@ er@@ vic@@ e ( ) . r@@ u@@ n ( ar@@ g@@ s ) ; }
 @ Override public String get@@ Value ( CmsHistoryResourceBean historyRes ) { String path = historyRes . get@@ R@@ oo@@ t@@ P@@ ath ( ) ; String si@@ te@@ R@@ oo@@ t = Cms@@ Co@@ re@@ P@@ ro@@ vi@@ der . get ( ) . get@@ Si@@ te@@ R@@ oo@@ t ( ) ; if ( path . startsWith ( si@@ te@@ R@@ oo@@ t ) ) { path = path . substring ( si@@ te@@ R@@ oo@@ t . length ( ) ) ; if ( ! path . startsWith ( " / " ) ) { path = " / " + path ; } } return path ; }
 @ Override public List < Data@@ Type > c@@ al@@ c@@ ul@@ ate@@ O@@ ut@@ put@@ Data@@ T@@ yp@@ es ( List < Data@@ Type > in@@ put@@ Data@@ T@@ yp@@ es ) { P@@ re@@ con@@ di@@ tion@@ s . ch@@ ec@@ k@@ St@@ ate ( in@@ put@@ Data@@ T@@ yp@@ es != null && in@@ put@@ Data@@ T@@ yp@@ es . size ( ) == 2 , " Ex@@ p@@ ec@@ ted ▁ ex@@ ac@@ t@@ l@@ y ▁ 2 ▁ in@@ pu@@ t ▁ d@@ at@@ at@@ yp@@ es ▁ for ▁ % s , ▁ g@@ o@@ t ▁ % s " , get@@ Cl@@ ass ( ) , in@@ put@@ Data@@ T@@ yp@@ es ) ; P@@ re@@ con@@ di@@ tion@@ s . ch@@ ec@@ k@@ St@@ ate ( in@@ put@@ Data@@ T@@ yp@@ es . get ( 1 ) . is@@ In@@ t@@ Type ( ) , " Dat@@ at@@ ype ▁ for ▁ in@@ pu@@ t ▁ 1 ▁ ( Se@@ g@@ m@@ ent ▁ I@@ D@@ s ) ▁ m@@ u@@ st ▁ b@@ e ▁ an ▁ in@@ teger ▁ type , ▁ g@@ o@@ t ▁ % s " , in@@ put@@ Data@@ T@@ yp@@ es . get ( 1 ) ) ; return Co@@ l@@ le@@ c@@ tion@@ s . s@@ ing@@ l@@ et@@ on@@ List ( in@@ put@@ Data@@ T@@ yp@@ es . get ( 0 ) ) ; }
 private void add@@ Column ( String l@@ ab@@ e@@ l , int w@@ id@@ t@@ h , Column < CmsHistoryResourceBean , ? > co@@ l ) { add@@ Column ( co@@ l , l@@ ab@@ e@@ l ) ; set@@ Colum@@ n@@ W@@ id@@ t@@ h ( co@@ l , w@@ id@@ t@@ h , U@@ n@@ i@@ t . P@@ X ) ; }
 public void p@@ r@@ int@@ l@@ n@@ W@@ i@@ th@@ Tim@@ es@@ t@@ am@@ p ( String m@@ essag@@ e ) throws IOException { Sy@@ s@@ tem . o@@ u@@ t . p@@ r@@ int@@ l@@ n ( form@@ at@@ C@@ ur@@ re@@ n@@ t@@ Tim@@ e ( ) + " ▁ ▁ " + m@@ essag@@ e ) ; }
 public static Th@@ ro@@ w@@ able get@@ R@@ oo@@ t@@ C@@ a@@ u@@ se ( Th@@ ro@@ w@@ able thro@@ w@@ able ) { if ( thro@@ w@@ able . get@@ C@@ a@@ u@@ se ( ) != null ) return get@@ R@@ oo@@ t@@ C@@ a@@ u@@ se ( thro@@ w@@ able . get@@ C@@ a@@ u@@ se ( ) ) ; return thro@@ w@@ able ; }
 public void set@@ B@@ ot@@ s@@ Co@@ unt ( int co@@ unt ) { b@@ ot@@ s@@ Co@@ unt = co@@ unt ; }
 @ Test public void te@@ st@@ Re@@ d@@ u@@ ce@@ d@@ Map ( ) { Map < String , List < SjukfallIntyg > > map = cre@@ ator . c@@ rea@@ te@@ Map ( intyg@@ Data@@ List , param@@ e@@ ters ) ; Map < String , List < SjukfallIntyg > > re@@ d@@ u@@ ce@@ d@@ Map = cre@@ ator . re@@ d@@ u@@ ce@@ Map ( map ) ; assertTrue ( " Ex@@ p@@ ec@@ ted ▁ 6 ▁ bu@@ t ▁ w@@ as ▁ " + re@@ d@@ u@@ ce@@ d@@ Map . size ( ) , re@@ d@@ u@@ ce@@ d@@ Map . size ( ) == 6 ) ; }
 @ Override public View get@@ View ( int i , View vie@@ w , View@@ Group vie@@ w@@ Group ) { if ( vie@@ w == null ) { vie@@ w = new M@@ en@@ tion@@ C@@ el@@ l ( m@@ Context ) ; ( ( M@@ en@@ tion@@ C@@ el@@ l ) vie@@ w ) . set@@ I@@ s@@ D@@ ar@@ k@@ Th@@ e@@ m@@ e ( is@@ D@@ ar@@ k@@ Th@@ e@@ m@@ e ) ; } if ( searchResult@@ User@@ names != null ) { ( ( M@@ en@@ tion@@ C@@ el@@ l ) vie@@ w ) . set@@ U@@ ser ( searchResult@@ User@@ names . get ( i ) ) ; } else if ( searchResult@@ H@@ asht@@ ags != null ) { ( ( M@@ en@@ tion@@ C@@ el@@ l ) vie@@ w ) . set@@ Te@@ xt ( searchResult@@ H@@ asht@@ ags . get ( i ) ) ; } else if ( searchResultCommand@@ s != null ) { ( ( M@@ en@@ tion@@ C@@ el@@ l ) vie@@ w ) . set@@ B@@ ot@@ Command ( searchResultCommand@@ s . get ( i ) , searchResultCommand@@ s@@ H@@ el@@ p . get ( i ) , searchResultCommand@@ s@@ User@@ s . get ( i ) ) ; } return vie@@ w ; }
 public Option@@ Int cre@@ ate ( ) throws Option@@ Par@@ ser@@ Exception { if ( o@@ ption@@ Type == null ) { if ( ! has@@ Value ) o@@ ption@@ Type = Option@@ Type . B@@ O@@ O@@ L@@ E@@ A@@ N ; else if ( is@@ P@@ roper@@ ty ) o@@ ption@@ Type = Option@@ Type . G@@ R@@ O@@ U@@ P ; else if ( has@@ M@@ ul@@ ti@@ p@@ le@@ V@@ alu@@ es ) o@@ ption@@ Type = Option@@ Type . L@@ I@@ S@@ T ; else o@@ ption@@ Type = Option@@ Type . N@@ O@@ R@@ M@@ A@@ L ; } if ( name == null || ( name . length ( ) < 1 && o@@ ption@@ Type != Option@@ Type . A@@ R@@ G@@ U@@ M@@ E@@ N@@ T ) ) { if ( fi@@ el@@ d@@ Name == null || fi@@ el@@ d@@ Name . length ( ) < 1 ) throw new Option@@ Par@@ ser@@ Exception ( " Name ▁ m@@ u@@ st ▁ b@@ e ▁ de@@ fin@@ ed ▁ t@@ o ▁ cre@@ ate ▁ an ▁ O@@ ption " ) ; else name = fi@@ el@@ d@@ Name ; } return new Option@@ Int ( sh@@ or@@ t@@ Name , name , d@@ es@@ cri@@ ption , ar@@ g@@ um@@ ent , re@@ qu@@ i@@ re@@ d , v@@ alu@@ e@@ Se@@ par@@ ator , de@@ fa@@ ult@@ V@@ alu@@ es , type , fi@@ el@@ d@@ Name , o@@ ption@@ Type , con@@ ver@@ ter , comp@@ le@@ ter ) ; }
 private static String re@@ al@@ C@@ an@@ on@@ ic@@ ali@@ ze ( final String path , final int l@@ ast@@ D@@ o@@ t , final int in@@ i@@ ti@@ al@@ St@@ ate ) { int state = in@@ i@@ ti@@ al@@ St@@ ate ; int e@@ at@@ Co@@ unt = 0 ; int to@@ k@@ en@@ En@@ d = path . length ( ) ; final List < String > par@@ ts = new ArrayList < > ( ) ; for ( int i = l@@ ast@@ D@@ o@@ t - 1 ; i >@@ = 0 ; -@@ - i ) { final ch@@ a@@ r c = path . ch@@ ar@@ A@@ t ( i ) ; s@@ w@@ it@@ ch ( state ) { c@@ ase N@@ O@@ R@@ M@@ A@@ L : { if ( c == ' / ' ) { state = F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ; if ( e@@ at@@ Co@@ unt > 0 ) { -@@ - e@@ at@@ Co@@ unt ; to@@ k@@ en@@ En@@ d = i ; } } b@@ rea@@ k ; } c@@ ase F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H : { if ( c == ' . ' ) { state = ON@@ E_@@ D@@ O@@ T ; } else if ( c == ' / ' ) { if ( e@@ at@@ Co@@ unt > 0 ) { -@@ - e@@ at@@ Co@@ unt ; to@@ k@@ en@@ En@@ d = i ; } else { par@@ ts . add ( path . substring ( i + 1 , to@@ k@@ en@@ En@@ d ) ) ; to@@ k@@ en@@ En@@ d = i ; } } else { state = N@@ O@@ R@@ M@@ A@@ L ; } b@@ rea@@ k ; } c@@ ase ON@@ E_@@ D@@ O@@ T : { if ( c == ' . ' ) { state = T@@ W@@ O@@ _@@ D@@ O@@ T ; } else if ( c == ' / ' ) { if ( i + 2 != to@@ k@@ en@@ En@@ d ) { par@@ ts . add ( path . substring ( i + 2 , to@@ k@@ en@@ En@@ d ) ) ; } to@@ k@@ en@@ En@@ d = i ; state = F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ; } else { state = N@@ O@@ R@@ M@@ A@@ L ; } b@@ rea@@ k ; } c@@ ase T@@ W@@ O@@ _@@ D@@ O@@ T : { if ( c == ' / ' ) { if ( i + 3 != to@@ k@@ en@@ En@@ d ) { par@@ ts . add ( path . substring ( i + 3 , to@@ k@@ en@@ En@@ d ) ) ; } to@@ k@@ en@@ En@@ d = i ; e@@ at@@ Co@@ unt ++ ; state = F@@ I@@ R@@ S@@ T@@ _@@ S@@ L@@ A@@ S@@ H ; } else { state = N@@ O@@ R@@ M@@ A@@ L ; } } } } final S@@ tr@@ ing@@ Builder result = new S@@ tr@@ ing@@ Builder ( ) ; if ( to@@ k@@ en@@ En@@ d != 0 ) { result . ap@@ pen@@ d ( path . substring ( 0 , to@@ k@@ en@@ En@@ d ) ) ; } for ( int i = par@@ ts . size ( ) - 1 ; i >@@ = 0 ; -@@ - i ) { result . ap@@ pen@@ d ( par@@ ts . get ( i ) ) ; } if ( result . length ( ) == 0 ) { return " / " ; } return result . to@@ String ( ) ; }
 @ Test public void te@@ st@@ Set@@ A@@ c@@ ti@@ ve@@ C@@ er@@ ti@@ f@@ ic@@ ate ( ) { Map < String , List < SjukfallIntyg > > map = cre@@ ator . c@@ rea@@ te@@ Map ( intyg@@ Data@@ List , param@@ e@@ ters ) ; Map < String , List < SjukfallIntyg > > ac@@ ti@@ ve@@ Map = cre@@ ator . set@@ A@@ c@@ ti@@ v@@ e ( map ) ; assertTrue ( ac@@ ti@@ ve@@ Map . en@@ tr@@ y@@ Se@@ t ( ) . st@@ ream ( ) . all@@ M@@ atch ( e -@@ > e . get@@ Value ( ) . st@@ ream ( ) . fil@@ ter ( o -@@ > o . is@@ A@@ k@@ ti@@ v@@ t@@ Intyg ( ) ) . co@@ unt ( ) < 2 ) ) ; }
 public static void ma@@ in ( String [ ] ar@@ g@@ s ) throws Exception { Sy@@ s@@ tem . o@@ u@@ t . p@@ r@@ int@@ l@@ n ( " \n L@@ Z@@ M@@ A ▁ ( J@@ av@@ a ) ▁ 4@@ .@@ 6@@ 1 ▁ ▁ 2@@ 0@@ 0@@ 8@@ -@@ 1@@ 1@@ -@@ 2@@ 3 \n " ) ; if ( ar@@ g@@ s . length < 1 ) { P@@ r@@ int@@ H@@ el@@ p ( ) ; return ; } Command@@ L@@ in@@ e params = new Command@@ L@@ in@@ e ( ) ; if ( ! params . Par@@ se ( ar@@ g@@ s ) ) { Sy@@ s@@ tem . o@@ u@@ t . p@@ r@@ int@@ l@@ n ( " \n In@@ cor@@ rec@@ t ▁ comm@@ and " ) ; return ; } if ( params . Command == Command@@ L@@ in@@ e . k@@ B@@ en@@ ch@@ ma@@ k ) { int d@@ ic@@ tion@@ ar@@ y = ( 1 <@@ < 2@@ 1 ) ; if ( params . D@@ ic@@ tion@@ ar@@ y@@ Si@@ z@@ e@@ I@@ s@@ De@@ fin@@ ed ) d@@ ic@@ tion@@ ar@@ y = params . D@@ ic@@ tion@@ ar@@ y@@ Size ; if ( params . M@@ at@@ ch@@ F@@ in@@ der > 1 ) throw new Exception ( " U@@ n@@ s@@ up@@ p@@ or@@ ted ▁ m@@ atch ▁ fin@@ der " ) ; S@@ ev@@ en@@ Z@@ i@@ p . L@@ z@@ ma@@ B@@ en@@ ch . L@@ z@@ ma@@ B@@ en@@ ch@@ mar@@ k ( params . N@@ um@@ B@@ en@@ ch@@ mar@@ k@@ P@@ ass@@ es , d@@ ic@@ tion@@ ar@@ y ) ; } else if ( params . Command == Command@@ L@@ in@@ e . k@@ En@@ co@@ de || params . Command == Command@@ L@@ in@@ e . k@@ De@@ co@@ de ) { java . i@@ o . File in@@ File = new java . i@@ o . File ( params . In@@ File ) ; java . i@@ o . File out@@ File = new java . i@@ o . File ( params . O@@ ut@@ File ) ; java . i@@ o . Bu@@ ff@@ e@@ re@@ d@@ In@@ put@@ Stream in@@ Stream = new java . i@@ o . Bu@@ ff@@ e@@ re@@ d@@ In@@ put@@ Stream ( new java . i@@ o . File@@ In@@ put@@ Stream ( in@@ File ) ) ; java . i@@ o . Bu@@ ff@@ e@@ re@@ d@@ O@@ ut@@ put@@ Stream out@@ Stream = new java . i@@ o . Bu@@ ff@@ e@@ re@@ d@@ O@@ ut@@ put@@ Stream ( new java . i@@ o . File@@ O@@ ut@@ put@@ Stream ( out@@ File ) ) ; boolean e@@ os = false ; if ( params . E@@ os ) e@@ os = true ; if ( params . Command == Command@@ L@@ in@@ e . k@@ En@@ co@@ de ) { S@@ ev@@ en@@ Z@@ i@@ p . Co@@ mp@@ ression . L@@ Z@@ M@@ A . En@@ coder en@@ coder = new S@@ ev@@ en@@ Z@@ i@@ p . Co@@ mp@@ ression . L@@ Z@@ M@@ A . En@@ coder ( ) ; if ( ! en@@ coder . Set@@ A@@ l@@ g@@ or@@ i@@ th@@ m ( params . A@@ l@@ g@@ or@@ i@@ th@@ m ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ comp@@ ression ▁ m@@ o@@ de " ) ; if ( ! en@@ coder . Set@@ D@@ ic@@ tion@@ ar@@ y@@ Size ( params . D@@ ic@@ tion@@ ar@@ y@@ Size ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ d@@ ic@@ tion@@ ar@@ y ▁ size " ) ; if ( ! en@@ coder . Set@@ N@@ um@@ F@@ ast@@ By@@ te@@ s ( params . F@@ b ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ - f@@ b ▁ value " ) ; if ( ! en@@ coder . Set@@ M@@ at@@ ch@@ F@@ in@@ der ( params . M@@ at@@ ch@@ F@@ in@@ der ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ - m@@ f ▁ value " ) ; if ( ! en@@ coder . Set@@ L@@ c@@ L@@ p@@ P@@ b ( params . L@@ c , params . L@@ p , params . P@@ b ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ - l@@ c ▁ or ▁ - l@@ p ▁ or ▁ - p@@ b ▁ value " ) ; en@@ coder . Set@@ En@@ d@@ M@@ ar@@ k@@ er@@ Mo@@ de ( e@@ os ) ; en@@ coder . W@@ ri@@ te@@ Co@@ d@@ er@@ P@@ roperties ( out@@ Stream ) ; long fi@@ le@@ Size ; if ( e@@ os ) fi@@ le@@ Size = - 1 ; else fi@@ le@@ Size = in@@ File . length ( ) ; for ( int i = 0 ; i < 8 ; i ++ ) out@@ Stream . wri@@ te ( ( int ) ( fi@@ le@@ Size >@@ >@@ > ( 8 * i ) ) & 0@@ x@@ F@@ F ) ; en@@ coder . Co@@ de ( in@@ Stream , out@@ Stream , - 1 , - 1 , null ) ; } else { int p@@ roperti@@ es@@ Size = 5 ; b@@ y@@ te [ ] p@@ roperties = new b@@ y@@ te [ p@@ roperti@@ es@@ Size ] ; if ( in@@ Stream . rea@@ d ( p@@ roperties , 0 , p@@ roperti@@ es@@ Size ) != p@@ roperti@@ es@@ Size ) throw new Exception ( " in@@ pu@@ t ▁ . l@@ z@@ m@@ a ▁ fil@@ e ▁ is ▁ to@@ o ▁ sh@@ or@@ t " ) ; S@@ ev@@ en@@ Z@@ i@@ p . Co@@ mp@@ ression . L@@ Z@@ M@@ A . De@@ coder de@@ coder = new S@@ ev@@ en@@ Z@@ i@@ p . Co@@ mp@@ ression . L@@ Z@@ M@@ A . De@@ coder ( ) ; if ( ! de@@ coder . Set@@ De@@ co@@ d@@ er@@ P@@ roperties ( p@@ roperties ) ) throw new Exception ( " In@@ cor@@ rec@@ t ▁ st@@ ream ▁ p@@ roperties " ) ; long out@@ Size = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int v = in@@ Stream . rea@@ d ( ) ; if ( v < 0 ) throw new Exception ( " C@@ an ' t ▁ rea@@ d ▁ st@@ ream ▁ size " ) ; out@@ Size |@@ = ( ( long ) v ) <@@ < ( 8 * i ) ; } if ( ! de@@ coder . Co@@ de ( in@@ Stream , out@@ Stream , out@@ Size ) ) throw new Exception ( " E@@ r@@ ro@@ r ▁ in ▁ d@@ at@@ a ▁ st@@ ream " ) ; } out@@ Stream . f@@ lu@@ s@@ h ( ) ; out@@ Stream . cl@@ o@@ se ( ) ; in@@ Stream . cl@@ o@@ se ( ) ; } else throw new Exception ( " In@@ cor@@ rec@@ t ▁ comm@@ and " ) ; return ; }
 @ Override public void in@@ i@@ ti@@ ali@@ ze ( B@@ oo@@ t@@ str@@ ap < H@@ el@@ lo@@ W@@ or@@ l@@ d@@ Con@@ fi@@ g@@ ur@@ ati@@ on > b@@ oo@@ t@@ str@@ ap ) { b@@ oo@@ t@@ str@@ ap . add@@ B@@ und@@ le ( new View@@ B@@ und@@ le < > ( ) ) ; b@@ oo@@ t@@ str@@ ap . add@@ B@@ und@@ le ( new J@@ d@@ bi@@ Exce@@ ption@@ s@@ B@@ und@@ le ( ) ) ; }
 private static void assert@@ St@@ art@@ Date ( SjukfallIntyg intyg@@ s@@ Dat@@ a , String d@@ at@@ um ) { assertTrue ( intyg@@ s@@ Dat@@ a . get@@ St@@ art@@ Dat@@ um ( ) . equals ( Lo@@ c@@ al@@ Date . par@@ se ( d@@ at@@ um ) ) ) ; }
 public String form@@ at@@ C@@ ur@@ re@@ n@@ t@@ Tim@@ e ( ) { return form@@ at@@ Tim@@ e ( Sy@@ s@@ tem . c@@ ur@@ re@@ n@@ t@@ Tim@@ e@@ M@@ il@@ li@@ s ( ) ) ; }
