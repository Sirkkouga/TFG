 public void setIncludeRegex ( String includeRegex ) { this . includeRegex = Util . nullify ( includeRegex ) ; if ( this . includeRegex == null ) this . includePattern = null ; else this . includePattern = Pattern . compile ( includeRegex ) ; }
 @ Override public boolean writeTo ( ByteBuffer buf , MessageWriter writer ) { writer . setBuffer ( buf ) ; if ( ! writer . isHeaderWritten ( ) ) { if ( ! writer . writeHeader ( directType ( ) , fieldsCount ( ) ) ) return false ; writer . onHeaderWritten ( ) ; } switch ( writer . state ( ) ) { case 0 : if ( ! writer . writeByteArray ( " siblingsBytes " , siblingsBytes ) ) return false ; writer . incrementState ( ) ; } return true ; }
 @ Override public byte fieldsCount ( ) { return 1 ; }
 public void visitClassConstant ( Clazz clazz , ClassConstant classConstant ) { classConstant . referencedClassAccept ( this ) ; }
 public void visitLibraryClass ( LibraryClass libraryClass ) { }
 public void visitConstantInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , ConstantInstruction constantInstruction ) { if ( constantInstruction . opcode == InstructionConstants . OP_INSTANCEOF ) { clazz . constantPoolEntryAccept ( constantInstruction . constantIndex , this ) ; } }
 private void prepareClanPlayer ( ) { if ( insertClanPlayer != null ) { try { insertClanPlayer . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClanPlayer = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ players ` ▁ ( ▁ ` name ` , ▁ ` leader ` , ▁ ` trusted ` , ▁ ` join _ date ` , ▁ ` last _ seen ` , ▁ ` clan ` , ▁ ` neutral _ kills ` , ▁ ` rival _ Kills ` , ▁ ` civilian _ Kills ` , ▁ ` deaths ` , ▁ ` flags ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) " ) ; }
 @ Override public DescribableList < ListViewColumn , Descriptor < ListViewColumn > > getColumns ( ) { return columns ; }
 private void prepareClan ( ) { if ( insertClan != null ) { try { insertClan . close ( ) ; } catch ( SQLException e ) { Logging . debug ( e , false ) ; } } insertClan = to . prepare ( " INSERT ▁ INTO ▁ ` sc2 _ clans ` ▁ ( ` name ` , ▁ ` tag ` , ▁ ` verified ` , ▁ ` founded ` , ▁ ` last _ action ` , ▁ ` flags ` , ▁ ` balance ` ▁ ) ▁ VALUES ▁ ( ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? , ▁ ? ▁ ) ; " ) ; }
 @ Override public Collection < K > keys ( ) { return cache . keys ( ) ; }
 @ Override public void onLocationChanged ( final Item item , final String oldFullName , final String newFullName ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; } } ) ; }
 public void insertPlayer ( String name , boolean leader , boolean trusted , long joinDate , long lastSeen , long clan , int neutralKills , int rivalKills , int civilianKills , int deaths , String flags ) throws SQLException { insertClanPlayer . setString ( 1 , name ) ; insertClanPlayer . setBoolean ( 2 , leader ) ; insertClanPlayer . setBoolean ( 3 , trusted ) ; insertClanPlayer . setTimestamp ( 4 , new Timestamp ( joinDate ) ) ; insertClanPlayer . setTimestamp ( 5 , new Timestamp ( lastSeen ) ) ; insertClanPlayer . setLong ( 6 , clan ) ; insertClanPlayer . setInt ( 7 , neutralKills ) ; insertClanPlayer . setInt ( 8 , rivalKills ) ; insertClanPlayer . setInt ( 9 , civilianKills ) ; insertClanPlayer . setInt ( 10 , deaths ) ; if ( flags != null ) { insertClanPlayer . setString ( 11 , flags ) ; } else { insertClanPlayer . setNull ( 11 , Types . VARCHAR ) ; } try { insertClanPlayer . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clanPlayer ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClanPlayer ( ) ; } }
 public void visitProgramClass ( ProgramClass programClass ) { setInstanceofed ( programClass ) ; }
 public void unmarshalSiblings ( Marshaller marsh ) throws IgniteCheckedException { assert marsh != null ; if ( siblingsBytes != null ) siblings = marsh . unmarshal ( siblingsBytes , null ) ; }
 private Object readResolve ( ) { if ( includeRegex != null ) { try { includePattern = Pattern . compile ( includeRegex ) ; } catch ( PatternSyntaxException x ) { includeRegex = null ; OldDataMonitor . report ( this , Collections . < Throwable > singleton ( x ) ) ; } } if ( jobNames == null ) { jobNames = new TreeSet < String > ( CaseInsensitiveComparator . INSTANCE ) ; } initColumns ( ) ; initJobFilters ( ) ; return this ; }
 @ Override public void clear ( ) { cache . clear ( ) ; loadingDates . clear ( ) ; }
 @ Override public List < TopLevelItem > getItems ( ) { SortedSet < String > names ; List < TopLevelItem > items = new ArrayList < TopLevelItem > ( ) ; synchronized ( this ) { names = new TreeSet < String > ( jobNames ) ; } ItemGroup < ? extends TopLevelItem > parent = getOwnerItemGroup ( ) ; List < TopLevelItem > parentItems = new ArrayList < TopLevelItem > ( parent . getItems ( ) ) ; includeItems ( parent , parentItems , names ) ; Boolean statusFilter = this . statusFilter ; Iterable < ? extends TopLevelItem > candidates ; if ( recurse ) { candidates = Items . getAllItems ( parent , TopLevelItem . class ) ; } else { candidates = parent . getItems ( ) ; } for ( TopLevelItem item : candidates ) { if ( ! names . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ) continue ; if ( statusFilter == null || ! ( item instanceof AbstractProject ) || ( ( AbstractProject ) item ) . isDisabled ( ) ^ statusFilter ) items . add ( item ) ; } Iterable < ViewJobFilter > jobFilters = getJobFilters ( ) ; List < TopLevelItem > allItems = new ArrayList < TopLevelItem > ( parentItems ) ; if ( recurse ) allItems = expand ( allItems , new ArrayList < TopLevelItem > ( ) ) ; for ( ViewJobFilter jobFilter : jobFilters ) { items = jobFilter . filter ( items , allItems , this ) ; } items = new ArrayList < TopLevelItem > ( new LinkedHashSet < TopLevelItem > ( items ) ) ; return items ; }
 public FormValidation doCheckIncludeRegex ( @ QueryParameter String value ) throws IOException , ServletException , InterruptedException { String v = Util . fixEmpty ( value ) ; if ( v != null ) { try { Pattern . compile ( v ) ; } catch ( PatternSyntaxException pse ) { return FormValidation . error ( pse . getMessage ( ) ) ; } } return FormValidation . ok ( ) ; }
 public int Add ( int a , int b ) { return ( a + b ) ; }
 public Collection < ComputeJobSibling > jobSiblings ( ) { return siblings ; }
 public void insertBB ( List < String > bb , long clan ) throws SQLException { for ( String text : bb ) { insertBB . setLong ( 1 , clan ) ; insertBB . setString ( 2 , text ) ; insertBB . executeUpdate ( ) ; } }
 @ Override public V get ( K key ) { Long loadingDate = loadingDates . get ( key ) ; if ( loadingDate != null && System . currentTimeMillis ( ) - loadingDate > maxAge ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; } return cache . get ( key ) ; }
 @ Override public void run ( ) { byte [ ] buffer = new byte [ 1024 ] ; int bytes ; while ( true ) { try { bytes = mInStream . read ( buffer ) ; String data = new String ( buffer , 0 , bytes ) ; mHandler . obtainMessage ( DataTransferActivity . DATA_RECEIVED , data ) . sendToTarget ( ) ; } catch ( IOException e ) { break ; } } }
 public void visitAnyInstruction ( Clazz clazz , Method method , CodeAttribute codeAttribute , int offset , Instruction instruction ) { }
 private List < TopLevelItem > expand ( Collection < TopLevelItem > items , List < TopLevelItem > allItems ) { for ( TopLevelItem item : items ) { if ( item instanceof ItemGroup ) { ItemGroup < ? extends Item > ig = ( ItemGroup < ? extends Item > ) item ; expand ( Util . filter ( ig . getItems ( ) , TopLevelItem . class ) , allItems ) ; } allItems . add ( item ) ; } return allItems ; }
 public String getIncludeRegex ( ) { return includeRegex ; }
 public void insertClan ( String name , String tag , boolean verified , long founded , long last_action , String flags , double balance ) throws SQLException { insertClan . setString ( 1 , name ) ; insertClan . setString ( 2 , tag ) ; insertClan . setBoolean ( 3 , verified ) ; insertClan . setTimestamp ( 4 , new Timestamp ( founded ) ) ; insertClan . setTimestamp ( 5 , new Timestamp ( last_action ) ) ; if ( flags != null ) { insertClan . setString ( 6 , flags ) ; } else { insertClan . setNull ( 6 , Types . VARCHAR ) ; } insertClan . setDouble ( 7 , balance ) ; try { insertClan . executeUpdate ( ) ; } catch ( SQLException e ) { if ( e . getMessage ( ) . startsWith ( " Duplicate ▁ entry " ) || e . getMessage ( ) . contains ( " Abort ▁ due ▁ to ▁ constraint ▁ violation " ) ) { Logging . debug ( " Found ▁ duplicate ▁ clan ▁ % s ! ▁ Skipping ! " , name ) ; } else { Logging . debug ( e , " Error " , false ) ; } prepareClan ( ) ; } }
 @ Override @ RequirePOST public HttpResponse doAddJobToView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( item == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ does ▁ not ▁ correspond ▁ to ▁ a ▁ known ▁ item " ) ; if ( contains ( item ) ) return HttpResponses . ok ( ) ; add ( item ) ; owner . save ( ) ; return HttpResponses . ok ( ) ; }
 private void deleteViewItem ( Item item , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { needsSave = lv . jobNames . remove ( item . getRelativeNameFrom ( vg . getItemGroup ( ) ) ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
 @ Override public void run ( ) { deleted ( item ) ; }
 public String Add ( String a , String b ) { return ( a + b ) ; }
 protected void initJobFilters ( ) { if ( jobFilters == null ) jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; }
 private void deleted ( Item item ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { deleteViewItem ( item , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { deleteViewItem ( item , vg , ( ListView ) v ) ; } } } } }
 @ Override public boolean contains ( TopLevelItem item ) { return getItems ( ) . contains ( item ) ; }
 @ Override public String getDisplayName ( ) { return Messages . ListView_DisplayName ( ) ; }
 @ Override public boolean remove ( TopLevelItem item ) throws IOException { synchronized ( this ) { String name = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( ! jobNames . remove ( name ) ) return false ; } save ( ) ; return true ; }
 public void convertAll ( ) { try { convertClans ( ) ; convertPlayers ( ) ; convertKills ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } clans = null ; players = null ; }
 private TopLevelItem resolveName ( String name ) { TopLevelItem item = getOwnerItemGroup ( ) . getItem ( name ) ; if ( item == null ) { name = Items . getCanonicalName ( getOwnerItemGroup ( ) , name ) ; item = Jenkins . getInstance ( ) . getItemByFullName ( name , TopLevelItem . class ) ; } return item ; }
 public boolean isRecurse ( ) { return recurse ; }
 public DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > getJobFilters ( ) { return jobFilters ; }
 public void setRecurse ( boolean recurse ) { this . recurse = recurse ; }
 @ Override public byte directType ( ) { return 4 ; }
 @ Override public void run ( ) { convertAll ( ) ; }
 @ Override public void close ( ) throws IOException { super . close ( ) ; Utility . disconnectQuietly ( connection ) ; }
 public Example Add ( Example a , Example b ) { return new Example ( a . mPublicInt + b . mPublicInt ) ; }
 @ Override public void remove ( K key ) { cache . remove ( key ) ; loadingDates . remove ( key ) ; }
 public float Add ( float a , float b ) { return ( a + b ) ; }
 @ Override public void onAckReceived ( ) { }
 @ Override @ RequirePOST public HttpResponse doRemoveJobFromView ( @ QueryParameter String name ) throws IOException , ServletException { checkPermission ( View . CONFIGURE ) ; if ( name == null ) throw new Failure ( " Query ▁ parameter ▁ ' name ' ▁ is ▁ required " ) ; TopLevelItem item = resolveName ( name ) ; if ( remove ( item ) ) owner . save ( ) ; return HttpResponses . ok ( ) ; }
 public void convertKills ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ kills ` ; " ) ; while ( result . next ( ) ) { Timestamp date ; try { date = result . getTimestamp ( " date " ) ; } catch ( Exception e ) { date = new Timestamp ( System . currentTimeMillis ( ) ) ; } insertKill ( result . getString ( " attacker " ) , result . getString ( " attacker _ tag " ) , result . getString ( " victim " ) , result . getString ( " victim _ tag " ) , result . getString ( " kill _ type " ) , result . getBoolean ( " war " ) , date ) ; } }
 public long getIDByTag ( String tag ) { for ( ConvertedClan clan : clans ) { if ( clan . getTag ( ) . equals ( tag ) ) { return clan . getId ( ) ; } } return - 1 ; }
 @ Override public void add ( TopLevelItem item ) throws IOException { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } save ( ) ; }
 public void convertPlayers ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ players ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; try { JSONParser parser = new JSONParser ( ) ; String flagsString = result . getString ( " flags " ) ; JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; boolean friendlyFire = result . getBoolean ( " friendly _ fire " ) ; boolean bb = ( Boolean ) object . get ( " bb - enabled " ) ; boolean cape = ( Boolean ) object . get ( " cape - enabled " ) ; if ( friendlyFire ) { flags . put ( " ff " , friendlyFire ) ; } if ( bb ) { flags . put ( " bb " , bb ) ; } if ( cape ) { flags . put ( " cape " , cape ) ; } } catch ( ParseException e ) { e . printStackTrace ( ) ; continue ; } String name = result . getString ( " name " ) ; insertPlayer ( name , result . getBoolean ( " leader " ) , result . getBoolean ( " trusted " ) , result . getLong ( " join _ date " ) , result . getLong ( " last _ seen " ) , getIDByTag ( result . getString ( " tag " ) ) , result . getInt ( " neutral _ kills " ) , result . getInt ( " rival _ kills " ) , result . getInt ( " civilian _ kills " ) , result . getInt ( " deaths " ) , flags . toJSONString ( ) ) ; ResultSet idResult = to . query ( " SELECT ▁ id ▁ FROM ▁ ` sc2 _ players ` ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ) ; idResult . next ( ) ; players . add ( new ConvertedClanPlayer ( idResult . getLong ( " id " ) , name ) ) ; } }
 public long getClanPlayerIDbyName ( String tag ) { for ( ConvertedClanPlayer cp : players ) { if ( cp . getName ( ) . equals ( tag ) ) { return cp . getId ( ) ; } } return - 1 ; }
 @ Override @ RequirePOST public Item doCreateItem ( StaplerRequest req , StaplerResponse rsp ) throws IOException , ServletException { ItemGroup < ? extends TopLevelItem > ig = getOwnerItemGroup ( ) ; if ( ig instanceof ModifiableItemGroup ) { TopLevelItem item = ( ( ModifiableItemGroup < ? extends TopLevelItem > ) ig ) . doCreateItem ( req , rsp ) ; if ( item != null ) { synchronized ( this ) { jobNames . add ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; } owner . save ( ) ; } return item ; } return null ; }
 private void renameViewItem ( String oldFullName , String newFullName , ViewGroup vg , ListView lv ) { boolean needsSave ; synchronized ( lv ) { Set < String > oldJobNames = new HashSet < String > ( lv . jobNames ) ; lv . jobNames . clear ( ) ; for ( String oldName : oldJobNames ) { lv . jobNames . add ( Items . computeRelativeNamesAfterRenaming ( oldFullName , newFullName , oldName , vg . getItemGroup ( ) ) ) ; } needsSave = ! oldJobNames . equals ( lv . jobNames ) ; } if ( needsSave ) { try { lv . save ( ) ; } catch ( IOException x ) { Logger . getLogger ( ListView . class . getName ( ) ) . log ( Level . WARNING , null , x ) ; } } }
 private void locationChanged ( Item item , String oldFullName , String newFullName ) { final Jenkins jenkins = Jenkins . getInstance ( ) ; for ( View view : jenkins . getViews ( ) ) { if ( view instanceof ListView ) { renameViewItem ( oldFullName , newFullName , jenkins , ( ListView ) view ) ; } } for ( Item g : jenkins . getAllItems ( ) ) { if ( g instanceof ViewGroup ) { ViewGroup vg = ( ViewGroup ) g ; for ( View v : vg . getViews ( ) ) { if ( v instanceof ListView ) { renameViewItem ( oldFullName , newFullName , vg , ( ListView ) v ) ; } } } } }
 public void insertKill ( String attacker , String attacker_clan , String victim , String victim_clan , String type , boolean war , Timestamp date ) throws SQLException { long attackerID = getClanPlayerIDbyName ( attacker ) ; if ( attackerID == - 1 ) { return ; } long victimID = getClanPlayerIDbyName ( victim ) ; if ( victimID == - 1 ) { return ; } insertKill . setLong ( 1 , attackerID ) ; insertKill . setLong ( 2 , getIDByTag ( attacker_clan ) ) ; insertKill . setLong ( 3 , victimID ) ; insertKill . setLong ( 4 , getIDByTag ( victim_clan ) ) ; KillType realType ; switch ( type . charAt ( 0 ) ) { case ' c ' : realType = KillType . CIVILIAN ; break ; case ' n ' : realType = KillType . NEUTRAL ; break ; case ' r ' : realType = KillType . RIVAL ; break ; default : throw new UnsupportedOperationException ( " Failed ▁ at ▁ inserting ▁ kill ! ▁ Type ▁ not ▁ found : ▁ " + type ) ; } insertKill . setByte ( 5 , realType . getType ( ) ) ; insertKill . setBoolean ( 6 , war ) ; insertKill . setTimestamp ( 7 , date ) ; insertKill . executeUpdate ( ) ; }
 public void write ( byte [ ] bytes ) { try { mOutStream . write ( bytes ) ; } catch ( IOException e ) { } }
 @ Override public void run ( ) { locationChanged ( item , oldFullName , newFullName ) ; }
 public Boolean getStatusFilter ( ) { return statusFilter ; }
 public void convertClans ( ) throws SQLException { ResultSet result = from . query ( " SELECT ▁ * ▁ FROM ▁ ` sc _ clans ` ; " ) ; while ( result . next ( ) ) { JSONObject flags = new JSONObject ( ) ; String name = result . getString ( " name " ) ; String tag = result . getString ( " tag " ) ; boolean verified = result . getBoolean ( " verified " ) ; boolean friendly_fire = result . getBoolean ( " friendly _ fire " ) ; long founded = result . getLong ( " founded " ) ; long last_used = result . getLong ( " last _ used " ) ; String flagsString = result . getString ( " flags " ) ; String cape = result . getString ( " cape _ url " ) ; ConvertedClan clan = new ConvertedClan ( tag ) ; clan . setPackedAllies ( result . getString ( " packed _ allies " ) ) ; clan . serPackedRivals ( result . getString ( " packed _ rivals " ) ) ; if ( friendly_fire ) { flags . put ( " ff " , friendly_fire ) ; } if ( cape != null && ! cape . isEmpty ( ) ) { flags . put ( " cape - url " , cape ) ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject object = ( JSONObject ) parser . parse ( flagsString ) ; String world = object . get ( " homeWorld " ) . toString ( ) ; if ( ! world . isEmpty ( ) ) { int x = ( ( Long ) object . get ( " homeX " ) ) . intValue ( ) ; int y = ( ( Long ) object . get ( " homeY " ) ) . intValue ( ) ; int z = ( ( Long ) object . get ( " homeZ " ) ) . intValue ( ) ; flags . put ( " home " , x + " : " + y + " : " + z + " : " + world + " : 0:0" ) ; } clan . setRawWarring ( ( JSONArray ) object . get ( " warring " ) ) ; } catch ( ParseException e ) { Logging . debug ( e , true ) ; continue ; } insertClan ( name , tag , verified , founded , last_used , flags . isEmpty ( ) ? null : flags . toJSONString ( ) , result . getDouble ( " balance " ) ) ; String selectLastQuery = " SELECT ▁ ` id ` ▁ FROM ▁ ` sc2 _ clans ` ▁ ORDER ▁ BY ▁ ID ▁ DESC ▁ LIMIT ▁ 1 ; " ; ResultSet selectLast = to . query ( selectLastQuery ) ; selectLast . next ( ) ; clan . setId ( selectLast . getLong ( " id " ) ) ; selectLast . close ( ) ; insertBB ( Arrays . asList ( result . getString ( " packed _ bb " ) . split ( " \\ s * ( \\ | | $ ) " ) ) , clan . getId ( ) ) ; clans . add ( clan ) ; } for ( ConvertedClan clan : clans ) { JSONArray allies = new JSONArray ( ) ; JSONArray rivals = new JSONArray ( ) ; JSONArray warring = new JSONArray ( ) ; for ( String allyTag : clan . getRawAllies ( ) ) { long allyID = getIDByTag ( allyTag ) ; if ( allyID != - 1 ) { allies . add ( allyID ) ; } } for ( String rivalTag : clan . getRawAllies ( ) ) { long rivalID = getIDByTag ( rivalTag ) ; if ( rivalID != - 1 ) { rivals . add ( rivalID ) ; } } for ( String warringTag : clan . getRawWarring ( ) ) { long warringID = getIDByTag ( warringTag ) ; if ( warringID != - 1 ) { warring . add ( warringID ) ; } } if ( ! allies . isEmpty ( ) ) { updateClan . setString ( 1 , allies . toJSONString ( ) ) ; } else { updateClan . setNull ( 1 , Types . VARCHAR ) ; } if ( ! rivals . isEmpty ( ) ) { updateClan . setString ( 2 , rivals . toJSONString ( ) ) ; } else { updateClan . setNull ( 2 , Types . VARCHAR ) ; } if ( ! warring . isEmpty ( ) ) { updateClan . setString ( 3 , warring . toJSONString ( ) ) ; } else { updateClan . setNull ( 3 , Types . VARCHAR ) ; } updateClan . setLong ( 4 , clan . getId ( ) ) ; updateClan . executeUpdate ( ) ; } }
 @ Override public boolean put ( K key , V value ) { boolean putSuccesfully = cache . put ( key , value ) ; if ( putSuccesfully ) { loadingDates . put ( key , System . currentTimeMillis ( ) ) ; } return putSuccesfully ; }
 @ Override protected void submit ( StaplerRequest req ) throws ServletException , FormException , IOException { JSONObject json = req . getSubmittedForm ( ) ; synchronized ( this ) { recurse = json . optBoolean ( " recurse " , true ) ; jobNames . clear ( ) ; Iterable < ? extends TopLevelItem > items ; if ( recurse ) { items = Items . getAllItems ( getOwnerItemGroup ( ) , TopLevelItem . class ) ; } else { items = getOwnerItemGroup ( ) . getItems ( ) ; } for ( TopLevelItem item : items ) { String relativeNameFrom = item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ; if ( req . getParameter ( relativeNameFrom ) != null ) { jobNames . add ( relativeNameFrom ) ; } } } setIncludeRegex ( req . getParameter ( " useincluderegex " ) != null ? req . getParameter ( " includeRegex " ) : null ) ; if ( columns == null ) { columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this ) ; } columns . rebuildHetero ( req , json , ListViewColumn . all ( ) , " columns " ) ; if ( jobFilters == null ) { jobFilters = new DescribableList < ViewJobFilter , Descriptor < ViewJobFilter > > ( this ) ; } jobFilters . rebuildHetero ( req , json , ViewJobFilter . all ( ) , " jobFilters " ) ; String filter = Util . fixEmpty ( req . getParameter ( " statusFilter " ) ) ; statusFilter = filter != null ? "1" . equals ( filter ) : null ; }
 @ Override public void onDeleted ( final Item item ) { ACL . impersonate ( ACL . SYSTEM , new Runnable ( ) { @ Override public void run ( ) { deleted ( item ) ; } } ) ; }
 public synchronized boolean jobNamesContains ( TopLevelItem item ) { if ( item == null ) return false ; return jobNames . contains ( item . getRelativeNameFrom ( getOwnerItemGroup ( ) ) ) ; }
 private void includeItems ( ItemGroup < ? extends TopLevelItem > root , Collection < ? extends Item > parentItems , SortedSet < String > names ) { if ( includePattern != null ) { for ( Item item : parentItems ) { if ( recurse && item instanceof ItemGroup ) { ItemGroup < ? > ig = ( ItemGroup < ? > ) item ; includeItems ( root , ig . getItems ( ) , names ) ; } if ( item instanceof TopLevelItem ) { String itemName = item . getRelativeNameFrom ( root ) ; if ( includePattern . matcher ( itemName ) . matches ( ) ) { names . add ( itemName ) ; } } } } }
 @ Override public String toString ( ) { return S . toString ( GridJobSiblingsResponse . class , this ) ; }
 public boolean hasJobFilterExtensions ( ) { return ! ViewJobFilter . all ( ) . isEmpty ( ) ; }
 protected void initColumns ( ) { if ( columns == null ) columns = new DescribableList < ListViewColumn , Descriptor < ListViewColumn > > ( this , ListViewColumn . createDefaultInitialColumnList ( ) ) ; }
 @ Override public boolean readFrom ( ByteBuffer buf , MessageReader reader ) { reader . setBuffer ( buf ) ; if ( ! reader . beforeMessageRead ( ) ) return false ; switch ( reader . state ( ) ) { case 0 : siblingsBytes = reader . readByteArray ( " siblingsBytes " ) ; if ( ! reader . isLastRead ( ) ) return false ; reader . incrementState ( ) ; } return reader . afterMessageRead ( GridJobSiblingsResponse . class ) ; }
